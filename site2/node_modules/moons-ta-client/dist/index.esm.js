var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/esbuild-plugin-polyfill-node/polyfills/__dirname.js
var init_dirname = __esm({
  "node_modules/esbuild-plugin-polyfill-node/polyfills/__dirname.js"() {
  }
});

// node_modules/@jspm/core/nodelibs/browser/process.js
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
function hrtime(previousTimestamp) {
  var baseNow = Math.floor((Date.now() - _performance.now()) * 1e-3);
  var clocktime = _performance.now() * 1e-3;
  var seconds = Math.floor(clocktime) + baseNow;
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += nanoPerSec;
    }
  }
  return [seconds, nanoseconds];
}
var env, _performance, nowOffset, nanoPerSec;
var init_process = __esm({
  "node_modules/@jspm/core/nodelibs/browser/process.js"() {
    init_dirname();
    init_buffer2();
    init_process2();
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    env = {
      PATH: "/usr/bin",
      LANG: navigator.language + ".UTF-8",
      PWD: "/",
      HOME: "/home",
      TMP: "/tmp"
    };
    _performance = {
      now: typeof performance !== "undefined" ? performance.now.bind(performance) : void 0,
      timing: typeof performance !== "undefined" ? performance.timing : void 0
    };
    if (_performance.now === void 0) {
      nowOffset = Date.now();
      if (_performance.timing && _performance.timing.navigationStart) {
        nowOffset = _performance.timing.navigationStart;
      }
      _performance.now = () => Date.now() - nowOffset;
    }
    nanoPerSec = 1e9;
    hrtime.bigint = function(time) {
      var diff = hrtime(time);
      if (typeof BigInt === "undefined") {
        return diff[0] * nanoPerSec + diff[1];
      }
      return BigInt(diff[0] * nanoPerSec) + BigInt(diff[1]);
    };
  }
});

// node_modules/esbuild-plugin-polyfill-node/polyfills/process.js
var init_process2 = __esm({
  "node_modules/esbuild-plugin-polyfill-node/polyfills/process.js"() {
    init_process();
  }
});

// node_modules/@jspm/core/nodelibs/browser/buffer.js
function dew$2() {
  if (_dewExec$2)
    return exports$3;
  _dewExec$2 = true;
  exports$3.byteLength = byteLength;
  exports$3.toByteArray = toByteArray;
  exports$3.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i2 = 0, len = code.length; i2 < len; ++i2) {
    lookup[i2] = code[i2];
    revLookup[code.charCodeAt(i2)] = i2;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i3;
    for (i3 = 0; i3 < len2; i3 += 4) {
      tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i3 = start; i3 < end; i3 += 3) {
      tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
  return exports$3;
}
function dew$1() {
  if (_dewExec$1)
    return exports$2;
  _dewExec$1 = true;
  exports$2.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e2, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i2 = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s2 = buffer[offset + i2];
    i2 += d;
    e2 = s2 & (1 << -nBits) - 1;
    s2 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
    }
    m = e2 & (1 << -nBits) - 1;
    e2 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
    }
    if (e2 === 0) {
      e2 = 1 - eBias;
    } else if (e2 === eMax) {
      return m ? NaN : (s2 ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e2 = e2 - eBias;
    }
    return (s2 ? -1 : 1) * m * Math.pow(2, e2 - mLen);
  };
  exports$2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e2, m, c2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i2 = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e2 = eMax;
    } else {
      e2 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c2 = Math.pow(2, -e2)) < 1) {
        e2--;
        c2 *= 2;
      }
      if (e2 + eBias >= 1) {
        value += rt / c2;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c2 >= 2) {
        e2++;
        c2 /= 2;
      }
      if (e2 + eBias >= eMax) {
        m = 0;
        e2 = eMax;
      } else if (e2 + eBias >= 1) {
        m = (value * c2 - 1) * Math.pow(2, mLen);
        e2 = e2 + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e2 = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
    }
    e2 = e2 << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i2] = e2 & 255, i2 += d, e2 /= 256, eLen -= 8) {
    }
    buffer[offset + i2 - d] |= s2 * 128;
  };
  return exports$2;
}
function dew() {
  if (_dewExec)
    return exports$1;
  _dewExec = true;
  const base64 = dew$2();
  const ieee754 = dew$1();
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports$1.Buffer = Buffer3;
  exports$1.SlowBuffer = SlowBuffer;
  exports$1.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports$1.kMaxLength = K_MAX_LENGTH;
  Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = {
        foo: function() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer3.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer3.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function Buffer3(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer3.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer3.from(valueOf, encodingOrOffset, length);
    }
    const b = fromObject(value);
    if (b)
      return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer3.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer3, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer3.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer3.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer3.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer3.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i2 = 0; i2 < length; i2 += 1) {
      buf[i2] = array[i2] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer3.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer3.alloc(+length);
  }
  Buffer3.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer3.prototype;
  };
  Buffer3.compare = function compare(a2, b) {
    if (isInstance(a2, Uint8Array))
      a2 = Buffer3.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b, Uint8Array))
      b = Buffer3.from(b, b.offset, b.byteLength);
    if (!Buffer3.isBuffer(a2) || !Buffer3.isBuffer(b)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a2 === b)
      return 0;
    let x = a2.length;
    let y2 = b.length;
    for (let i2 = 0, len = Math.min(x, y2); i2 < len; ++i2) {
      if (a2[i2] !== b[i2]) {
        x = a2[i2];
        y2 = b[i2];
        break;
      }
    }
    if (x < y2)
      return -1;
    if (y2 < x)
      return 1;
    return 0;
  };
  Buffer3.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer3.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer3.alloc(0);
    }
    let i2;
    if (length === void 0) {
      length = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length += list[i2].length;
      }
    }
    const buffer = Buffer3.allocUnsafe(length);
    let pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      let buf = list[i2];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer.length) {
          if (!Buffer3.isBuffer(buf))
            buf = Buffer3.from(buf);
          buf.copy(buffer, pos);
        } else {
          Uint8Array.prototype.set.call(buffer, buf, pos);
        }
      } else if (!Buffer3.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer, pos);
      }
      pos += buf.length;
    }
    return buffer;
  };
  function byteLength(string, encoding) {
    if (Buffer3.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.prototype._isBuffer = true;
  function swap(b, n2, m) {
    const i2 = b[n2];
    b[n2] = b[m];
    b[m] = i2;
  }
  Buffer3.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i2 = 0; i2 < len; i2 += 2) {
      swap(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer3.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i2 = 0; i2 < len; i2 += 4) {
      swap(this, i2, i2 + 3);
      swap(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer3.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i2 = 0; i2 < len; i2 += 8) {
      swap(this, i2, i2 + 7);
      swap(this, i2 + 1, i2 + 6);
      swap(this, i2 + 2, i2 + 5);
      swap(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer3.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
  Buffer3.prototype.equals = function equals(b) {
    if (!Buffer3.isBuffer(b))
      throw new TypeError("Argument must be a Buffer");
    if (this === b)
      return true;
    return Buffer3.compare(this, b) === 0;
  };
  Buffer3.prototype.inspect = function inspect() {
    let str = "";
    const max = exports$1.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
  }
  Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer3.from(target, target.offset, target.byteLength);
    }
    if (!Buffer3.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x = thisEnd - thisStart;
    let y2 = end - start;
    const len = Math.min(x, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i2 = 0; i2 < len; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x = thisCopy[i2];
        y2 = targetCopy[i2];
        break;
      }
    }
    if (x < y2)
      return -1;
    if (y2 < x)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    if (buffer.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer3.from(val, encoding);
    }
    if (Buffer3.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i3) {
      if (indexSize === 1) {
        return buf[i3];
      } else {
        return buf.readUInt16BE(i3 * indexSize);
      }
    }
    let i2;
    if (dir) {
      let foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        let found = true;
        for (let j = 0; j < valLength; j++) {
          if (read(arr, i2 + j) !== read(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i2;
    for (i2 = 0; i2 < length; ++i2) {
      const parsed = parseInt(string.substr(i2 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i2;
      buf[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer3.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer3.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i2 = start;
    while (i2 < end) {
      const firstByte = buf[i2];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i2 = 0;
    while (i2 < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = "";
    for (let i2 = start; i2 < end; ++i2) {
      out += hexSliceLookupTable[buf[i2]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
      res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
    }
    return res;
  }
  Buffer3.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer3.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i2 = 0;
    while (++i2 < byteLength2 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    let val = this[offset + --byteLength2];
    let mul = 1;
    while (byteLength2 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength2] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i2 = 0;
    while (++i2 < byteLength2 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    let i2 = byteLength2;
    let mul = 1;
    let val = this[offset + --i2];
    while (i2 > 0 && (mul *= 256)) {
      val += this[offset + --i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer3.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let mul = 1;
    let i2 = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength2 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let i2 = byteLength2 - 1;
    let mul = 1;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i2 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i2 = byteLength2 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer3.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer3.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code = val.charCodeAt(0);
        if (encoding === "utf8" && code < 128 || encoding === "latin1") {
          val = code;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i2;
    if (typeof val === "number") {
      for (i2 = start; i2 < end; ++i2) {
        this[i2] = val;
      }
    } else {
      const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i2 = 0; i2 < end - start; ++i2) {
        this[i2 + start] = bytes[i2 % len];
      }
    }
    return this;
  };
  const errors = {};
  function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
    if (name2) {
      return `${name2} is outside of buffer bounds`;
    }
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  E("ERR_INVALID_ARG_TYPE", function(name2, actual) {
    return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
  }, TypeError);
  E("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    let res = "";
    let i2 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i2 >= start + 4; i2 -= 3) {
      res = `_${val.slice(i2 - 3, i2)}${res}`;
    }
    return `${val.slice(0, i2)}${res}`;
  }
  function checkBounds(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
      boundsError(offset, buf.length - (byteLength2 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
      const n2 = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength2 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n2} and < 2${n2} ** ${(byteLength2 + 1) * 8}${n2}`;
        } else {
          range = `>= -(2${n2} ** ${(byteLength2 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n2}`;
        }
      } else {
        range = `>= ${min}${n2} and <= ${max}${n2}`;
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i2 = 0; i2 < length; ++i2) {
      codePoint = string.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      byteArray.push(str.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c2, hi, lo;
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i2);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i2;
    for (i2 = 0; i2 < length; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src.length)
        break;
      dst[i2 + offset] = src[i2];
    }
    return i2;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i2 = 0; i2 < 16; ++i2) {
      const i16 = i2 * 16;
      for (let j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i2] + alphabet[j];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
  return exports$1;
}
var exports$3, _dewExec$2, exports$2, _dewExec$1, exports$1, _dewExec, exports, Buffer2, INSPECT_MAX_BYTES, kMaxLength;
var init_buffer = __esm({
  "node_modules/@jspm/core/nodelibs/browser/buffer.js"() {
    init_dirname();
    init_buffer2();
    init_process2();
    exports$3 = {};
    _dewExec$2 = false;
    exports$2 = {};
    _dewExec$1 = false;
    exports$1 = {};
    _dewExec = false;
    exports = dew();
    exports["Buffer"];
    exports["SlowBuffer"];
    exports["INSPECT_MAX_BYTES"];
    exports["kMaxLength"];
    Buffer2 = exports.Buffer;
    INSPECT_MAX_BYTES = exports.INSPECT_MAX_BYTES;
    kMaxLength = exports.kMaxLength;
  }
});

// node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js
var init_buffer2 = __esm({
  "node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js"() {
    init_buffer();
  }
});

// globals:ws
var require_ws = __commonJS({
  "globals:ws"(exports2, module) {
    init_dirname();
    init_buffer2();
    init_process2();
    module.exports = WebSocket;
  }
});

// src/index.ts
init_dirname();
init_buffer2();
init_process2();

// src/tournament-assistant-client.ts
init_dirname();
init_buffer2();
init_process2();

// src/client.ts
init_dirname();
init_buffer2();
init_process2();

// src/custom-event-emitter.ts
init_dirname();
init_buffer2();
init_process2();

// node_modules/@jspm/core/nodelibs/browser/events.js
init_dirname();
init_buffer2();
init_process2();

// node_modules/@jspm/core/nodelibs/browser/chunk-4bd36a8f.js
init_dirname();
init_buffer2();
init_process2();
var e;
var t;
var n = "object" == typeof Reflect ? Reflect : null;
var r = n && "function" == typeof n.apply ? n.apply : function(e2, t2, n2) {
  return Function.prototype.apply.call(e2, t2, n2);
};
t = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function(e2) {
  return Object.getOwnPropertyNames(e2).concat(Object.getOwnPropertySymbols(e2));
} : function(e2) {
  return Object.getOwnPropertyNames(e2);
};
var i = Number.isNaN || function(e2) {
  return e2 != e2;
};
function o() {
  o.init.call(this);
}
e = o, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
var s = 10;
function u(e2) {
  if ("function" != typeof e2)
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e2);
}
function f(e2) {
  return void 0 === e2._maxListeners ? o.defaultMaxListeners : e2._maxListeners;
}
function v(e2, t2, n2, r2) {
  var i2, o2, s2, v2;
  if (u(n2), void 0 === (o2 = e2._events) ? (o2 = e2._events = /* @__PURE__ */ Object.create(null), e2._eventsCount = 0) : (void 0 !== o2.newListener && (e2.emit("newListener", t2, n2.listener ? n2.listener : n2), o2 = e2._events), s2 = o2[t2]), void 0 === s2)
    s2 = o2[t2] = n2, ++e2._eventsCount;
  else if ("function" == typeof s2 ? s2 = o2[t2] = r2 ? [n2, s2] : [s2, n2] : r2 ? s2.unshift(n2) : s2.push(n2), (i2 = f(e2)) > 0 && s2.length > i2 && !s2.warned) {
    s2.warned = true;
    var a2 = new Error("Possible EventEmitter memory leak detected. " + s2.length + " " + String(t2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a2.name = "MaxListenersExceededWarning", a2.emitter = e2, a2.type = t2, a2.count = s2.length, v2 = a2, console && console.warn && console.warn(v2);
  }
  return e2;
}
function a() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function l(e2, t2, n2) {
  var r2 = { fired: false, wrapFn: void 0, target: e2, type: t2, listener: n2 }, i2 = a.bind(r2);
  return i2.listener = n2, r2.wrapFn = i2, i2;
}
function h(e2, t2, n2) {
  var r2 = e2._events;
  if (void 0 === r2)
    return [];
  var i2 = r2[t2];
  return void 0 === i2 ? [] : "function" == typeof i2 ? n2 ? [i2.listener || i2] : [i2] : n2 ? function(e3) {
    for (var t3 = new Array(e3.length), n3 = 0; n3 < t3.length; ++n3)
      t3[n3] = e3[n3].listener || e3[n3];
    return t3;
  }(i2) : c(i2, i2.length);
}
function p(e2) {
  var t2 = this._events;
  if (void 0 !== t2) {
    var n2 = t2[e2];
    if ("function" == typeof n2)
      return 1;
    if (void 0 !== n2)
      return n2.length;
  }
  return 0;
}
function c(e2, t2) {
  for (var n2 = new Array(t2), r2 = 0; r2 < t2; ++r2)
    n2[r2] = e2[r2];
  return n2;
}
Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
  return s;
}, set: function(e2) {
  if ("number" != typeof e2 || e2 < 0 || i(e2))
    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e2 + ".");
  s = e2;
} }), o.init = function() {
  void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, o.prototype.setMaxListeners = function(e2) {
  if ("number" != typeof e2 || e2 < 0 || i(e2))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e2 + ".");
  return this._maxListeners = e2, this;
}, o.prototype.getMaxListeners = function() {
  return f(this);
}, o.prototype.emit = function(e2) {
  for (var t2 = [], n2 = 1; n2 < arguments.length; n2++)
    t2.push(arguments[n2]);
  var i2 = "error" === e2, o2 = this._events;
  if (void 0 !== o2)
    i2 = i2 && void 0 === o2.error;
  else if (!i2)
    return false;
  if (i2) {
    var s2;
    if (t2.length > 0 && (s2 = t2[0]), s2 instanceof Error)
      throw s2;
    var u2 = new Error("Unhandled error." + (s2 ? " (" + s2.message + ")" : ""));
    throw u2.context = s2, u2;
  }
  var f2 = o2[e2];
  if (void 0 === f2)
    return false;
  if ("function" == typeof f2)
    r(f2, this, t2);
  else {
    var v2 = f2.length, a2 = c(f2, v2);
    for (n2 = 0; n2 < v2; ++n2)
      r(a2[n2], this, t2);
  }
  return true;
}, o.prototype.addListener = function(e2, t2) {
  return v(this, e2, t2, false);
}, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(e2, t2) {
  return v(this, e2, t2, true);
}, o.prototype.once = function(e2, t2) {
  return u(t2), this.on(e2, l(this, e2, t2)), this;
}, o.prototype.prependOnceListener = function(e2, t2) {
  return u(t2), this.prependListener(e2, l(this, e2, t2)), this;
}, o.prototype.removeListener = function(e2, t2) {
  var n2, r2, i2, o2, s2;
  if (u(t2), void 0 === (r2 = this._events))
    return this;
  if (void 0 === (n2 = r2[e2]))
    return this;
  if (n2 === t2 || n2.listener === t2)
    0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r2[e2], r2.removeListener && this.emit("removeListener", e2, n2.listener || t2));
  else if ("function" != typeof n2) {
    for (i2 = -1, o2 = n2.length - 1; o2 >= 0; o2--)
      if (n2[o2] === t2 || n2[o2].listener === t2) {
        s2 = n2[o2].listener, i2 = o2;
        break;
      }
    if (i2 < 0)
      return this;
    0 === i2 ? n2.shift() : !function(e3, t3) {
      for (; t3 + 1 < e3.length; t3++)
        e3[t3] = e3[t3 + 1];
      e3.pop();
    }(n2, i2), 1 === n2.length && (r2[e2] = n2[0]), void 0 !== r2.removeListener && this.emit("removeListener", e2, s2 || t2);
  }
  return this;
}, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(e2) {
  var t2, n2, r2;
  if (void 0 === (n2 = this._events))
    return this;
  if (void 0 === n2.removeListener)
    return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n2[e2] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n2[e2]), this;
  if (0 === arguments.length) {
    var i2, o2 = Object.keys(n2);
    for (r2 = 0; r2 < o2.length; ++r2)
      "removeListener" !== (i2 = o2[r2]) && this.removeAllListeners(i2);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if ("function" == typeof (t2 = n2[e2]))
    this.removeListener(e2, t2);
  else if (void 0 !== t2)
    for (r2 = t2.length - 1; r2 >= 0; r2--)
      this.removeListener(e2, t2[r2]);
  return this;
}, o.prototype.listeners = function(e2) {
  return h(this, e2, true);
}, o.prototype.rawListeners = function(e2) {
  return h(this, e2, false);
}, o.listenerCount = function(e2, t2) {
  return "function" == typeof e2.listenerCount ? e2.listenerCount(t2) : p.call(e2, t2);
}, o.prototype.listenerCount = p, o.prototype.eventNames = function() {
  return this._eventsCount > 0 ? t(this._events) : [];
};
var y = e;
y.EventEmitter;
y.defaultMaxListeners;
y.init;
y.listenerCount;
y.EventEmitter;
y.defaultMaxListeners;
y.init;
y.listenerCount;

// node_modules/@jspm/core/nodelibs/browser/events.js
y.once = function(emitter, event) {
  return new Promise((resolve, reject) => {
    function eventListener(...args) {
      if (errorListener !== void 0) {
        emitter.removeListener("error", errorListener);
      }
      resolve(args);
    }
    let errorListener;
    if (event !== "error") {
      errorListener = (err) => {
        emitter.removeListener(name, eventListener);
        reject(err);
      };
      emitter.once("error", errorListener);
    }
    emitter.once(event, eventListener);
  });
};
y.on = function(emitter, event) {
  const unconsumedEventValues = [];
  const unconsumedPromises = [];
  let error = null;
  let finished = false;
  const iterator = {
    async next() {
      const value = unconsumedEventValues.shift();
      if (value) {
        return createIterResult(value, false);
      }
      if (error) {
        const p2 = Promise.reject(error);
        error = null;
        return p2;
      }
      if (finished) {
        return createIterResult(void 0, true);
      }
      return new Promise((resolve, reject) => unconsumedPromises.push({ resolve, reject }));
    },
    async return() {
      emitter.removeListener(event, eventHandler);
      emitter.removeListener("error", errorHandler);
      finished = true;
      for (const promise of unconsumedPromises) {
        promise.resolve(createIterResult(void 0, true));
      }
      return createIterResult(void 0, true);
    },
    throw(err) {
      error = err;
      emitter.removeListener(event, eventHandler);
      emitter.removeListener("error", errorHandler);
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
  emitter.on(event, eventHandler);
  emitter.on("error", errorHandler);
  return iterator;
  function eventHandler(...args) {
    const promise = unconsumedPromises.shift();
    if (promise) {
      promise.resolve(createIterResult(args, false));
    } else {
      unconsumedEventValues.push(args);
    }
  }
  function errorHandler(err) {
    finished = true;
    const toError = unconsumedPromises.shift();
    if (toError) {
      toError.reject(err);
    } else {
      error = err;
    }
    iterator.return();
  }
};
var {
  EventEmitter,
  defaultMaxListeners,
  init,
  listenerCount,
  on,
  once
} = y;

// src/custom-event-emitter.ts
var CustomEventEmitter = class {
  emitter = new EventEmitter();
  get on() {
    return this.emitter.on.bind(this.emitter);
  }
  get once() {
    return this.emitter.once.bind(this.emitter);
  }
  get emit() {
    return this.emitter.emit.bind(this.emitter);
  }
  get removeListener() {
    return this.emitter.removeListener.bind(this.emitter);
  }
};

// src/models/packets.ts
init_dirname();
init_buffer2();
init_process2();

// node_modules/@protobuf-ts/runtime/build/es2015/index.js
init_dirname();
init_buffer2();
init_process2();

// node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js
init_dirname();
init_buffer2();
init_process2();
function typeofJsonValue(value) {
  let t2 = typeof value;
  if (t2 == "object") {
    if (Array.isArray(value))
      return "array";
    if (value === null)
      return "null";
  }
  return t2;
}
function isJsonObject(value) {
  return value !== null && typeof value == "object" && !Array.isArray(value);
}

// node_modules/@protobuf-ts/runtime/build/es2015/base64.js
init_dirname();
init_buffer2();
init_process2();
var encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
var decTable = [];
for (let i2 = 0; i2 < encTable.length; i2++)
  decTable[encTable[i2].charCodeAt(0)] = i2;
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
function base64decode(base64Str) {
  let es = base64Str.length * 3 / 4;
  if (base64Str[base64Str.length - 2] == "=")
    es -= 2;
  else if (base64Str[base64Str.length - 1] == "=")
    es -= 1;
  let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p2 = 0;
  for (let i2 = 0; i2 < base64Str.length; i2++) {
    b = decTable[base64Str.charCodeAt(i2)];
    if (b === void 0) {
      switch (base64Str[i2]) {
        case "=":
          groupPos = 0;
        case "\n":
        case "\r":
        case "	":
        case " ":
          continue;
        default:
          throw Error(`invalid base64 string.`);
      }
    }
    switch (groupPos) {
      case 0:
        p2 = b;
        groupPos = 1;
        break;
      case 1:
        bytes[bytePos++] = p2 << 2 | (b & 48) >> 4;
        p2 = b;
        groupPos = 2;
        break;
      case 2:
        bytes[bytePos++] = (p2 & 15) << 4 | (b & 60) >> 2;
        p2 = b;
        groupPos = 3;
        break;
      case 3:
        bytes[bytePos++] = (p2 & 3) << 6 | b;
        groupPos = 0;
        break;
    }
  }
  if (groupPos == 1)
    throw Error(`invalid base64 string.`);
  return bytes.subarray(0, bytePos);
}
function base64encode(bytes) {
  let base64 = "", groupPos = 0, b, p2 = 0;
  for (let i2 = 0; i2 < bytes.length; i2++) {
    b = bytes[i2];
    switch (groupPos) {
      case 0:
        base64 += encTable[b >> 2];
        p2 = (b & 3) << 4;
        groupPos = 1;
        break;
      case 1:
        base64 += encTable[p2 | b >> 4];
        p2 = (b & 15) << 2;
        groupPos = 2;
        break;
      case 2:
        base64 += encTable[p2 | b >> 6];
        base64 += encTable[b & 63];
        groupPos = 0;
        break;
    }
  }
  if (groupPos) {
    base64 += encTable[p2];
    base64 += "=";
    if (groupPos == 1)
      base64 += "=";
  }
  return base64;
}

// node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js
init_dirname();
init_buffer2();
init_process2();
var UnknownFieldHandler;
(function(UnknownFieldHandler2) {
  UnknownFieldHandler2.symbol = Symbol.for("protobuf-ts/unknown");
  UnknownFieldHandler2.onRead = (typeName, message, fieldNo, wireType, data) => {
    let container = is(message) ? message[UnknownFieldHandler2.symbol] : message[UnknownFieldHandler2.symbol] = [];
    container.push({ no: fieldNo, wireType, data });
  };
  UnknownFieldHandler2.onWrite = (typeName, message, writer) => {
    for (let { no, wireType, data } of UnknownFieldHandler2.list(message))
      writer.tag(no, wireType).raw(data);
  };
  UnknownFieldHandler2.list = (message, fieldNo) => {
    if (is(message)) {
      let all = message[UnknownFieldHandler2.symbol];
      return fieldNo ? all.filter((uf) => uf.no == fieldNo) : all;
    }
    return [];
  };
  UnknownFieldHandler2.last = (message, fieldNo) => UnknownFieldHandler2.list(message, fieldNo).slice(-1)[0];
  const is = (message) => message && Array.isArray(message[UnknownFieldHandler2.symbol]);
})(UnknownFieldHandler || (UnknownFieldHandler = {}));
var WireType;
(function(WireType2) {
  WireType2[WireType2["Varint"] = 0] = "Varint";
  WireType2[WireType2["Bit64"] = 1] = "Bit64";
  WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
  WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
  WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
  WireType2[WireType2["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));

// node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js
init_dirname();
init_buffer2();
init_process2();

// node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js
init_dirname();
init_buffer2();
init_process2();

// node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js
init_dirname();
init_buffer2();
init_process2();
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift = 0; shift < 28; shift += 7) {
    let b = this.buf[this.pos++];
    lowBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift = 3; shift <= 31; shift += 7) {
    let b = this.buf[this.pos++];
    highBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo, hi, bytes) {
  for (let i2 = 0; i2 < 28; i2 = i2 + 7) {
    const shift = lo >>> i2;
    const hasNext = !(shift >>> 7 == 0 && hi == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
  const hasMoreBits = !(hi >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i2 = 3; i2 < 31; i2 = i2 + 7) {
    const shift = hi >>> i2;
    const hasNext = !(shift >>> 7 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi >>> 31 & 1);
}
var TWO_PWR_32_DBL = (1 << 16) * (1 << 16);
function int64fromString(dec) {
  let minus = dec[0] == "-";
  if (minus)
    dec = dec.slice(1);
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end) {
    const digit1e6 = Number(dec.slice(begin, end));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
      lowBits = lowBits % TWO_PWR_32_DBL;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return [minus, lowBits, highBits];
}
function int64toString(bitsLow, bitsHigh) {
  if (bitsHigh >>> 0 <= 2097151) {
    return "" + (TWO_PWR_32_DBL * bitsHigh + (bitsLow >>> 0));
  }
  let low = bitsLow & 16777215;
  let mid = (bitsLow >>> 24 | bitsHigh << 8) >>> 0 & 16777215;
  let high = bitsHigh >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  let base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  function decimalFrom1e7(digit1e7, needLeadingZeros) {
    let partial = digit1e7 ? String(digit1e7) : "";
    if (needLeadingZeros) {
      return "0000000".slice(partial.length) + partial;
    }
    return partial;
  }
  return decimalFrom1e7(
    digitC,
    /*needLeadingZeros=*/
    0
  ) + decimalFrom1e7(
    digitB,
    /*needLeadingZeros=*/
    digitC
  ) + // If the final 1e7 digit didn't need leading zeros, we would have
  // returned via the trivial code path at the top.
  decimalFrom1e7(
    digitA,
    /*needLeadingZeros=*/
    1
  );
}
function varint32write(value, bytes) {
  if (value >= 0) {
    while (value > 127) {
      bytes.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes.push(value);
  } else {
    for (let i2 = 0; i2 < 9; i2++) {
      bytes.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes.push(1);
  }
}
function varint32read() {
  let b = this.buf[this.pos++];
  let result = b & 127;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 7;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 14;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 21;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 15) << 28;
  for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
    b = this.buf[this.pos++];
  if ((b & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}

// node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js
var BI;
function detectBi() {
  const dv = new DataView(new ArrayBuffer(8));
  const ok = globalThis.BigInt !== void 0 && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function";
  BI = ok ? {
    MIN: BigInt("-9223372036854775808"),
    MAX: BigInt("9223372036854775807"),
    UMIN: BigInt("0"),
    UMAX: BigInt("18446744073709551615"),
    C: BigInt,
    V: dv
  } : void 0;
}
detectBi();
function assertBi(bi) {
  if (!bi)
    throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
}
var RE_DECIMAL_STR = /^-?[0-9]+$/;
var TWO_PWR_32_DBL2 = 4294967296;
var HALF_2_PWR_32 = 2147483648;
var SharedPbLong = class {
  /**
   * Create a new instance with the given bits.
   */
  constructor(lo, hi) {
    this.lo = lo | 0;
    this.hi = hi | 0;
  }
  /**
   * Is this instance equal to 0?
   */
  isZero() {
    return this.lo == 0 && this.hi == 0;
  }
  /**
   * Convert to a native number.
   */
  toNumber() {
    let result = this.hi * TWO_PWR_32_DBL2 + (this.lo >>> 0);
    if (!Number.isSafeInteger(result))
      throw new Error("cannot convert to safe number");
    return result;
  }
};
var PbULong = class _PbULong extends SharedPbLong {
  /**
   * Create instance from a `string`, `number` or `bigint`.
   */
  static from(value) {
    if (BI)
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          if (value == "")
            throw new Error("string is no integer");
          value = BI.C(value);
        case "number":
          if (value === 0)
            return this.ZERO;
          value = BI.C(value);
        case "bigint":
          if (!value)
            return this.ZERO;
          if (value < BI.UMIN)
            throw new Error("signed value for ulong");
          if (value > BI.UMAX)
            throw new Error("ulong too large");
          BI.V.setBigUint64(0, value, true);
          return new _PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
      }
    else
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          value = value.trim();
          if (!RE_DECIMAL_STR.test(value))
            throw new Error("string is no integer");
          let [minus, lo, hi] = int64fromString(value);
          if (minus)
            throw new Error("signed value for ulong");
          return new _PbULong(lo, hi);
        case "number":
          if (value == 0)
            return this.ZERO;
          if (!Number.isSafeInteger(value))
            throw new Error("number is no integer");
          if (value < 0)
            throw new Error("signed value for ulong");
          return new _PbULong(value, value / TWO_PWR_32_DBL2);
      }
    throw new Error("unknown value " + typeof value);
  }
  /**
   * Convert to decimal string.
   */
  toString() {
    return BI ? this.toBigInt().toString() : int64toString(this.lo, this.hi);
  }
  /**
   * Convert to native bigint.
   */
  toBigInt() {
    assertBi(BI);
    BI.V.setInt32(0, this.lo, true);
    BI.V.setInt32(4, this.hi, true);
    return BI.V.getBigUint64(0, true);
  }
};
PbULong.ZERO = new PbULong(0, 0);
var PbLong = class _PbLong extends SharedPbLong {
  /**
   * Create instance from a `string`, `number` or `bigint`.
   */
  static from(value) {
    if (BI)
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          if (value == "")
            throw new Error("string is no integer");
          value = BI.C(value);
        case "number":
          if (value === 0)
            return this.ZERO;
          value = BI.C(value);
        case "bigint":
          if (!value)
            return this.ZERO;
          if (value < BI.MIN)
            throw new Error("signed long too small");
          if (value > BI.MAX)
            throw new Error("signed long too large");
          BI.V.setBigInt64(0, value, true);
          return new _PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
      }
    else
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          value = value.trim();
          if (!RE_DECIMAL_STR.test(value))
            throw new Error("string is no integer");
          let [minus, lo, hi] = int64fromString(value);
          if (minus) {
            if (hi > HALF_2_PWR_32 || hi == HALF_2_PWR_32 && lo != 0)
              throw new Error("signed long too small");
          } else if (hi >= HALF_2_PWR_32)
            throw new Error("signed long too large");
          let pbl = new _PbLong(lo, hi);
          return minus ? pbl.negate() : pbl;
        case "number":
          if (value == 0)
            return this.ZERO;
          if (!Number.isSafeInteger(value))
            throw new Error("number is no integer");
          return value > 0 ? new _PbLong(value, value / TWO_PWR_32_DBL2) : new _PbLong(-value, -value / TWO_PWR_32_DBL2).negate();
      }
    throw new Error("unknown value " + typeof value);
  }
  /**
   * Do we have a minus sign?
   */
  isNegative() {
    return (this.hi & HALF_2_PWR_32) !== 0;
  }
  /**
   * Negate two's complement.
   * Invert all the bits and add one to the result.
   */
  negate() {
    let hi = ~this.hi, lo = this.lo;
    if (lo)
      lo = ~lo + 1;
    else
      hi += 1;
    return new _PbLong(lo, hi);
  }
  /**
   * Convert to decimal string.
   */
  toString() {
    if (BI)
      return this.toBigInt().toString();
    if (this.isNegative()) {
      let n2 = this.negate();
      return "-" + int64toString(n2.lo, n2.hi);
    }
    return int64toString(this.lo, this.hi);
  }
  /**
   * Convert to native bigint.
   */
  toBigInt() {
    assertBi(BI);
    BI.V.setInt32(0, this.lo, true);
    BI.V.setInt32(4, this.hi, true);
    return BI.V.getBigInt64(0, true);
  }
};
PbLong.ZERO = new PbLong(0, 0);

// node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js
var defaultsRead = {
  readUnknownField: true,
  readerFactory: (bytes) => new BinaryReader(bytes)
};
function binaryReadOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
}
var BinaryReader = class {
  constructor(buf, textDecoder) {
    this.varint64 = varint64read;
    this.uint32 = varint32read;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder("utf-8", {
      fatal: true,
      ignoreBOM: true
    });
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
    if (fieldNo <= 0 || wireType < 0 || wireType > 5)
      throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
    return [fieldNo, wireType];
  }
  /**
   * Skip one element on the wire and return the skipped data.
   * Supports WireType.StartGroup since v2.0.0-alpha.23.
   */
  skip(wireType) {
    let start = this.pos;
    switch (wireType) {
      case WireType.Varint:
        while (this.buf[this.pos++] & 128) {
        }
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let len = this.uint32();
        this.pos += len;
        break;
      case WireType.StartGroup:
        let t2;
        while ((t2 = this.tag()[1]) !== WireType.EndGroup) {
          this.skip(t2);
        }
        break;
      default:
        throw new Error("cant skip wire type " + wireType);
    }
    this.assertBounds();
    return this.buf.subarray(start, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let zze = this.uint32();
    return zze >>> 1 ^ -(zze & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return new PbLong(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return new PbULong(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [lo, hi] = this.varint64();
    let s2 = -(lo & 1);
    lo = (lo >>> 1 | (hi & 1) << 31) ^ s2;
    hi = hi >>> 1 ^ s2;
    return new PbLong(lo, hi);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [lo, hi] = this.varint64();
    return lo !== 0 || hi !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return new PbULong(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return new PbLong(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let len = this.uint32();
    let start = this.pos;
    this.pos += len;
    this.assertBounds();
    return this.buf.subarray(start, start + len);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.textDecoder.decode(this.bytes());
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js
init_dirname();
init_buffer2();
init_process2();

// node_modules/@protobuf-ts/runtime/build/es2015/assert.js
init_dirname();
init_buffer2();
init_process2();
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}
var FLOAT32_MAX = 34028234663852886e22;
var FLOAT32_MIN = -34028234663852886e22;
var UINT32_MAX = 4294967295;
var INT32_MAX = 2147483647;
var INT32_MIN = -2147483648;
function assertInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid int 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int 32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid uint 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint 32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid float 32: " + typeof arg);
  if (!Number.isFinite(arg))
    return;
  if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
    throw new Error("invalid float 32: " + arg);
}

// node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js
var defaultsWrite = {
  writeUnknownFields: true,
  writerFactory: () => new BinaryWriter()
};
function binaryWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
}
var BinaryWriter = class {
  constructor(textEncoder) {
    this.stack = [];
    this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
    this.chunks = [];
    this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let len = 0;
    for (let i2 = 0; i2 < this.chunks.length; i2++)
      len += this.chunks[i2].length;
    let bytes = new Uint8Array(len);
    let offset = 0;
    for (let i2 = 0; i2 < this.chunks.length; i2++) {
      bytes.set(this.chunks[i2], offset);
      offset += this.chunks[i2].length;
    }
    this.chunks = [];
    return bytes;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    this.stack.push({ chunks: this.chunks, buf: this.buf });
    this.chunks = [];
    this.buf = [];
    return this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let chunk = this.finish();
    let prev = this.stack.pop();
    if (!prev)
      throw new Error("invalid state, fork stack empty");
    this.chunks = prev.chunks;
    this.buf = prev.buf;
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(fieldNo, type) {
    return this.uint32((fieldNo << 3 | type) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(chunk) {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    this.chunks.push(chunk);
    return this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(value) {
    assertUInt32(value);
    while (value > 127) {
      this.buf.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buf.push(value);
    return this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(value) {
    assertInt32(value);
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(value) {
    this.buf.push(value ? 1 : 0);
    return this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(value) {
    this.uint32(value.byteLength);
    return this.raw(value);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(value) {
    let chunk = this.textEncoder.encode(value);
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(value) {
    assertFloat32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setFloat32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(value) {
    let chunk = new Uint8Array(8);
    new DataView(chunk.buffer).setFloat64(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(value) {
    assertUInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setUint32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(value) {
    assertInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setInt32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(value) {
    assertInt32(value);
    value = (value << 1 ^ value >> 31) >>> 0;
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(value) {
    let chunk = new Uint8Array(8);
    let view = new DataView(chunk.buffer);
    let long = PbLong.from(value);
    view.setInt32(0, long.lo, true);
    view.setInt32(4, long.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(value) {
    let chunk = new Uint8Array(8);
    let view = new DataView(chunk.buffer);
    let long = PbULong.from(value);
    view.setInt32(0, long.lo, true);
    view.setInt32(4, long.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(value) {
    let long = PbLong.from(value);
    varint64write(long.lo, long.hi, this.buf);
    return this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(value) {
    let long = PbLong.from(value), sign = long.hi >> 31, lo = long.lo << 1 ^ sign, hi = (long.hi << 1 | long.lo >>> 31) ^ sign;
    varint64write(lo, hi, this.buf);
    return this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(value) {
    let long = PbULong.from(value);
    varint64write(long.lo, long.hi, this.buf);
    return this;
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js
init_dirname();
init_buffer2();
init_process2();
var defaultsWrite2 = {
  emitDefaultValues: false,
  enumAsInteger: false,
  useProtoFieldName: false,
  prettySpaces: 0
};
var defaultsRead2 = {
  ignoreUnknownFields: false
};
function jsonReadOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsRead2), options) : defaultsRead2;
}
function jsonWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsWrite2), options) : defaultsWrite2;
}

// node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js
init_dirname();
init_buffer2();
init_process2();
var MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");

// node_modules/@protobuf-ts/runtime/build/es2015/message-type.js
init_dirname();
init_buffer2();
init_process2();

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js
init_dirname();
init_buffer2();
init_process2();

// node_modules/@protobuf-ts/runtime/build/es2015/lower-camel-case.js
init_dirname();
init_buffer2();
init_process2();
function lowerCamelCase(snakeCase) {
  let capNext = false;
  const sb = [];
  for (let i2 = 0; i2 < snakeCase.length; i2++) {
    let next = snakeCase.charAt(i2);
    if (next == "_") {
      capNext = true;
    } else if (/\d/.test(next)) {
      sb.push(next);
      capNext = true;
    } else if (capNext) {
      sb.push(next.toUpperCase());
      capNext = false;
    } else if (i2 == 0) {
      sb.push(next.toLowerCase());
    } else {
      sb.push(next);
    }
  }
  return sb.join("");
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js
var ScalarType;
(function(ScalarType2) {
  ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
  ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
  ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
  ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
  ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
  ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
  ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
  ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
  ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
  ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
  ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
  ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
  ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
  ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
  ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
var LongType;
(function(LongType2) {
  LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
  LongType2[LongType2["STRING"] = 1] = "STRING";
  LongType2[LongType2["NUMBER"] = 2] = "NUMBER";
})(LongType || (LongType = {}));
var RepeatType;
(function(RepeatType2) {
  RepeatType2[RepeatType2["NO"] = 0] = "NO";
  RepeatType2[RepeatType2["PACKED"] = 1] = "PACKED";
  RepeatType2[RepeatType2["UNPACKED"] = 2] = "UNPACKED";
})(RepeatType || (RepeatType = {}));
function normalizeFieldInfo(field) {
  var _a, _b, _c, _d;
  field.localName = (_a = field.localName) !== null && _a !== void 0 ? _a : lowerCamelCase(field.name);
  field.jsonName = (_b = field.jsonName) !== null && _b !== void 0 ? _b : lowerCamelCase(field.name);
  field.repeat = (_c = field.repeat) !== null && _c !== void 0 ? _c : RepeatType.NO;
  field.opt = (_d = field.opt) !== null && _d !== void 0 ? _d : field.repeat ? false : field.oneof ? false : field.kind == "message";
  return field;
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js
init_dirname();
init_buffer2();
init_process2();

// node_modules/@protobuf-ts/runtime/build/es2015/oneof.js
init_dirname();
init_buffer2();
init_process2();
function isOneofGroup(any) {
  if (typeof any != "object" || any === null || !any.hasOwnProperty("oneofKind")) {
    return false;
  }
  switch (typeof any.oneofKind) {
    case "string":
      if (any[any.oneofKind] === void 0)
        return false;
      return Object.keys(any).length == 2;
    case "undefined":
      return Object.keys(any).length == 1;
    default:
      return false;
  }
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js
var ReflectionTypeCheck = class {
  constructor(info) {
    var _a;
    this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
  }
  prepare() {
    if (this.data)
      return;
    const req = [], known = [], oneofs = [];
    for (let field of this.fields) {
      if (field.oneof) {
        if (!oneofs.includes(field.oneof)) {
          oneofs.push(field.oneof);
          req.push(field.oneof);
          known.push(field.oneof);
        }
      } else {
        known.push(field.localName);
        switch (field.kind) {
          case "scalar":
          case "enum":
            if (!field.opt || field.repeat)
              req.push(field.localName);
            break;
          case "message":
            if (field.repeat)
              req.push(field.localName);
            break;
          case "map":
            req.push(field.localName);
            break;
        }
      }
    }
    this.data = { req, known, oneofs: Object.values(oneofs) };
  }
  /**
   * Is the argument a valid message as specified by the
   * reflection information?
   *
   * Checks all field types recursively. The `depth`
   * specifies how deep into the structure the check will be.
   *
   * With a depth of 0, only the presence of fields
   * is checked.
   *
   * With a depth of 1 or more, the field types are checked.
   *
   * With a depth of 2 or more, the members of map, repeated
   * and message fields are checked.
   *
   * Message fields will be checked recursively with depth - 1.
   *
   * The number of map entries / repeated values being checked
   * is < depth.
   */
  is(message, depth, allowExcessProperties = false) {
    if (depth < 0)
      return true;
    if (message === null || message === void 0 || typeof message != "object")
      return false;
    this.prepare();
    let keys = Object.keys(message), data = this.data;
    if (keys.length < data.req.length || data.req.some((n2) => !keys.includes(n2)))
      return false;
    if (!allowExcessProperties) {
      if (keys.some((k) => !data.known.includes(k)))
        return false;
    }
    if (depth < 1) {
      return true;
    }
    for (const name2 of data.oneofs) {
      const group = message[name2];
      if (!isOneofGroup(group))
        return false;
      if (group.oneofKind === void 0)
        continue;
      const field = this.fields.find((f2) => f2.localName === group.oneofKind);
      if (!field)
        return false;
      if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))
        return false;
    }
    for (const field of this.fields) {
      if (field.oneof !== void 0)
        continue;
      if (!this.field(message[field.localName], field, allowExcessProperties, depth))
        return false;
    }
    return true;
  }
  field(arg, field, allowExcessProperties, depth) {
    let repeated = field.repeat;
    switch (field.kind) {
      case "scalar":
        if (arg === void 0)
          return field.opt;
        if (repeated)
          return this.scalars(arg, field.T, depth, field.L);
        return this.scalar(arg, field.T, field.L);
      case "enum":
        if (arg === void 0)
          return field.opt;
        if (repeated)
          return this.scalars(arg, ScalarType.INT32, depth);
        return this.scalar(arg, ScalarType.INT32);
      case "message":
        if (arg === void 0)
          return true;
        if (repeated)
          return this.messages(arg, field.T(), allowExcessProperties, depth);
        return this.message(arg, field.T(), allowExcessProperties, depth);
      case "map":
        if (typeof arg != "object" || arg === null)
          return false;
        if (depth < 2)
          return true;
        if (!this.mapKeys(arg, field.K, depth))
          return false;
        switch (field.V.kind) {
          case "scalar":
            return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
          case "enum":
            return this.scalars(Object.values(arg), ScalarType.INT32, depth);
          case "message":
            return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
        }
        break;
    }
    return true;
  }
  message(arg, type, allowExcessProperties, depth) {
    if (allowExcessProperties) {
      return type.isAssignable(arg, depth);
    }
    return type.is(arg, depth);
  }
  messages(arg, type, allowExcessProperties, depth) {
    if (!Array.isArray(arg))
      return false;
    if (depth < 2)
      return true;
    if (allowExcessProperties) {
      for (let i2 = 0; i2 < arg.length && i2 < depth; i2++)
        if (!type.isAssignable(arg[i2], depth - 1))
          return false;
    } else {
      for (let i2 = 0; i2 < arg.length && i2 < depth; i2++)
        if (!type.is(arg[i2], depth - 1))
          return false;
    }
    return true;
  }
  scalar(arg, type, longType) {
    let argType = typeof arg;
    switch (type) {
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        switch (longType) {
          case LongType.BIGINT:
            return argType == "bigint";
          case LongType.NUMBER:
            return argType == "number" && !isNaN(arg);
          default:
            return argType == "string";
        }
      case ScalarType.BOOL:
        return argType == "boolean";
      case ScalarType.STRING:
        return argType == "string";
      case ScalarType.BYTES:
        return arg instanceof Uint8Array;
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        return argType == "number" && !isNaN(arg);
      default:
        return argType == "number" && Number.isInteger(arg);
    }
  }
  scalars(arg, type, depth, longType) {
    if (!Array.isArray(arg))
      return false;
    if (depth < 2)
      return true;
    if (Array.isArray(arg)) {
      for (let i2 = 0; i2 < arg.length && i2 < depth; i2++)
        if (!this.scalar(arg[i2], type, longType))
          return false;
    }
    return true;
  }
  mapKeys(map, type, depth) {
    let keys = Object.keys(map);
    switch (type) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.UINT32:
        return this.scalars(keys.slice(0, depth).map((k) => parseInt(k)), type, depth);
      case ScalarType.BOOL:
        return this.scalars(keys.slice(0, depth).map((k) => k == "true" ? true : k == "false" ? false : k), type, depth);
      default:
        return this.scalars(keys, type, depth, LongType.STRING);
    }
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js
init_dirname();
init_buffer2();
init_process2();

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js
init_dirname();
init_buffer2();
init_process2();
function reflectionLongConvert(long, type) {
  switch (type) {
    case LongType.BIGINT:
      return long.toBigInt();
    case LongType.NUMBER:
      return long.toNumber();
    default:
      return long.toString();
  }
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js
var ReflectionJsonReader = class {
  constructor(info) {
    this.info = info;
  }
  prepare() {
    var _a;
    if (this.fMap === void 0) {
      this.fMap = {};
      const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
      for (const field of fieldsInput) {
        this.fMap[field.name] = field;
        this.fMap[field.jsonName] = field;
        this.fMap[field.localName] = field;
      }
    }
  }
  // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.
  assert(condition, fieldName, jsonValue) {
    if (!condition) {
      let what = typeofJsonValue(jsonValue);
      if (what == "number" || what == "boolean")
        what = jsonValue.toString();
      throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
    }
  }
  /**
   * Reads a message from canonical JSON format into the target message.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  read(input, message, options) {
    this.prepare();
    const oneofsHandled = [];
    for (const [jsonKey, jsonValue] of Object.entries(input)) {
      const field = this.fMap[jsonKey];
      if (!field) {
        if (!options.ignoreUnknownFields)
          throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
        continue;
      }
      const localName = field.localName;
      let target;
      if (field.oneof) {
        if (jsonValue === null && (field.kind !== "enum" || field.T()[0] !== "google.protobuf.NullValue")) {
          continue;
        }
        if (oneofsHandled.includes(field.oneof))
          throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
        oneofsHandled.push(field.oneof);
        target = message[field.oneof] = {
          oneofKind: localName
        };
      } else {
        target = message;
      }
      if (field.kind == "map") {
        if (jsonValue === null) {
          continue;
        }
        this.assert(isJsonObject(jsonValue), field.name, jsonValue);
        const fieldObj = target[localName];
        for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
          this.assert(jsonObjValue !== null, field.name + " map value", null);
          let val;
          switch (field.V.kind) {
            case "message":
              val = field.V.T().internalJsonRead(jsonObjValue, options);
              break;
            case "enum":
              val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
              if (val === false)
                continue;
              break;
            case "scalar":
              val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
              break;
          }
          this.assert(val !== void 0, field.name + " map value", jsonObjValue);
          let key = jsonObjKey;
          if (field.K == ScalarType.BOOL)
            key = key == "true" ? true : key == "false" ? false : key;
          key = this.scalar(key, field.K, LongType.STRING, field.name).toString();
          fieldObj[key] = val;
        }
      } else if (field.repeat) {
        if (jsonValue === null)
          continue;
        this.assert(Array.isArray(jsonValue), field.name, jsonValue);
        const fieldArr = target[localName];
        for (const jsonItem of jsonValue) {
          this.assert(jsonItem !== null, field.name, null);
          let val;
          switch (field.kind) {
            case "message":
              val = field.T().internalJsonRead(jsonItem, options);
              break;
            case "enum":
              val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
              if (val === false)
                continue;
              break;
            case "scalar":
              val = this.scalar(jsonItem, field.T, field.L, field.name);
              break;
          }
          this.assert(val !== void 0, field.name, jsonValue);
          fieldArr.push(val);
        }
      } else {
        switch (field.kind) {
          case "message":
            if (jsonValue === null && field.T().typeName != "google.protobuf.Value") {
              this.assert(field.oneof === void 0, field.name + " (oneof member)", null);
              continue;
            }
            target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
            break;
          case "enum":
            let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
            if (val === false)
              continue;
            target[localName] = val;
            break;
          case "scalar":
            target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
            break;
        }
      }
    }
  }
  /**
   * Returns `false` for unrecognized string representations.
   *
   * google.protobuf.NullValue accepts only JSON `null` (or the old `"NULL_VALUE"`).
   */
  enum(type, json, fieldName, ignoreUnknownFields) {
    if (type[0] == "google.protobuf.NullValue")
      assert(json === null || json === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);
    if (json === null)
      return 0;
    switch (typeof json) {
      case "number":
        assert(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
        return json;
      case "string":
        let localEnumName = json;
        if (type[2] && json.substring(0, type[2].length) === type[2])
          localEnumName = json.substring(type[2].length);
        let enumNumber = type[1][localEnumName];
        if (typeof enumNumber === "undefined" && ignoreUnknownFields) {
          return false;
        }
        assert(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`);
        return enumNumber;
    }
    assert(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
  }
  scalar(json, type, longType, fieldName) {
    let e2;
    try {
      switch (type) {
        case ScalarType.DOUBLE:
        case ScalarType.FLOAT:
          if (json === null)
            return 0;
          if (json === "NaN")
            return Number.NaN;
          if (json === "Infinity")
            return Number.POSITIVE_INFINITY;
          if (json === "-Infinity")
            return Number.NEGATIVE_INFINITY;
          if (json === "") {
            e2 = "empty string";
            break;
          }
          if (typeof json == "string" && json.trim().length !== json.length) {
            e2 = "extra whitespace";
            break;
          }
          if (typeof json != "string" && typeof json != "number") {
            break;
          }
          let float = Number(json);
          if (Number.isNaN(float)) {
            e2 = "not a number";
            break;
          }
          if (!Number.isFinite(float)) {
            e2 = "too large or small";
            break;
          }
          if (type == ScalarType.FLOAT)
            assertFloat32(float);
          return float;
        case ScalarType.INT32:
        case ScalarType.FIXED32:
        case ScalarType.SFIXED32:
        case ScalarType.SINT32:
        case ScalarType.UINT32:
          if (json === null)
            return 0;
          let int32;
          if (typeof json == "number")
            int32 = json;
          else if (json === "")
            e2 = "empty string";
          else if (typeof json == "string") {
            if (json.trim().length !== json.length)
              e2 = "extra whitespace";
            else
              int32 = Number(json);
          }
          if (int32 === void 0)
            break;
          if (type == ScalarType.UINT32)
            assertUInt32(int32);
          else
            assertInt32(int32);
          return int32;
        case ScalarType.INT64:
        case ScalarType.SFIXED64:
        case ScalarType.SINT64:
          if (json === null)
            return reflectionLongConvert(PbLong.ZERO, longType);
          if (typeof json != "number" && typeof json != "string")
            break;
          return reflectionLongConvert(PbLong.from(json), longType);
        case ScalarType.FIXED64:
        case ScalarType.UINT64:
          if (json === null)
            return reflectionLongConvert(PbULong.ZERO, longType);
          if (typeof json != "number" && typeof json != "string")
            break;
          return reflectionLongConvert(PbULong.from(json), longType);
        case ScalarType.BOOL:
          if (json === null)
            return false;
          if (typeof json !== "boolean")
            break;
          return json;
        case ScalarType.STRING:
          if (json === null)
            return "";
          if (typeof json !== "string") {
            e2 = "extra whitespace";
            break;
          }
          try {
            encodeURIComponent(json);
          } catch (e3) {
            e3 = "invalid UTF8";
            break;
          }
          return json;
        case ScalarType.BYTES:
          if (json === null || json === "")
            return new Uint8Array(0);
          if (typeof json !== "string")
            break;
          return base64decode(json);
      }
    } catch (error) {
      e2 = error.message;
    }
    this.assert(false, fieldName + (e2 ? " - " + e2 : ""), json);
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-writer.js
init_dirname();
init_buffer2();
init_process2();
var ReflectionJsonWriter = class {
  constructor(info) {
    var _a;
    this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
  }
  /**
   * Converts the message to a JSON object, based on the field descriptors.
   */
  write(message, options) {
    const json = {}, source = message;
    for (const field of this.fields) {
      if (!field.oneof) {
        let jsonValue2 = this.field(field, source[field.localName], options);
        if (jsonValue2 !== void 0)
          json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue2;
        continue;
      }
      const group = source[field.oneof];
      if (group.oneofKind !== field.localName)
        continue;
      const opt = field.kind == "scalar" || field.kind == "enum" ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;
      let jsonValue = this.field(field, group[field.localName], opt);
      assert(jsonValue !== void 0);
      json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
    }
    return json;
  }
  field(field, value, options) {
    let jsonValue = void 0;
    if (field.kind == "map") {
      assert(typeof value == "object" && value !== null);
      const jsonObj = {};
      switch (field.V.kind) {
        case "scalar":
          for (const [entryKey, entryValue] of Object.entries(value)) {
            const val = this.scalar(field.V.T, entryValue, field.name, false, true);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
        case "message":
          const messageType = field.V.T();
          for (const [entryKey, entryValue] of Object.entries(value)) {
            const val = this.message(messageType, entryValue, field.name, options);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
        case "enum":
          const enumInfo = field.V.T();
          for (const [entryKey, entryValue] of Object.entries(value)) {
            assert(entryValue === void 0 || typeof entryValue == "number");
            const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
      }
      if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)
        jsonValue = jsonObj;
    } else if (field.repeat) {
      assert(Array.isArray(value));
      const jsonArr = [];
      switch (field.kind) {
        case "scalar":
          for (let i2 = 0; i2 < value.length; i2++) {
            const val = this.scalar(field.T, value[i2], field.name, field.opt, true);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
        case "enum":
          const enumInfo = field.T();
          for (let i2 = 0; i2 < value.length; i2++) {
            assert(value[i2] === void 0 || typeof value[i2] == "number");
            const val = this.enum(enumInfo, value[i2], field.name, field.opt, true, options.enumAsInteger);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
        case "message":
          const messageType = field.T();
          for (let i2 = 0; i2 < value.length; i2++) {
            const val = this.message(messageType, value[i2], field.name, options);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
      }
      if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)
        jsonValue = jsonArr;
    } else {
      switch (field.kind) {
        case "scalar":
          jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);
          break;
        case "enum":
          jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
          break;
        case "message":
          jsonValue = this.message(field.T(), value, field.name, options);
          break;
      }
    }
    return jsonValue;
  }
  /**
   * Returns `null` as the default for google.protobuf.NullValue.
   */
  enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
    if (type[0] == "google.protobuf.NullValue")
      return !emitDefaultValues && !optional ? void 0 : null;
    if (value === void 0) {
      assert(optional);
      return void 0;
    }
    if (value === 0 && !emitDefaultValues && !optional)
      return void 0;
    assert(typeof value == "number");
    assert(Number.isInteger(value));
    if (enumAsInteger || !type[1].hasOwnProperty(value))
      return value;
    if (type[2])
      return type[2] + type[1][value];
    return type[1][value];
  }
  message(type, value, fieldName, options) {
    if (value === void 0)
      return options.emitDefaultValues ? null : void 0;
    return type.internalJsonWrite(value, options);
  }
  scalar(type, value, fieldName, optional, emitDefaultValues) {
    if (value === void 0) {
      assert(optional);
      return void 0;
    }
    const ed = emitDefaultValues || optional;
    switch (type) {
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        if (value === 0)
          return ed ? 0 : void 0;
        assertInt32(value);
        return value;
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        if (value === 0)
          return ed ? 0 : void 0;
        assertUInt32(value);
        return value;
      case ScalarType.FLOAT:
        assertFloat32(value);
      case ScalarType.DOUBLE:
        if (value === 0)
          return ed ? 0 : void 0;
        assert(typeof value == "number");
        if (Number.isNaN(value))
          return "NaN";
        if (value === Number.POSITIVE_INFINITY)
          return "Infinity";
        if (value === Number.NEGATIVE_INFINITY)
          return "-Infinity";
        return value;
      case ScalarType.STRING:
        if (value === "")
          return ed ? "" : void 0;
        assert(typeof value == "string");
        return value;
      case ScalarType.BOOL:
        if (value === false)
          return ed ? false : void 0;
        assert(typeof value == "boolean");
        return value;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
        assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
        let ulong = PbULong.from(value);
        if (ulong.isZero() && !ed)
          return void 0;
        return ulong.toString();
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
        let long = PbLong.from(value);
        if (long.isZero() && !ed)
          return void 0;
        return long.toString();
      case ScalarType.BYTES:
        assert(value instanceof Uint8Array);
        if (!value.byteLength)
          return ed ? "" : void 0;
        return base64encode(value);
    }
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js
init_dirname();
init_buffer2();
init_process2();

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js
init_dirname();
init_buffer2();
init_process2();
function reflectionScalarDefault(type, longType = LongType.STRING) {
  switch (type) {
    case ScalarType.BOOL:
      return false;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
      return reflectionLongConvert(PbULong.ZERO, longType);
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return reflectionLongConvert(PbLong.ZERO, longType);
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    case ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js
var ReflectionBinaryReader = class {
  constructor(info) {
    this.info = info;
  }
  prepare() {
    var _a;
    if (!this.fieldNoToField) {
      const fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
      this.fieldNoToField = new Map(fieldsInput.map((field) => [field.no, field]));
    }
  }
  /**
   * Reads a message from binary format into the target message.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  read(reader, message, options, length) {
    this.prepare();
    const end = length === void 0 ? reader.len : reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
      if (!field) {
        let u2 = options.readUnknownField;
        if (u2 == "throw")
          throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
        let d = reader.skip(wireType);
        if (u2 !== false)
          (u2 === true ? UnknownFieldHandler.onRead : u2)(this.info.typeName, message, fieldNo, wireType, d);
        continue;
      }
      let target = message, repeated = field.repeat, localName = field.localName;
      if (field.oneof) {
        target = target[field.oneof];
        if (target.oneofKind !== localName)
          target = message[field.oneof] = {
            oneofKind: localName
          };
      }
      switch (field.kind) {
        case "scalar":
        case "enum":
          let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
          let L = field.kind == "scalar" ? field.L : void 0;
          if (repeated) {
            let arr = target[localName];
            if (wireType == WireType.LengthDelimited && T != ScalarType.STRING && T != ScalarType.BYTES) {
              let e2 = reader.uint32() + reader.pos;
              while (reader.pos < e2)
                arr.push(this.scalar(reader, T, L));
            } else
              arr.push(this.scalar(reader, T, L));
          } else
            target[localName] = this.scalar(reader, T, L);
          break;
        case "message":
          if (repeated) {
            let arr = target[localName];
            let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
            arr.push(msg);
          } else
            target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
          break;
        case "map":
          let [mapKey, mapVal] = this.mapEntry(field, reader, options);
          target[localName][mapKey] = mapVal;
          break;
      }
    }
  }
  /**
   * Read a map field, expecting key field = 1, value field = 2
   */
  mapEntry(field, reader, options) {
    let length = reader.uint32();
    let end = reader.pos + length;
    let key = void 0;
    let val = void 0;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          if (field.K == ScalarType.BOOL)
            key = reader.bool().toString();
          else
            key = this.scalar(reader, field.K, LongType.STRING);
          break;
        case 2:
          switch (field.V.kind) {
            case "scalar":
              val = this.scalar(reader, field.V.T, field.V.L);
              break;
            case "enum":
              val = reader.int32();
              break;
            case "message":
              val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
              break;
          }
          break;
        default:
          throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
      }
    }
    if (key === void 0) {
      let keyRaw = reflectionScalarDefault(field.K);
      key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;
    }
    if (val === void 0)
      switch (field.V.kind) {
        case "scalar":
          val = reflectionScalarDefault(field.V.T, field.V.L);
          break;
        case "enum":
          val = 0;
          break;
        case "message":
          val = field.V.T().create();
          break;
      }
    return [key, val];
  }
  scalar(reader, type, longType) {
    switch (type) {
      case ScalarType.INT32:
        return reader.int32();
      case ScalarType.STRING:
        return reader.string();
      case ScalarType.BOOL:
        return reader.bool();
      case ScalarType.DOUBLE:
        return reader.double();
      case ScalarType.FLOAT:
        return reader.float();
      case ScalarType.INT64:
        return reflectionLongConvert(reader.int64(), longType);
      case ScalarType.UINT64:
        return reflectionLongConvert(reader.uint64(), longType);
      case ScalarType.FIXED64:
        return reflectionLongConvert(reader.fixed64(), longType);
      case ScalarType.FIXED32:
        return reader.fixed32();
      case ScalarType.BYTES:
        return reader.bytes();
      case ScalarType.UINT32:
        return reader.uint32();
      case ScalarType.SFIXED32:
        return reader.sfixed32();
      case ScalarType.SFIXED64:
        return reflectionLongConvert(reader.sfixed64(), longType);
      case ScalarType.SINT32:
        return reader.sint32();
      case ScalarType.SINT64:
        return reflectionLongConvert(reader.sint64(), longType);
    }
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-writer.js
init_dirname();
init_buffer2();
init_process2();
var ReflectionBinaryWriter = class {
  constructor(info) {
    this.info = info;
  }
  prepare() {
    if (!this.fields) {
      const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
      this.fields = fieldsInput.sort((a2, b) => a2.no - b.no);
    }
  }
  /**
   * Writes the message to binary format.
   */
  write(message, writer, options) {
    this.prepare();
    for (const field of this.fields) {
      let value, emitDefault, repeated = field.repeat, localName = field.localName;
      if (field.oneof) {
        const group = message[field.oneof];
        if (group.oneofKind !== localName)
          continue;
        value = group[localName];
        emitDefault = true;
      } else {
        value = message[localName];
        emitDefault = false;
      }
      switch (field.kind) {
        case "scalar":
        case "enum":
          let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
          if (repeated) {
            assert(Array.isArray(value));
            if (repeated == RepeatType.PACKED)
              this.packed(writer, T, field.no, value);
            else
              for (const item of value)
                this.scalar(writer, T, field.no, item, true);
          } else if (value === void 0)
            assert(field.opt);
          else
            this.scalar(writer, T, field.no, value, emitDefault || field.opt);
          break;
        case "message":
          if (repeated) {
            assert(Array.isArray(value));
            for (const item of value)
              this.message(writer, options, field.T(), field.no, item);
          } else {
            this.message(writer, options, field.T(), field.no, value);
          }
          break;
        case "map":
          assert(typeof value == "object" && value !== null);
          for (const [key, val] of Object.entries(value))
            this.mapEntry(writer, options, field, key, val);
          break;
      }
    }
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 === true ? UnknownFieldHandler.onWrite : u2)(this.info.typeName, message, writer);
  }
  mapEntry(writer, options, field, key, value) {
    writer.tag(field.no, WireType.LengthDelimited);
    writer.fork();
    let keyValue = key;
    switch (field.K) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        keyValue = Number.parseInt(key);
        break;
      case ScalarType.BOOL:
        assert(key == "true" || key == "false");
        keyValue = key == "true";
        break;
    }
    this.scalar(writer, field.K, 1, keyValue, true);
    switch (field.V.kind) {
      case "scalar":
        this.scalar(writer, field.V.T, 2, value, true);
        break;
      case "enum":
        this.scalar(writer, ScalarType.INT32, 2, value, true);
        break;
      case "message":
        this.message(writer, options, field.V.T(), 2, value);
        break;
    }
    writer.join();
  }
  message(writer, options, handler, fieldNo, value) {
    if (value === void 0)
      return;
    handler.internalBinaryWrite(value, writer.tag(fieldNo, WireType.LengthDelimited).fork(), options);
    writer.join();
  }
  /**
   * Write a single scalar value.
   */
  scalar(writer, type, fieldNo, value, emitDefault) {
    let [wireType, method, isDefault] = this.scalarInfo(type, value);
    if (!isDefault || emitDefault) {
      writer.tag(fieldNo, wireType);
      writer[method](value);
    }
  }
  /**
   * Write an array of scalar values in packed format.
   */
  packed(writer, type, fieldNo, value) {
    if (!value.length)
      return;
    assert(type !== ScalarType.BYTES && type !== ScalarType.STRING);
    writer.tag(fieldNo, WireType.LengthDelimited);
    writer.fork();
    let [, method] = this.scalarInfo(type);
    for (let i2 = 0; i2 < value.length; i2++)
      writer[method](value[i2]);
    writer.join();
  }
  /**
   * Get information for writing a scalar value.
   *
   * Returns tuple:
   * [0]: appropriate WireType
   * [1]: name of the appropriate method of IBinaryWriter
   * [2]: whether the given value is a default value
   *
   * If argument `value` is omitted, [2] is always false.
   */
  scalarInfo(type, value) {
    let t2 = WireType.Varint;
    let m;
    let i2 = value === void 0;
    let d = value === 0;
    switch (type) {
      case ScalarType.INT32:
        m = "int32";
        break;
      case ScalarType.STRING:
        d = i2 || !value.length;
        t2 = WireType.LengthDelimited;
        m = "string";
        break;
      case ScalarType.BOOL:
        d = value === false;
        m = "bool";
        break;
      case ScalarType.UINT32:
        m = "uint32";
        break;
      case ScalarType.DOUBLE:
        t2 = WireType.Bit64;
        m = "double";
        break;
      case ScalarType.FLOAT:
        t2 = WireType.Bit32;
        m = "float";
        break;
      case ScalarType.INT64:
        d = i2 || PbLong.from(value).isZero();
        m = "int64";
        break;
      case ScalarType.UINT64:
        d = i2 || PbULong.from(value).isZero();
        m = "uint64";
        break;
      case ScalarType.FIXED64:
        d = i2 || PbULong.from(value).isZero();
        t2 = WireType.Bit64;
        m = "fixed64";
        break;
      case ScalarType.BYTES:
        d = i2 || !value.byteLength;
        t2 = WireType.LengthDelimited;
        m = "bytes";
        break;
      case ScalarType.FIXED32:
        t2 = WireType.Bit32;
        m = "fixed32";
        break;
      case ScalarType.SFIXED32:
        t2 = WireType.Bit32;
        m = "sfixed32";
        break;
      case ScalarType.SFIXED64:
        d = i2 || PbLong.from(value).isZero();
        t2 = WireType.Bit64;
        m = "sfixed64";
        break;
      case ScalarType.SINT32:
        m = "sint32";
        break;
      case ScalarType.SINT64:
        d = i2 || PbLong.from(value).isZero();
        m = "sint64";
        break;
    }
    return [t2, m, i2 || d];
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-create.js
init_dirname();
init_buffer2();
init_process2();
function reflectionCreate(type) {
  const msg = type.messagePrototype ? Object.create(type.messagePrototype) : Object.defineProperty({}, MESSAGE_TYPE, { value: type });
  for (let field of type.fields) {
    let name2 = field.localName;
    if (field.opt)
      continue;
    if (field.oneof)
      msg[field.oneof] = { oneofKind: void 0 };
    else if (field.repeat)
      msg[name2] = [];
    else
      switch (field.kind) {
        case "scalar":
          msg[name2] = reflectionScalarDefault(field.T, field.L);
          break;
        case "enum":
          msg[name2] = 0;
          break;
        case "map":
          msg[name2] = {};
          break;
      }
  }
  return msg;
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js
init_dirname();
init_buffer2();
init_process2();
function reflectionMergePartial(info, target, source) {
  let fieldValue, input = source, output;
  for (let field of info.fields) {
    let name2 = field.localName;
    if (field.oneof) {
      const group = input[field.oneof];
      if ((group === null || group === void 0 ? void 0 : group.oneofKind) == void 0) {
        continue;
      }
      fieldValue = group[name2];
      output = target[field.oneof];
      output.oneofKind = group.oneofKind;
      if (fieldValue == void 0) {
        delete output[name2];
        continue;
      }
    } else {
      fieldValue = input[name2];
      output = target;
      if (fieldValue == void 0) {
        continue;
      }
    }
    if (field.repeat)
      output[name2].length = fieldValue.length;
    switch (field.kind) {
      case "scalar":
      case "enum":
        if (field.repeat)
          for (let i2 = 0; i2 < fieldValue.length; i2++)
            output[name2][i2] = fieldValue[i2];
        else
          output[name2] = fieldValue;
        break;
      case "message":
        let T = field.T();
        if (field.repeat)
          for (let i2 = 0; i2 < fieldValue.length; i2++)
            output[name2][i2] = T.create(fieldValue[i2]);
        else if (output[name2] === void 0)
          output[name2] = T.create(fieldValue);
        else
          T.mergePartial(output[name2], fieldValue);
        break;
      case "map":
        switch (field.V.kind) {
          case "scalar":
          case "enum":
            Object.assign(output[name2], fieldValue);
            break;
          case "message":
            let T2 = field.V.T();
            for (let k of Object.keys(fieldValue))
              output[name2][k] = T2.create(fieldValue[k]);
            break;
        }
        break;
    }
  }
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-equals.js
init_dirname();
init_buffer2();
init_process2();
function reflectionEquals(info, a2, b) {
  if (a2 === b)
    return true;
  if (!a2 || !b)
    return false;
  for (let field of info.fields) {
    let localName = field.localName;
    let val_a = field.oneof ? a2[field.oneof][localName] : a2[localName];
    let val_b = field.oneof ? b[field.oneof][localName] : b[localName];
    switch (field.kind) {
      case "enum":
      case "scalar":
        let t2 = field.kind == "enum" ? ScalarType.INT32 : field.T;
        if (!(field.repeat ? repeatedPrimitiveEq(t2, val_a, val_b) : primitiveEq(t2, val_a, val_b)))
          return false;
        break;
      case "map":
        if (!(field.V.kind == "message" ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b)) : repeatedPrimitiveEq(field.V.kind == "enum" ? ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
          return false;
        break;
      case "message":
        let T = field.T();
        if (!(field.repeat ? repeatedMsgEq(T, val_a, val_b) : T.equals(val_a, val_b)))
          return false;
        break;
    }
  }
  return true;
}
var objectValues = Object.values;
function primitiveEq(type, a2, b) {
  if (a2 === b)
    return true;
  if (type !== ScalarType.BYTES)
    return false;
  let ba = a2;
  let bb = b;
  if (ba.length !== bb.length)
    return false;
  for (let i2 = 0; i2 < ba.length; i2++)
    if (ba[i2] != bb[i2])
      return false;
  return true;
}
function repeatedPrimitiveEq(type, a2, b) {
  if (a2.length !== b.length)
    return false;
  for (let i2 = 0; i2 < a2.length; i2++)
    if (!primitiveEq(type, a2[i2], b[i2]))
      return false;
  return true;
}
function repeatedMsgEq(type, a2, b) {
  if (a2.length !== b.length)
    return false;
  for (let i2 = 0; i2 < a2.length; i2++)
    if (!type.equals(a2[i2], b[i2]))
      return false;
  return true;
}

// node_modules/@protobuf-ts/runtime/build/es2015/message-type.js
var baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));
var MessageType = class {
  constructor(name2, fields, options) {
    this.defaultCheckDepth = 16;
    this.typeName = name2;
    this.fields = fields.map(normalizeFieldInfo);
    this.options = options !== null && options !== void 0 ? options : {};
    this.messagePrototype = Object.create(null, Object.assign(Object.assign({}, baseDescriptors), { [MESSAGE_TYPE]: { value: this } }));
    this.refTypeCheck = new ReflectionTypeCheck(this);
    this.refJsonReader = new ReflectionJsonReader(this);
    this.refJsonWriter = new ReflectionJsonWriter(this);
    this.refBinReader = new ReflectionBinaryReader(this);
    this.refBinWriter = new ReflectionBinaryWriter(this);
  }
  create(value) {
    let message = reflectionCreate(this);
    if (value !== void 0) {
      reflectionMergePartial(this, message, value);
    }
    return message;
  }
  /**
   * Clone the message.
   *
   * Unknown fields are discarded.
   */
  clone(message) {
    let copy = this.create();
    reflectionMergePartial(this, copy, message);
    return copy;
  }
  /**
   * Determines whether two message of the same type have the same field values.
   * Checks for deep equality, traversing repeated fields, oneof groups, maps
   * and messages recursively.
   * Will also return true if both messages are `undefined`.
   */
  equals(a2, b) {
    return reflectionEquals(this, a2, b);
  }
  /**
   * Is the given value assignable to our message type
   * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
   */
  is(arg, depth = this.defaultCheckDepth) {
    return this.refTypeCheck.is(arg, depth, false);
  }
  /**
   * Is the given value assignable to our message type,
   * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
   */
  isAssignable(arg, depth = this.defaultCheckDepth) {
    return this.refTypeCheck.is(arg, depth, true);
  }
  /**
   * Copy partial data into the target message.
   */
  mergePartial(target, source) {
    reflectionMergePartial(this, target, source);
  }
  /**
   * Create a new message from binary format.
   */
  fromBinary(data, options) {
    let opt = binaryReadOptions(options);
    return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
  }
  /**
   * Read a new message from a JSON value.
   */
  fromJson(json, options) {
    return this.internalJsonRead(json, jsonReadOptions(options));
  }
  /**
   * Read a new message from a JSON string.
   * This is equivalent to `T.fromJson(JSON.parse(json))`.
   */
  fromJsonString(json, options) {
    let value = JSON.parse(json);
    return this.fromJson(value, options);
  }
  /**
   * Write the message to canonical JSON value.
   */
  toJson(message, options) {
    return this.internalJsonWrite(message, jsonWriteOptions(options));
  }
  /**
   * Convert the message to canonical JSON string.
   * This is equivalent to `JSON.stringify(T.toJson(t))`
   */
  toJsonString(message, options) {
    var _a;
    let value = this.toJson(message, options);
    return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
  }
  /**
   * Write the message to binary format.
   */
  toBinary(message, options) {
    let opt = binaryWriteOptions(options);
    return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
  }
  /**
   * This is an internal method. If you just want to read a message from
   * JSON, use `fromJson()` or `fromJsonString()`.
   *
   * Reads JSON value and merges the fields into the target
   * according to protobuf rules. If the target is omitted,
   * a new instance is created first.
   */
  internalJsonRead(json, options, target) {
    if (json !== null && typeof json == "object" && !Array.isArray(json)) {
      let message = target !== null && target !== void 0 ? target : this.create();
      this.refJsonReader.read(json, message, options);
      return message;
    }
    throw new Error(`Unable to parse message ${this.typeName} from JSON ${typeofJsonValue(json)}.`);
  }
  /**
   * This is an internal method. If you just want to write a message
   * to JSON, use `toJson()` or `toJsonString().
   *
   * Writes JSON value and returns it.
   */
  internalJsonWrite(message, options) {
    return this.refJsonWriter.write(message, options);
  }
  /**
   * This is an internal method. If you just want to write a message
   * in binary format, use `toBinary()`.
   *
   * Serializes the message in binary format and appends it to the given
   * writer. Returns passed writer.
   */
  internalBinaryWrite(message, writer, options) {
    this.refBinWriter.write(message, writer, options);
    return writer;
  }
  /**
   * This is an internal method. If you just want to read a message from
   * binary data, use `fromBinary()`.
   *
   * Reads data from binary format and merges the fields into
   * the target according to protobuf rules. If the target is
   * omitted, a new instance is created first.
   */
  internalBinaryRead(reader, length, options, target) {
    let message = target !== null && target !== void 0 ? target : this.create();
    this.refBinReader.read(reader, message, options, length);
    return message;
  }
};

// src/models/events.ts
init_dirname();
init_buffer2();
init_process2();

// src/models/models.ts
init_dirname();
init_buffer2();
init_process2();

// src/models/discord.ts
init_dirname();
init_buffer2();
init_process2();
var Channel$Type = class extends MessageType {
  constructor() {
    super("proto.discord.Channel", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { id: "", name: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* string name */
        2:
          message.name = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    if (message.name !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.name);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Channel = new Channel$Type();
var DiscordUser$Type = class extends MessageType {
  constructor() {
    super("proto.discord.DiscordUser", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { id: "", name: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* string name */
        2:
          message.name = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    if (message.name !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.name);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var DiscordUser = new DiscordUser$Type();
var Guild$Type = class extends MessageType {
  constructor() {
    super("proto.discord.Guild", [
      {
        no: 1,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { id: "", name: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */
        1:
          message.id = reader.string();
          break;
        case /* string name */
        2:
          message.name = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    if (message.name !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.name);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Guild = new Guild$Type();

// src/models/models.ts
var GameplayModifiers_GameOptions = /* @__PURE__ */ ((GameplayModifiers_GameOptions2) => {
  GameplayModifiers_GameOptions2[GameplayModifiers_GameOptions2["None"] = 0] = "None";
  GameplayModifiers_GameOptions2[GameplayModifiers_GameOptions2["NoFail"] = 1] = "NoFail";
  GameplayModifiers_GameOptions2[GameplayModifiers_GameOptions2["NoBombs"] = 2] = "NoBombs";
  GameplayModifiers_GameOptions2[GameplayModifiers_GameOptions2["NoArrows"] = 4] = "NoArrows";
  GameplayModifiers_GameOptions2[GameplayModifiers_GameOptions2["NoObstacles"] = 8] = "NoObstacles";
  GameplayModifiers_GameOptions2[GameplayModifiers_GameOptions2["SlowSong"] = 16] = "SlowSong";
  GameplayModifiers_GameOptions2[GameplayModifiers_GameOptions2["InstaFail"] = 32] = "InstaFail";
  GameplayModifiers_GameOptions2[GameplayModifiers_GameOptions2["FailOnClash"] = 64] = "FailOnClash";
  GameplayModifiers_GameOptions2[GameplayModifiers_GameOptions2["BatteryEnergy"] = 128] = "BatteryEnergy";
  GameplayModifiers_GameOptions2[GameplayModifiers_GameOptions2["FastNotes"] = 256] = "FastNotes";
  GameplayModifiers_GameOptions2[GameplayModifiers_GameOptions2["FastSong"] = 512] = "FastSong";
  GameplayModifiers_GameOptions2[GameplayModifiers_GameOptions2["DisappearingArrows"] = 1024] = "DisappearingArrows";
  GameplayModifiers_GameOptions2[GameplayModifiers_GameOptions2["GhostNotes"] = 2048] = "GhostNotes";
  GameplayModifiers_GameOptions2[GameplayModifiers_GameOptions2["DemoNoFail"] = 4096] = "DemoNoFail";
  GameplayModifiers_GameOptions2[GameplayModifiers_GameOptions2["DemoNoObstacles"] = 8192] = "DemoNoObstacles";
  GameplayModifiers_GameOptions2[GameplayModifiers_GameOptions2["StrictAngles"] = 16384] = "StrictAngles";
  GameplayModifiers_GameOptions2[GameplayModifiers_GameOptions2["ProMode"] = 32768] = "ProMode";
  GameplayModifiers_GameOptions2[GameplayModifiers_GameOptions2["ZenMode"] = 65536] = "ZenMode";
  GameplayModifiers_GameOptions2[GameplayModifiers_GameOptions2["SmallCubes"] = 131072] = "SmallCubes";
  GameplayModifiers_GameOptions2[GameplayModifiers_GameOptions2["SuperFastSong"] = 262144] = "SuperFastSong";
  return GameplayModifiers_GameOptions2;
})(GameplayModifiers_GameOptions || {});
var PlayerSpecificSettings_PlayerOptions = /* @__PURE__ */ ((PlayerSpecificSettings_PlayerOptions2) => {
  PlayerSpecificSettings_PlayerOptions2[PlayerSpecificSettings_PlayerOptions2["NoPlayerOptions"] = 0] = "NoPlayerOptions";
  PlayerSpecificSettings_PlayerOptions2[PlayerSpecificSettings_PlayerOptions2["LeftHanded"] = 1] = "LeftHanded";
  PlayerSpecificSettings_PlayerOptions2[PlayerSpecificSettings_PlayerOptions2["StaticLights"] = 2] = "StaticLights";
  PlayerSpecificSettings_PlayerOptions2[PlayerSpecificSettings_PlayerOptions2["NoHud"] = 4] = "NoHud";
  PlayerSpecificSettings_PlayerOptions2[PlayerSpecificSettings_PlayerOptions2["AdvancedHud"] = 8] = "AdvancedHud";
  PlayerSpecificSettings_PlayerOptions2[PlayerSpecificSettings_PlayerOptions2["ReduceDebris"] = 16] = "ReduceDebris";
  PlayerSpecificSettings_PlayerOptions2[PlayerSpecificSettings_PlayerOptions2["AutoPlayerHeight"] = 32] = "AutoPlayerHeight";
  PlayerSpecificSettings_PlayerOptions2[PlayerSpecificSettings_PlayerOptions2["NoFailEffects"] = 64] = "NoFailEffects";
  PlayerSpecificSettings_PlayerOptions2[PlayerSpecificSettings_PlayerOptions2["AutoRestart"] = 128] = "AutoRestart";
  PlayerSpecificSettings_PlayerOptions2[PlayerSpecificSettings_PlayerOptions2["HideNoteSpawnEffect"] = 256] = "HideNoteSpawnEffect";
  PlayerSpecificSettings_PlayerOptions2[PlayerSpecificSettings_PlayerOptions2["AdaptiveSfx"] = 512] = "AdaptiveSfx";
  PlayerSpecificSettings_PlayerOptions2[PlayerSpecificSettings_PlayerOptions2["ArcsHapticFeedback"] = 1024] = "ArcsHapticFeedback";
  return PlayerSpecificSettings_PlayerOptions2;
})(PlayerSpecificSettings_PlayerOptions || {});
var PlayerSpecificSettings_NoteJumpDurationTypeSettings = /* @__PURE__ */ ((PlayerSpecificSettings_NoteJumpDurationTypeSettings2) => {
  PlayerSpecificSettings_NoteJumpDurationTypeSettings2[PlayerSpecificSettings_NoteJumpDurationTypeSettings2["Dynamic"] = 0] = "Dynamic";
  PlayerSpecificSettings_NoteJumpDurationTypeSettings2[PlayerSpecificSettings_NoteJumpDurationTypeSettings2["Static"] = 1] = "Static";
  return PlayerSpecificSettings_NoteJumpDurationTypeSettings2;
})(PlayerSpecificSettings_NoteJumpDurationTypeSettings || {});
var PlayerSpecificSettings_ArcVisibilityType = /* @__PURE__ */ ((PlayerSpecificSettings_ArcVisibilityType2) => {
  PlayerSpecificSettings_ArcVisibilityType2[PlayerSpecificSettings_ArcVisibilityType2["None"] = 0] = "None";
  PlayerSpecificSettings_ArcVisibilityType2[PlayerSpecificSettings_ArcVisibilityType2["Low"] = 1] = "Low";
  PlayerSpecificSettings_ArcVisibilityType2[PlayerSpecificSettings_ArcVisibilityType2["Standard"] = 2] = "Standard";
  PlayerSpecificSettings_ArcVisibilityType2[PlayerSpecificSettings_ArcVisibilityType2["High"] = 3] = "High";
  return PlayerSpecificSettings_ArcVisibilityType2;
})(PlayerSpecificSettings_ArcVisibilityType || {});
var User_PlayStates = /* @__PURE__ */ ((User_PlayStates2) => {
  User_PlayStates2[User_PlayStates2["InMenu"] = 0] = "InMenu";
  User_PlayStates2[User_PlayStates2["WaitingForCoordinator"] = 1] = "WaitingForCoordinator";
  User_PlayStates2[User_PlayStates2["InGame"] = 2] = "InGame";
  return User_PlayStates2;
})(User_PlayStates || {});
var User_DownloadStates = /* @__PURE__ */ ((User_DownloadStates2) => {
  User_DownloadStates2[User_DownloadStates2["None"] = 0] = "None";
  User_DownloadStates2[User_DownloadStates2["Downloading"] = 1] = "Downloading";
  User_DownloadStates2[User_DownloadStates2["Downloaded"] = 2] = "Downloaded";
  User_DownloadStates2[User_DownloadStates2["DownloadError"] = 3] = "DownloadError";
  return User_DownloadStates2;
})(User_DownloadStates || {});
var User_ClientTypes = /* @__PURE__ */ ((User_ClientTypes2) => {
  User_ClientTypes2[User_ClientTypes2["Player"] = 0] = "Player";
  User_ClientTypes2[User_ClientTypes2["WebsocketConnection"] = 1] = "WebsocketConnection";
  return User_ClientTypes2;
})(User_ClientTypes || {});
var QualifierEvent_EventSettings = /* @__PURE__ */ ((QualifierEvent_EventSettings2) => {
  QualifierEvent_EventSettings2[QualifierEvent_EventSettings2["None"] = 0] = "None";
  QualifierEvent_EventSettings2[QualifierEvent_EventSettings2["HideScoresFromPlayers"] = 1] = "HideScoresFromPlayers";
  QualifierEvent_EventSettings2[QualifierEvent_EventSettings2["DisableScoresaberSubmission"] = 2] = "DisableScoresaberSubmission";
  QualifierEvent_EventSettings2[QualifierEvent_EventSettings2["EnableDiscordScoreFeed"] = 4] = "EnableDiscordScoreFeed";
  QualifierEvent_EventSettings2[QualifierEvent_EventSettings2["EnableDiscordLeaderboard"] = 8] = "EnableDiscordLeaderboard";
  return QualifierEvent_EventSettings2;
})(QualifierEvent_EventSettings || {});
var QualifierEvent_LeaderboardSort = /* @__PURE__ */ ((QualifierEvent_LeaderboardSort2) => {
  QualifierEvent_LeaderboardSort2[QualifierEvent_LeaderboardSort2["ModifiedScore"] = 0] = "ModifiedScore";
  QualifierEvent_LeaderboardSort2[QualifierEvent_LeaderboardSort2["ModifiedScoreAscending"] = 1] = "ModifiedScoreAscending";
  QualifierEvent_LeaderboardSort2[QualifierEvent_LeaderboardSort2["ModifiedScoreTarget"] = 2] = "ModifiedScoreTarget";
  QualifierEvent_LeaderboardSort2[QualifierEvent_LeaderboardSort2["NotesMissed"] = 3] = "NotesMissed";
  QualifierEvent_LeaderboardSort2[QualifierEvent_LeaderboardSort2["NotesMissedAscending"] = 4] = "NotesMissedAscending";
  QualifierEvent_LeaderboardSort2[QualifierEvent_LeaderboardSort2["NotesMissedTarget"] = 5] = "NotesMissedTarget";
  QualifierEvent_LeaderboardSort2[QualifierEvent_LeaderboardSort2["BadCuts"] = 6] = "BadCuts";
  QualifierEvent_LeaderboardSort2[QualifierEvent_LeaderboardSort2["BadCutsAscending"] = 7] = "BadCutsAscending";
  QualifierEvent_LeaderboardSort2[QualifierEvent_LeaderboardSort2["BadCutsTarget"] = 8] = "BadCutsTarget";
  QualifierEvent_LeaderboardSort2[QualifierEvent_LeaderboardSort2["MaxCombo"] = 9] = "MaxCombo";
  QualifierEvent_LeaderboardSort2[QualifierEvent_LeaderboardSort2["MaxComboAscending"] = 10] = "MaxComboAscending";
  QualifierEvent_LeaderboardSort2[QualifierEvent_LeaderboardSort2["MaxComboTarget"] = 11] = "MaxComboTarget";
  QualifierEvent_LeaderboardSort2[QualifierEvent_LeaderboardSort2["GoodCuts"] = 12] = "GoodCuts";
  QualifierEvent_LeaderboardSort2[QualifierEvent_LeaderboardSort2["GoodCutsAscending"] = 13] = "GoodCutsAscending";
  QualifierEvent_LeaderboardSort2[QualifierEvent_LeaderboardSort2["GoodCutsTarget"] = 14] = "GoodCutsTarget";
  return QualifierEvent_LeaderboardSort2;
})(QualifierEvent_LeaderboardSort || {});
var Permissions = /* @__PURE__ */ ((Permissions2) => {
  Permissions2[Permissions2["None"] = 0] = "None";
  Permissions2[Permissions2["View"] = 1] = "View";
  Permissions2[Permissions2["Admin"] = 2] = "Admin";
  return Permissions2;
})(Permissions || {});
var Characteristic$Type = class extends MessageType {
  constructor() {
    super("proto.models.Characteristic", [
      {
        no: 1,
        name: "serialized_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "difficulties",
        kind: "scalar",
        repeat: 1,
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
  create(value) {
    const message = { serializedName: "", difficulties: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string serialized_name */
        1:
          message.serializedName = reader.string();
          break;
        case /* repeated int32 difficulties */
        2:
          if (wireType === WireType.LengthDelimited)
            for (let e2 = reader.int32() + reader.pos; reader.pos < e2; )
              message.difficulties.push(reader.int32());
          else
            message.difficulties.push(reader.int32());
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.serializedName !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.serializedName);
    if (message.difficulties.length) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i2 = 0; i2 < message.difficulties.length; i2++)
        writer.int32(message.difficulties[i2]);
      writer.join();
    }
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Characteristic = new Characteristic$Type();
var Beatmap$Type = class extends MessageType {
  constructor() {
    super("proto.models.Beatmap", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "level_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "characteristic", kind: "message", T: () => Characteristic },
      {
        no: 4,
        name: "difficulty",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
  create(value) {
    const message = { name: "", levelId: "", difficulty: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* string level_id */
        2:
          message.levelId = reader.string();
          break;
        case /* proto.models.Characteristic characteristic */
        3:
          message.characteristic = Characteristic.internalBinaryRead(reader, reader.uint32(), options, message.characteristic);
          break;
        case /* int32 difficulty */
        4:
          message.difficulty = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.levelId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.levelId);
    if (message.characteristic)
      Characteristic.internalBinaryWrite(message.characteristic, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.difficulty !== 0)
      writer.tag(4, WireType.Varint).int32(message.difficulty);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Beatmap = new Beatmap$Type();
var GameplayModifiers$Type = class extends MessageType {
  constructor() {
    super("proto.models.GameplayModifiers", [
      { no: 1, name: "options", kind: "enum", T: () => ["proto.models.GameplayModifiers.GameOptions", GameplayModifiers_GameOptions] }
    ]);
  }
  create(value) {
    const message = { options: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* proto.models.GameplayModifiers.GameOptions options */
        1:
          message.options = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.options !== 0)
      writer.tag(1, WireType.Varint).int32(message.options);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var GameplayModifiers = new GameplayModifiers$Type();
var PlayerSpecificSettings$Type = class extends MessageType {
  constructor() {
    super("proto.models.PlayerSpecificSettings", [
      {
        no: 1,
        name: "player_height",
        kind: "scalar",
        T: 2
        /*ScalarType.FLOAT*/
      },
      {
        no: 2,
        name: "sfx_volume",
        kind: "scalar",
        T: 2
        /*ScalarType.FLOAT*/
      },
      {
        no: 3,
        name: "saber_trail_intensity",
        kind: "scalar",
        T: 2
        /*ScalarType.FLOAT*/
      },
      {
        no: 4,
        name: "note_jump_start_beat_offset",
        kind: "scalar",
        T: 2
        /*ScalarType.FLOAT*/
      },
      {
        no: 5,
        name: "note_jump_fixed_duration",
        kind: "scalar",
        T: 2
        /*ScalarType.FLOAT*/
      },
      { no: 6, name: "options", kind: "enum", T: () => ["proto.models.PlayerSpecificSettings.PlayerOptions", PlayerSpecificSettings_PlayerOptions] },
      { no: 7, name: "note_jump_duration_type_settings", kind: "enum", T: () => ["proto.models.PlayerSpecificSettings.NoteJumpDurationTypeSettings", PlayerSpecificSettings_NoteJumpDurationTypeSettings] },
      { no: 8, name: "arc_visibility_type", kind: "enum", T: () => ["proto.models.PlayerSpecificSettings.ArcVisibilityType", PlayerSpecificSettings_ArcVisibilityType] }
    ]);
  }
  create(value) {
    const message = { playerHeight: 0, sfxVolume: 0, saberTrailIntensity: 0, noteJumpStartBeatOffset: 0, noteJumpFixedDuration: 0, options: 0, noteJumpDurationTypeSettings: 0, arcVisibilityType: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* float player_height */
        1:
          message.playerHeight = reader.float();
          break;
        case /* float sfx_volume */
        2:
          message.sfxVolume = reader.float();
          break;
        case /* float saber_trail_intensity */
        3:
          message.saberTrailIntensity = reader.float();
          break;
        case /* float note_jump_start_beat_offset */
        4:
          message.noteJumpStartBeatOffset = reader.float();
          break;
        case /* float note_jump_fixed_duration */
        5:
          message.noteJumpFixedDuration = reader.float();
          break;
        case /* proto.models.PlayerSpecificSettings.PlayerOptions options */
        6:
          message.options = reader.int32();
          break;
        case /* proto.models.PlayerSpecificSettings.NoteJumpDurationTypeSettings note_jump_duration_type_settings */
        7:
          message.noteJumpDurationTypeSettings = reader.int32();
          break;
        case /* proto.models.PlayerSpecificSettings.ArcVisibilityType arc_visibility_type */
        8:
          message.arcVisibilityType = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.playerHeight !== 0)
      writer.tag(1, WireType.Bit32).float(message.playerHeight);
    if (message.sfxVolume !== 0)
      writer.tag(2, WireType.Bit32).float(message.sfxVolume);
    if (message.saberTrailIntensity !== 0)
      writer.tag(3, WireType.Bit32).float(message.saberTrailIntensity);
    if (message.noteJumpStartBeatOffset !== 0)
      writer.tag(4, WireType.Bit32).float(message.noteJumpStartBeatOffset);
    if (message.noteJumpFixedDuration !== 0)
      writer.tag(5, WireType.Bit32).float(message.noteJumpFixedDuration);
    if (message.options !== 0)
      writer.tag(6, WireType.Varint).int32(message.options);
    if (message.noteJumpDurationTypeSettings !== 0)
      writer.tag(7, WireType.Varint).int32(message.noteJumpDurationTypeSettings);
    if (message.arcVisibilityType !== 0)
      writer.tag(8, WireType.Varint).int32(message.arcVisibilityType);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var PlayerSpecificSettings = new PlayerSpecificSettings$Type();
var GameplayParameters$Type = class extends MessageType {
  constructor() {
    super("proto.models.GameplayParameters", [
      { no: 1, name: "beatmap", kind: "message", T: () => Beatmap },
      { no: 2, name: "player_settings", kind: "message", T: () => PlayerSpecificSettings },
      { no: 3, name: "gameplay_modifiers", kind: "message", T: () => GameplayModifiers },
      {
        no: 4,
        name: "attempts",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 5,
        name: "show_scoreboard",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 6,
        name: "disable_pause",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 7,
        name: "disable_fail",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 8,
        name: "disable_scoresaber_submission",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 9,
        name: "disable_custom_notes_on_stream",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 10,
        name: "use_sync",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 11,
        name: "target",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
  create(value) {
    const message = { attempts: 0, showScoreboard: false, disablePause: false, disableFail: false, disableScoresaberSubmission: false, disableCustomNotesOnStream: false, useSync: false, target: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* proto.models.Beatmap beatmap */
        1:
          message.beatmap = Beatmap.internalBinaryRead(reader, reader.uint32(), options, message.beatmap);
          break;
        case /* proto.models.PlayerSpecificSettings player_settings */
        2:
          message.playerSettings = PlayerSpecificSettings.internalBinaryRead(reader, reader.uint32(), options, message.playerSettings);
          break;
        case /* proto.models.GameplayModifiers gameplay_modifiers */
        3:
          message.gameplayModifiers = GameplayModifiers.internalBinaryRead(reader, reader.uint32(), options, message.gameplayModifiers);
          break;
        case /* int32 attempts */
        4:
          message.attempts = reader.int32();
          break;
        case /* bool show_scoreboard */
        5:
          message.showScoreboard = reader.bool();
          break;
        case /* bool disable_pause */
        6:
          message.disablePause = reader.bool();
          break;
        case /* bool disable_fail */
        7:
          message.disableFail = reader.bool();
          break;
        case /* bool disable_scoresaber_submission */
        8:
          message.disableScoresaberSubmission = reader.bool();
          break;
        case /* bool disable_custom_notes_on_stream */
        9:
          message.disableCustomNotesOnStream = reader.bool();
          break;
        case /* bool use_sync */
        10:
          message.useSync = reader.bool();
          break;
        case /* int32 target */
        11:
          message.target = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.beatmap)
      Beatmap.internalBinaryWrite(message.beatmap, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.playerSettings)
      PlayerSpecificSettings.internalBinaryWrite(message.playerSettings, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.gameplayModifiers)
      GameplayModifiers.internalBinaryWrite(message.gameplayModifiers, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.attempts !== 0)
      writer.tag(4, WireType.Varint).int32(message.attempts);
    if (message.showScoreboard !== false)
      writer.tag(5, WireType.Varint).bool(message.showScoreboard);
    if (message.disablePause !== false)
      writer.tag(6, WireType.Varint).bool(message.disablePause);
    if (message.disableFail !== false)
      writer.tag(7, WireType.Varint).bool(message.disableFail);
    if (message.disableScoresaberSubmission !== false)
      writer.tag(8, WireType.Varint).bool(message.disableScoresaberSubmission);
    if (message.disableCustomNotesOnStream !== false)
      writer.tag(9, WireType.Varint).bool(message.disableCustomNotesOnStream);
    if (message.useSync !== false)
      writer.tag(10, WireType.Varint).bool(message.useSync);
    if (message.target !== 0)
      writer.tag(11, WireType.Varint).int32(message.target);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var GameplayParameters = new GameplayParameters$Type();
var Map$Type = class extends MessageType {
  constructor() {
    super("proto.models.Map", [
      {
        no: 1,
        name: "guid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "gameplay_parameters", kind: "message", T: () => GameplayParameters }
    ]);
  }
  create(value) {
    const message = { guid: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string guid */
        1:
          message.guid = reader.string();
          break;
        case /* proto.models.GameplayParameters gameplay_parameters */
        2:
          message.gameplayParameters = GameplayParameters.internalBinaryRead(reader, reader.uint32(), options, message.gameplayParameters);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.guid !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.guid);
    if (message.gameplayParameters)
      GameplayParameters.internalBinaryWrite(message.gameplayParameters, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Map2 = new Map$Type();
var User$Type = class extends MessageType {
  constructor() {
    super("proto.models.User", [
      {
        no: 1,
        name: "guid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "platform_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "client_type", kind: "enum", T: () => ["proto.models.User.ClientTypes", User_ClientTypes] },
      {
        no: 5,
        name: "team_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 6, name: "play_state", kind: "enum", T: () => ["proto.models.User.PlayStates", User_PlayStates] },
      { no: 7, name: "download_state", kind: "enum", T: () => ["proto.models.User.DownloadStates", User_DownloadStates] },
      {
        no: 8,
        name: "mod_list",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 9, name: "stream_screen_coordinates", kind: "message", T: () => User_Point },
      {
        no: 10,
        name: "stream_delay_ms",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 11,
        name: "stream_sync_start_ms",
        kind: "scalar",
        T: 3,
        L: 0
        /*LongType.BIGINT*/
      },
      { no: 12, name: "discord_info", kind: "message", T: () => User_DiscordInfo },
      {
        no: 13,
        name: "user_image",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 14, name: "permissions", kind: "enum", T: () => ["proto.models.Permissions", Permissions] }
    ]);
  }
  create(value) {
    const message = { guid: "", name: "", platformId: "", clientType: 0, teamId: "", playState: 0, downloadState: 0, modList: [], streamDelayMs: 0n, streamSyncStartMs: 0n, userImage: new Uint8Array(0), permissions: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string guid */
        1:
          message.guid = reader.string();
          break;
        case /* string name */
        2:
          message.name = reader.string();
          break;
        case /* string platform_id */
        3:
          message.platformId = reader.string();
          break;
        case /* proto.models.User.ClientTypes client_type */
        4:
          message.clientType = reader.int32();
          break;
        case /* string team_id */
        5:
          message.teamId = reader.string();
          break;
        case /* proto.models.User.PlayStates play_state */
        6:
          message.playState = reader.int32();
          break;
        case /* proto.models.User.DownloadStates download_state */
        7:
          message.downloadState = reader.int32();
          break;
        case /* repeated string mod_list */
        8:
          message.modList.push(reader.string());
          break;
        case /* proto.models.User.Point stream_screen_coordinates */
        9:
          message.streamScreenCoordinates = User_Point.internalBinaryRead(reader, reader.uint32(), options, message.streamScreenCoordinates);
          break;
        case /* int64 stream_delay_ms */
        10:
          message.streamDelayMs = reader.int64().toBigInt();
          break;
        case /* int64 stream_sync_start_ms */
        11:
          message.streamSyncStartMs = reader.int64().toBigInt();
          break;
        case /* proto.models.User.DiscordInfo discord_info */
        12:
          message.discordInfo = User_DiscordInfo.internalBinaryRead(reader, reader.uint32(), options, message.discordInfo);
          break;
        case /* bytes user_image */
        13:
          message.userImage = reader.bytes();
          break;
        case /* proto.models.Permissions permissions */
        14:
          message.permissions = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.guid !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.guid);
    if (message.name !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.name);
    if (message.platformId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.platformId);
    if (message.clientType !== 0)
      writer.tag(4, WireType.Varint).int32(message.clientType);
    if (message.teamId !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.teamId);
    if (message.playState !== 0)
      writer.tag(6, WireType.Varint).int32(message.playState);
    if (message.downloadState !== 0)
      writer.tag(7, WireType.Varint).int32(message.downloadState);
    for (let i2 = 0; i2 < message.modList.length; i2++)
      writer.tag(8, WireType.LengthDelimited).string(message.modList[i2]);
    if (message.streamScreenCoordinates)
      User_Point.internalBinaryWrite(message.streamScreenCoordinates, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
    if (message.streamDelayMs !== 0n)
      writer.tag(10, WireType.Varint).int64(message.streamDelayMs);
    if (message.streamSyncStartMs !== 0n)
      writer.tag(11, WireType.Varint).int64(message.streamSyncStartMs);
    if (message.discordInfo)
      User_DiscordInfo.internalBinaryWrite(message.discordInfo, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
    if (message.userImage.length)
      writer.tag(13, WireType.LengthDelimited).bytes(message.userImage);
    if (message.permissions !== 0)
      writer.tag(14, WireType.Varint).int32(message.permissions);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var User = new User$Type();
var User_DiscordInfo$Type = class extends MessageType {
  constructor() {
    super("proto.models.User.DiscordInfo", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "username",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "avatar_url",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { userId: "", username: "", avatarUrl: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string user_id */
        1:
          message.userId = reader.string();
          break;
        case /* string username */
        2:
          message.username = reader.string();
          break;
        case /* string avatar_url */
        3:
          message.avatarUrl = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.userId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.userId);
    if (message.username !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.username);
    if (message.avatarUrl !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.avatarUrl);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var User_DiscordInfo = new User_DiscordInfo$Type();
var User_Point$Type = class extends MessageType {
  constructor() {
    super("proto.models.User.Point", [
      {
        no: 1,
        name: "x",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: "y",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
  create(value) {
    const message = { x: 0, y: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 x */
        1:
          message.x = reader.int32();
          break;
        case /* int32 y */
        2:
          message.y = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.x !== 0)
      writer.tag(1, WireType.Varint).int32(message.x);
    if (message.y !== 0)
      writer.tag(2, WireType.Varint).int32(message.y);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var User_Point = new User_Point$Type();
var Match$Type = class extends MessageType {
  constructor() {
    super("proto.models.Match", [
      {
        no: 1,
        name: "guid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "associated_users",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "leader",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "selected_map", kind: "message", T: () => Map2 }
    ]);
  }
  create(value) {
    const message = { guid: "", associatedUsers: [], leader: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string guid */
        1:
          message.guid = reader.string();
          break;
        case /* repeated string associated_users */
        2:
          message.associatedUsers.push(reader.string());
          break;
        case /* string leader */
        3:
          message.leader = reader.string();
          break;
        case /* proto.models.Map selected_map */
        4:
          message.selectedMap = Map2.internalBinaryRead(reader, reader.uint32(), options, message.selectedMap);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.guid !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.guid);
    for (let i2 = 0; i2 < message.associatedUsers.length; i2++)
      writer.tag(2, WireType.LengthDelimited).string(message.associatedUsers[i2]);
    if (message.leader !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.leader);
    if (message.selectedMap)
      Map2.internalBinaryWrite(message.selectedMap, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Match = new Match$Type();
var QualifierEvent$Type = class extends MessageType {
  constructor() {
    super("proto.models.QualifierEvent", [
      {
        no: 1,
        name: "guid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "image",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 4, name: "info_channel", kind: "message", T: () => Channel },
      { no: 5, name: "qualifier_maps", kind: "message", repeat: 1, T: () => Map2 },
      { no: 6, name: "flags", kind: "enum", T: () => ["proto.models.QualifierEvent.EventSettings", QualifierEvent_EventSettings] },
      { no: 7, name: "sort", kind: "enum", T: () => ["proto.models.QualifierEvent.LeaderboardSort", QualifierEvent_LeaderboardSort] }
    ]);
  }
  create(value) {
    const message = { guid: "", name: "", image: new Uint8Array(0), qualifierMaps: [], flags: 0, sort: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string guid */
        1:
          message.guid = reader.string();
          break;
        case /* string name */
        2:
          message.name = reader.string();
          break;
        case /* bytes image */
        3:
          message.image = reader.bytes();
          break;
        case /* proto.discord.Channel info_channel */
        4:
          message.infoChannel = Channel.internalBinaryRead(reader, reader.uint32(), options, message.infoChannel);
          break;
        case /* repeated proto.models.Map qualifier_maps */
        5:
          message.qualifierMaps.push(Map2.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* proto.models.QualifierEvent.EventSettings flags */
        6:
          message.flags = reader.int32();
          break;
        case /* proto.models.QualifierEvent.LeaderboardSort sort */
        7:
          message.sort = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.guid !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.guid);
    if (message.name !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.name);
    if (message.image.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.image);
    if (message.infoChannel)
      Channel.internalBinaryWrite(message.infoChannel, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    for (let i2 = 0; i2 < message.qualifierMaps.length; i2++)
      Map2.internalBinaryWrite(message.qualifierMaps[i2], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.flags !== 0)
      writer.tag(6, WireType.Varint).int32(message.flags);
    if (message.sort !== 0)
      writer.tag(7, WireType.Varint).int32(message.sort);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var QualifierEvent = new QualifierEvent$Type();
var CoreServer$Type = class extends MessageType {
  constructor() {
    super("proto.models.CoreServer", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "port",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: "websocket_port",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
  create(value) {
    const message = { name: "", address: "", port: 0, websocketPort: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */
        1:
          message.name = reader.string();
          break;
        case /* string address */
        2:
          message.address = reader.string();
          break;
        case /* int32 port */
        3:
          message.port = reader.int32();
          break;
        case /* int32 websocket_port */
        4:
          message.websocketPort = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    if (message.address !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.address);
    if (message.port !== 0)
      writer.tag(3, WireType.Varint).int32(message.port);
    if (message.websocketPort !== 0)
      writer.tag(4, WireType.Varint).int32(message.websocketPort);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var CoreServer = new CoreServer$Type();
var Tournament$Type = class extends MessageType {
  constructor() {
    super("proto.models.Tournament", [
      {
        no: 1,
        name: "guid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "settings", kind: "message", T: () => Tournament_TournamentSettings },
      { no: 3, name: "users", kind: "message", repeat: 1, T: () => User },
      { no: 4, name: "matches", kind: "message", repeat: 1, T: () => Match },
      { no: 5, name: "qualifiers", kind: "message", repeat: 1, T: () => QualifierEvent },
      { no: 6, name: "server", kind: "message", T: () => CoreServer }
    ]);
  }
  create(value) {
    const message = { guid: "", users: [], matches: [], qualifiers: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string guid */
        1:
          message.guid = reader.string();
          break;
        case /* proto.models.Tournament.TournamentSettings settings */
        2:
          message.settings = Tournament_TournamentSettings.internalBinaryRead(reader, reader.uint32(), options, message.settings);
          break;
        case /* repeated proto.models.User users */
        3:
          message.users.push(User.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated proto.models.Match matches */
        4:
          message.matches.push(Match.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated proto.models.QualifierEvent qualifiers */
        5:
          message.qualifiers.push(QualifierEvent.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* proto.models.CoreServer server */
        6:
          message.server = CoreServer.internalBinaryRead(reader, reader.uint32(), options, message.server);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.guid !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.guid);
    if (message.settings)
      Tournament_TournamentSettings.internalBinaryWrite(message.settings, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    for (let i2 = 0; i2 < message.users.length; i2++)
      User.internalBinaryWrite(message.users[i2], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    for (let i2 = 0; i2 < message.matches.length; i2++)
      Match.internalBinaryWrite(message.matches[i2], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    for (let i2 = 0; i2 < message.qualifiers.length; i2++)
      QualifierEvent.internalBinaryWrite(message.qualifiers[i2], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.server)
      CoreServer.internalBinaryWrite(message.server, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Tournament = new Tournament$Type();
var Tournament_TournamentSettings$Type = class extends MessageType {
  constructor() {
    super("proto.models.Tournament.TournamentSettings", [
      {
        no: 1,
        name: "tournament_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "tournament_image",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      {
        no: 3,
        name: "enable_teams",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "enable_pools",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 5, name: "teams", kind: "message", repeat: 1, T: () => Tournament_TournamentSettings_Team },
      {
        no: 6,
        name: "score_update_frequency",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 7,
        name: "banned_mods",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 8, name: "pools", kind: "message", repeat: 1, T: () => Tournament_TournamentSettings_Pool },
      {
        no: 9,
        name: "show_tournament_button",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 10,
        name: "show_qualifier_button",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 11,
        name: "allow_unauthorized_view",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentName: "", tournamentImage: new Uint8Array(0), enableTeams: false, enablePools: false, teams: [], scoreUpdateFrequency: 0, bannedMods: [], pools: [], showTournamentButton: false, showQualifierButton: false, allowUnauthorizedView: false };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_name */
        1:
          message.tournamentName = reader.string();
          break;
        case /* bytes tournament_image */
        2:
          message.tournamentImage = reader.bytes();
          break;
        case /* bool enable_teams */
        3:
          message.enableTeams = reader.bool();
          break;
        case /* bool enable_pools */
        4:
          message.enablePools = reader.bool();
          break;
        case /* repeated proto.models.Tournament.TournamentSettings.Team teams */
        5:
          message.teams.push(Tournament_TournamentSettings_Team.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* int32 score_update_frequency */
        6:
          message.scoreUpdateFrequency = reader.int32();
          break;
        case /* repeated string banned_mods */
        7:
          message.bannedMods.push(reader.string());
          break;
        case /* repeated proto.models.Tournament.TournamentSettings.Pool pools */
        8:
          message.pools.push(Tournament_TournamentSettings_Pool.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* bool show_tournament_button */
        9:
          message.showTournamentButton = reader.bool();
          break;
        case /* bool show_qualifier_button */
        10:
          message.showQualifierButton = reader.bool();
          break;
        case /* bool allow_unauthorized_view */
        11:
          message.allowUnauthorizedView = reader.bool();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentName !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentName);
    if (message.tournamentImage.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.tournamentImage);
    if (message.enableTeams !== false)
      writer.tag(3, WireType.Varint).bool(message.enableTeams);
    if (message.enablePools !== false)
      writer.tag(4, WireType.Varint).bool(message.enablePools);
    for (let i2 = 0; i2 < message.teams.length; i2++)
      Tournament_TournamentSettings_Team.internalBinaryWrite(message.teams[i2], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.scoreUpdateFrequency !== 0)
      writer.tag(6, WireType.Varint).int32(message.scoreUpdateFrequency);
    for (let i2 = 0; i2 < message.bannedMods.length; i2++)
      writer.tag(7, WireType.LengthDelimited).string(message.bannedMods[i2]);
    for (let i2 = 0; i2 < message.pools.length; i2++)
      Tournament_TournamentSettings_Pool.internalBinaryWrite(message.pools[i2], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    if (message.showTournamentButton !== false)
      writer.tag(9, WireType.Varint).bool(message.showTournamentButton);
    if (message.showQualifierButton !== false)
      writer.tag(10, WireType.Varint).bool(message.showQualifierButton);
    if (message.allowUnauthorizedView !== false)
      writer.tag(11, WireType.Varint).bool(message.allowUnauthorizedView);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Tournament_TournamentSettings = new Tournament_TournamentSettings$Type();
var Tournament_TournamentSettings_Pool$Type = class extends MessageType {
  constructor() {
    super("proto.models.Tournament.TournamentSettings.Pool", [
      {
        no: 1,
        name: "guid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "image",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      },
      { no: 4, name: "maps", kind: "message", repeat: 1, T: () => Map2 }
    ]);
  }
  create(value) {
    const message = { guid: "", name: "", image: new Uint8Array(0), maps: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string guid */
        1:
          message.guid = reader.string();
          break;
        case /* string name */
        2:
          message.name = reader.string();
          break;
        case /* bytes image */
        3:
          message.image = reader.bytes();
          break;
        case /* repeated proto.models.Map maps */
        4:
          message.maps.push(Map2.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.guid !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.guid);
    if (message.name !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.name);
    if (message.image.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.image);
    for (let i2 = 0; i2 < message.maps.length; i2++)
      Map2.internalBinaryWrite(message.maps[i2], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Tournament_TournamentSettings_Pool = new Tournament_TournamentSettings_Pool$Type();
var Tournament_TournamentSettings_Team$Type = class extends MessageType {
  constructor() {
    super("proto.models.Tournament.TournamentSettings.Team", [
      {
        no: 1,
        name: "guid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "image",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = { guid: "", name: "", image: new Uint8Array(0) };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string guid */
        1:
          message.guid = reader.string();
          break;
        case /* string name */
        2:
          message.name = reader.string();
          break;
        case /* bytes image */
        3:
          message.image = reader.bytes();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.guid !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.guid);
    if (message.name !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.name);
    if (message.image.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.image);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Tournament_TournamentSettings_Team = new Tournament_TournamentSettings_Team$Type();
var State$Type = class extends MessageType {
  constructor() {
    super("proto.models.State", [
      { no: 1, name: "tournaments", kind: "message", repeat: 1, T: () => Tournament },
      { no: 2, name: "known_servers", kind: "message", repeat: 1, T: () => CoreServer }
    ]);
  }
  create(value) {
    const message = { tournaments: [], knownServers: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated proto.models.Tournament tournaments */
        1:
          message.tournaments.push(Tournament.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* repeated proto.models.CoreServer known_servers */
        2:
          message.knownServers.push(CoreServer.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i2 = 0; i2 < message.tournaments.length; i2++)
      Tournament.internalBinaryWrite(message.tournaments[i2], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    for (let i2 = 0; i2 < message.knownServers.length; i2++)
      CoreServer.internalBinaryWrite(message.knownServers[i2], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var State = new State$Type();
var LeaderboardEntry$Type = class extends MessageType {
  constructor() {
    super("proto.models.LeaderboardEntry", [
      {
        no: 1,
        name: "event_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "map_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "platform_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "username",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "multiplied_score",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 6,
        name: "modified_score",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 7,
        name: "max_possible_score",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 8,
        name: "accuracy",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 9,
        name: "notes_missed",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 10,
        name: "bad_cuts",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 11,
        name: "good_cuts",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 12,
        name: "max_combo",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 13,
        name: "full_combo",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 14,
        name: "is_placeholder",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 15,
        name: "color",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { eventId: "", mapId: "", platformId: "", username: "", multipliedScore: 0, modifiedScore: 0, maxPossibleScore: 0, accuracy: 0, notesMissed: 0, badCuts: 0, goodCuts: 0, maxCombo: 0, fullCombo: false, isPlaceholder: false, color: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string event_id */
        1:
          message.eventId = reader.string();
          break;
        case /* string map_id */
        2:
          message.mapId = reader.string();
          break;
        case /* string platform_id */
        3:
          message.platformId = reader.string();
          break;
        case /* string username */
        4:
          message.username = reader.string();
          break;
        case /* int32 multiplied_score */
        5:
          message.multipliedScore = reader.int32();
          break;
        case /* int32 modified_score */
        6:
          message.modifiedScore = reader.int32();
          break;
        case /* int32 max_possible_score */
        7:
          message.maxPossibleScore = reader.int32();
          break;
        case /* double accuracy */
        8:
          message.accuracy = reader.double();
          break;
        case /* int32 notes_missed */
        9:
          message.notesMissed = reader.int32();
          break;
        case /* int32 bad_cuts */
        10:
          message.badCuts = reader.int32();
          break;
        case /* int32 good_cuts */
        11:
          message.goodCuts = reader.int32();
          break;
        case /* int32 max_combo */
        12:
          message.maxCombo = reader.int32();
          break;
        case /* bool full_combo */
        13:
          message.fullCombo = reader.bool();
          break;
        case /* bool is_placeholder */
        14:
          message.isPlaceholder = reader.bool();
          break;
        case /* string color */
        15:
          message.color = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.eventId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.eventId);
    if (message.mapId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.mapId);
    if (message.platformId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.platformId);
    if (message.username !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.username);
    if (message.multipliedScore !== 0)
      writer.tag(5, WireType.Varint).int32(message.multipliedScore);
    if (message.modifiedScore !== 0)
      writer.tag(6, WireType.Varint).int32(message.modifiedScore);
    if (message.maxPossibleScore !== 0)
      writer.tag(7, WireType.Varint).int32(message.maxPossibleScore);
    if (message.accuracy !== 0)
      writer.tag(8, WireType.Bit64).double(message.accuracy);
    if (message.notesMissed !== 0)
      writer.tag(9, WireType.Varint).int32(message.notesMissed);
    if (message.badCuts !== 0)
      writer.tag(10, WireType.Varint).int32(message.badCuts);
    if (message.goodCuts !== 0)
      writer.tag(11, WireType.Varint).int32(message.goodCuts);
    if (message.maxCombo !== 0)
      writer.tag(12, WireType.Varint).int32(message.maxCombo);
    if (message.fullCombo !== false)
      writer.tag(13, WireType.Varint).bool(message.fullCombo);
    if (message.isPlaceholder !== false)
      writer.tag(14, WireType.Varint).bool(message.isPlaceholder);
    if (message.color !== "")
      writer.tag(15, WireType.LengthDelimited).string(message.color);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var LeaderboardEntry = new LeaderboardEntry$Type();
var RealtimeScore$Type = class extends MessageType {
  constructor() {
    super("proto.models.RealtimeScore", [
      {
        no: 1,
        name: "user_guid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "score",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "score_with_modifiers",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: "max_score",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 5,
        name: "max_score_with_modifiers",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 6,
        name: "combo",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 7,
        name: "player_health",
        kind: "scalar",
        T: 2
        /*ScalarType.FLOAT*/
      },
      {
        no: 8,
        name: "accuracy",
        kind: "scalar",
        T: 2
        /*ScalarType.FLOAT*/
      },
      {
        no: 9,
        name: "song_position",
        kind: "scalar",
        T: 2
        /*ScalarType.FLOAT*/
      },
      {
        no: 10,
        name: "notes_missed",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 11,
        name: "bad_cuts",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 12,
        name: "bomb_hits",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 13,
        name: "wall_hits",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 14,
        name: "max_combo",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      { no: 15, name: "left_hand", kind: "message", T: () => ScoreTrackerHand },
      { no: 16, name: "right_hand", kind: "message", T: () => ScoreTrackerHand }
    ]);
  }
  create(value) {
    const message = { userGuid: "", score: 0, scoreWithModifiers: 0, maxScore: 0, maxScoreWithModifiers: 0, combo: 0, playerHealth: 0, accuracy: 0, songPosition: 0, notesMissed: 0, badCuts: 0, bombHits: 0, wallHits: 0, maxCombo: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string user_guid */
        1:
          message.userGuid = reader.string();
          break;
        case /* int32 score */
        2:
          message.score = reader.int32();
          break;
        case /* int32 score_with_modifiers */
        3:
          message.scoreWithModifiers = reader.int32();
          break;
        case /* int32 max_score */
        4:
          message.maxScore = reader.int32();
          break;
        case /* int32 max_score_with_modifiers */
        5:
          message.maxScoreWithModifiers = reader.int32();
          break;
        case /* int32 combo */
        6:
          message.combo = reader.int32();
          break;
        case /* float player_health */
        7:
          message.playerHealth = reader.float();
          break;
        case /* float accuracy */
        8:
          message.accuracy = reader.float();
          break;
        case /* float song_position */
        9:
          message.songPosition = reader.float();
          break;
        case /* int32 notes_missed */
        10:
          message.notesMissed = reader.int32();
          break;
        case /* int32 bad_cuts */
        11:
          message.badCuts = reader.int32();
          break;
        case /* int32 bomb_hits */
        12:
          message.bombHits = reader.int32();
          break;
        case /* int32 wall_hits */
        13:
          message.wallHits = reader.int32();
          break;
        case /* int32 max_combo */
        14:
          message.maxCombo = reader.int32();
          break;
        case /* proto.models.ScoreTrackerHand left_hand */
        15:
          message.leftHand = ScoreTrackerHand.internalBinaryRead(reader, reader.uint32(), options, message.leftHand);
          break;
        case /* proto.models.ScoreTrackerHand right_hand */
        16:
          message.rightHand = ScoreTrackerHand.internalBinaryRead(reader, reader.uint32(), options, message.rightHand);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.userGuid !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.userGuid);
    if (message.score !== 0)
      writer.tag(2, WireType.Varint).int32(message.score);
    if (message.scoreWithModifiers !== 0)
      writer.tag(3, WireType.Varint).int32(message.scoreWithModifiers);
    if (message.maxScore !== 0)
      writer.tag(4, WireType.Varint).int32(message.maxScore);
    if (message.maxScoreWithModifiers !== 0)
      writer.tag(5, WireType.Varint).int32(message.maxScoreWithModifiers);
    if (message.combo !== 0)
      writer.tag(6, WireType.Varint).int32(message.combo);
    if (message.playerHealth !== 0)
      writer.tag(7, WireType.Bit32).float(message.playerHealth);
    if (message.accuracy !== 0)
      writer.tag(8, WireType.Bit32).float(message.accuracy);
    if (message.songPosition !== 0)
      writer.tag(9, WireType.Bit32).float(message.songPosition);
    if (message.notesMissed !== 0)
      writer.tag(10, WireType.Varint).int32(message.notesMissed);
    if (message.badCuts !== 0)
      writer.tag(11, WireType.Varint).int32(message.badCuts);
    if (message.bombHits !== 0)
      writer.tag(12, WireType.Varint).int32(message.bombHits);
    if (message.wallHits !== 0)
      writer.tag(13, WireType.Varint).int32(message.wallHits);
    if (message.maxCombo !== 0)
      writer.tag(14, WireType.Varint).int32(message.maxCombo);
    if (message.leftHand)
      ScoreTrackerHand.internalBinaryWrite(message.leftHand, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
    if (message.rightHand)
      ScoreTrackerHand.internalBinaryWrite(message.rightHand, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var RealtimeScore = new RealtimeScore$Type();
var ScoreTrackerHand$Type = class extends MessageType {
  constructor() {
    super("proto.models.ScoreTrackerHand", [
      {
        no: 1,
        name: "hit",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: "miss",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "bad_cut",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: "avg_cut",
        kind: "scalar",
        repeat: 1,
        T: 2
        /*ScalarType.FLOAT*/
      }
    ]);
  }
  create(value) {
    const message = { hit: 0, miss: 0, badCut: 0, avgCut: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 hit */
        1:
          message.hit = reader.int32();
          break;
        case /* int32 miss */
        2:
          message.miss = reader.int32();
          break;
        case /* int32 bad_cut */
        3:
          message.badCut = reader.int32();
          break;
        case /* repeated float avg_cut */
        4:
          if (wireType === WireType.LengthDelimited)
            for (let e2 = reader.int32() + reader.pos; reader.pos < e2; )
              message.avgCut.push(reader.float());
          else
            message.avgCut.push(reader.float());
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.hit !== 0)
      writer.tag(1, WireType.Varint).int32(message.hit);
    if (message.miss !== 0)
      writer.tag(2, WireType.Varint).int32(message.miss);
    if (message.badCut !== 0)
      writer.tag(3, WireType.Varint).int32(message.badCut);
    if (message.avgCut.length) {
      writer.tag(4, WireType.LengthDelimited).fork();
      for (let i2 = 0; i2 < message.avgCut.length; i2++)
        writer.float(message.avgCut[i2]);
      writer.join();
    }
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var ScoreTrackerHand = new ScoreTrackerHand$Type();

// src/models/events.ts
var Event$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Event", [
      { no: 1, name: "user_added", kind: "message", oneof: "changedObject", T: () => Event_UserAdded },
      { no: 2, name: "user_updated", kind: "message", oneof: "changedObject", T: () => Event_UserUpdated },
      { no: 3, name: "user_left", kind: "message", oneof: "changedObject", T: () => Event_UserLeft },
      { no: 6, name: "match_created", kind: "message", oneof: "changedObject", T: () => Event_MatchCreated },
      { no: 7, name: "match_updated", kind: "message", oneof: "changedObject", T: () => Event_MatchUpdated },
      { no: 8, name: "match_deleted", kind: "message", oneof: "changedObject", T: () => Event_MatchDeleted },
      { no: 9, name: "qualifier_created", kind: "message", oneof: "changedObject", T: () => Event_QualifierCreated },
      { no: 10, name: "qualifier_updated", kind: "message", oneof: "changedObject", T: () => Event_QualifierUpdated },
      { no: 11, name: "qualifier_deleted", kind: "message", oneof: "changedObject", T: () => Event_QualifierDeleted },
      { no: 12, name: "tournament_created", kind: "message", oneof: "changedObject", T: () => Event_TournamentCreated },
      { no: 13, name: "tournament_updated", kind: "message", oneof: "changedObject", T: () => Event_TournamentUpdated },
      { no: 14, name: "tournament_deleted", kind: "message", oneof: "changedObject", T: () => Event_TournamentDeleted },
      { no: 15, name: "server_added", kind: "message", oneof: "changedObject", T: () => Event_ServerAdded },
      { no: 16, name: "server_deleted", kind: "message", oneof: "changedObject", T: () => Event_ServerDeleted }
    ]);
  }
  create(value) {
    const message = { changedObject: { oneofKind: void 0 } };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* proto.packets.Event.UserAdded user_added */
        1:
          message.changedObject = {
            oneofKind: "userAdded",
            userAdded: Event_UserAdded.internalBinaryRead(reader, reader.uint32(), options, message.changedObject.userAdded)
          };
          break;
        case /* proto.packets.Event.UserUpdated user_updated */
        2:
          message.changedObject = {
            oneofKind: "userUpdated",
            userUpdated: Event_UserUpdated.internalBinaryRead(reader, reader.uint32(), options, message.changedObject.userUpdated)
          };
          break;
        case /* proto.packets.Event.UserLeft user_left */
        3:
          message.changedObject = {
            oneofKind: "userLeft",
            userLeft: Event_UserLeft.internalBinaryRead(reader, reader.uint32(), options, message.changedObject.userLeft)
          };
          break;
        case /* proto.packets.Event.MatchCreated match_created */
        6:
          message.changedObject = {
            oneofKind: "matchCreated",
            matchCreated: Event_MatchCreated.internalBinaryRead(reader, reader.uint32(), options, message.changedObject.matchCreated)
          };
          break;
        case /* proto.packets.Event.MatchUpdated match_updated */
        7:
          message.changedObject = {
            oneofKind: "matchUpdated",
            matchUpdated: Event_MatchUpdated.internalBinaryRead(reader, reader.uint32(), options, message.changedObject.matchUpdated)
          };
          break;
        case /* proto.packets.Event.MatchDeleted match_deleted */
        8:
          message.changedObject = {
            oneofKind: "matchDeleted",
            matchDeleted: Event_MatchDeleted.internalBinaryRead(reader, reader.uint32(), options, message.changedObject.matchDeleted)
          };
          break;
        case /* proto.packets.Event.QualifierCreated qualifier_created */
        9:
          message.changedObject = {
            oneofKind: "qualifierCreated",
            qualifierCreated: Event_QualifierCreated.internalBinaryRead(reader, reader.uint32(), options, message.changedObject.qualifierCreated)
          };
          break;
        case /* proto.packets.Event.QualifierUpdated qualifier_updated */
        10:
          message.changedObject = {
            oneofKind: "qualifierUpdated",
            qualifierUpdated: Event_QualifierUpdated.internalBinaryRead(reader, reader.uint32(), options, message.changedObject.qualifierUpdated)
          };
          break;
        case /* proto.packets.Event.QualifierDeleted qualifier_deleted */
        11:
          message.changedObject = {
            oneofKind: "qualifierDeleted",
            qualifierDeleted: Event_QualifierDeleted.internalBinaryRead(reader, reader.uint32(), options, message.changedObject.qualifierDeleted)
          };
          break;
        case /* proto.packets.Event.TournamentCreated tournament_created */
        12:
          message.changedObject = {
            oneofKind: "tournamentCreated",
            tournamentCreated: Event_TournamentCreated.internalBinaryRead(reader, reader.uint32(), options, message.changedObject.tournamentCreated)
          };
          break;
        case /* proto.packets.Event.TournamentUpdated tournament_updated */
        13:
          message.changedObject = {
            oneofKind: "tournamentUpdated",
            tournamentUpdated: Event_TournamentUpdated.internalBinaryRead(reader, reader.uint32(), options, message.changedObject.tournamentUpdated)
          };
          break;
        case /* proto.packets.Event.TournamentDeleted tournament_deleted */
        14:
          message.changedObject = {
            oneofKind: "tournamentDeleted",
            tournamentDeleted: Event_TournamentDeleted.internalBinaryRead(reader, reader.uint32(), options, message.changedObject.tournamentDeleted)
          };
          break;
        case /* proto.packets.Event.ServerAdded server_added */
        15:
          message.changedObject = {
            oneofKind: "serverAdded",
            serverAdded: Event_ServerAdded.internalBinaryRead(reader, reader.uint32(), options, message.changedObject.serverAdded)
          };
          break;
        case /* proto.packets.Event.ServerDeleted server_deleted */
        16:
          message.changedObject = {
            oneofKind: "serverDeleted",
            serverDeleted: Event_ServerDeleted.internalBinaryRead(reader, reader.uint32(), options, message.changedObject.serverDeleted)
          };
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.changedObject.oneofKind === "userAdded")
      Event_UserAdded.internalBinaryWrite(message.changedObject.userAdded, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.changedObject.oneofKind === "userUpdated")
      Event_UserUpdated.internalBinaryWrite(message.changedObject.userUpdated, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.changedObject.oneofKind === "userLeft")
      Event_UserLeft.internalBinaryWrite(message.changedObject.userLeft, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.changedObject.oneofKind === "matchCreated")
      Event_MatchCreated.internalBinaryWrite(message.changedObject.matchCreated, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.changedObject.oneofKind === "matchUpdated")
      Event_MatchUpdated.internalBinaryWrite(message.changedObject.matchUpdated, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.changedObject.oneofKind === "matchDeleted")
      Event_MatchDeleted.internalBinaryWrite(message.changedObject.matchDeleted, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    if (message.changedObject.oneofKind === "qualifierCreated")
      Event_QualifierCreated.internalBinaryWrite(message.changedObject.qualifierCreated, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
    if (message.changedObject.oneofKind === "qualifierUpdated")
      Event_QualifierUpdated.internalBinaryWrite(message.changedObject.qualifierUpdated, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
    if (message.changedObject.oneofKind === "qualifierDeleted")
      Event_QualifierDeleted.internalBinaryWrite(message.changedObject.qualifierDeleted, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
    if (message.changedObject.oneofKind === "tournamentCreated")
      Event_TournamentCreated.internalBinaryWrite(message.changedObject.tournamentCreated, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
    if (message.changedObject.oneofKind === "tournamentUpdated")
      Event_TournamentUpdated.internalBinaryWrite(message.changedObject.tournamentUpdated, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
    if (message.changedObject.oneofKind === "tournamentDeleted")
      Event_TournamentDeleted.internalBinaryWrite(message.changedObject.tournamentDeleted, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
    if (message.changedObject.oneofKind === "serverAdded")
      Event_ServerAdded.internalBinaryWrite(message.changedObject.serverAdded, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
    if (message.changedObject.oneofKind === "serverDeleted")
      Event_ServerDeleted.internalBinaryWrite(message.changedObject.serverDeleted, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Event = new Event$Type();
var Event_UserAdded$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Event.UserAdded", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "user", kind: "message", T: () => User }
    ]);
  }
  create(value) {
    const message = { tournamentId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* proto.models.User user */
        2:
          message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.user)
      User.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Event_UserAdded = new Event_UserAdded$Type();
var Event_UserUpdated$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Event.UserUpdated", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "user", kind: "message", T: () => User }
    ]);
  }
  create(value) {
    const message = { tournamentId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* proto.models.User user */
        2:
          message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.user)
      User.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Event_UserUpdated = new Event_UserUpdated$Type();
var Event_UserLeft$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Event.UserLeft", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "user", kind: "message", T: () => User }
    ]);
  }
  create(value) {
    const message = { tournamentId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* proto.models.User user */
        2:
          message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.user)
      User.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Event_UserLeft = new Event_UserLeft$Type();
var Event_MatchCreated$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Event.MatchCreated", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "match", kind: "message", T: () => Match }
    ]);
  }
  create(value) {
    const message = { tournamentId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* proto.models.Match match */
        2:
          message.match = Match.internalBinaryRead(reader, reader.uint32(), options, message.match);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.match)
      Match.internalBinaryWrite(message.match, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Event_MatchCreated = new Event_MatchCreated$Type();
var Event_MatchUpdated$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Event.MatchUpdated", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "match", kind: "message", T: () => Match }
    ]);
  }
  create(value) {
    const message = { tournamentId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* proto.models.Match match */
        2:
          message.match = Match.internalBinaryRead(reader, reader.uint32(), options, message.match);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.match)
      Match.internalBinaryWrite(message.match, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Event_MatchUpdated = new Event_MatchUpdated$Type();
var Event_MatchDeleted$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Event.MatchDeleted", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "match", kind: "message", T: () => Match }
    ]);
  }
  create(value) {
    const message = { tournamentId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* proto.models.Match match */
        2:
          message.match = Match.internalBinaryRead(reader, reader.uint32(), options, message.match);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.match)
      Match.internalBinaryWrite(message.match, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Event_MatchDeleted = new Event_MatchDeleted$Type();
var Event_QualifierCreated$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Event.QualifierCreated", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "event", kind: "message", T: () => QualifierEvent }
    ]);
  }
  create(value) {
    const message = { tournamentId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* proto.models.QualifierEvent event */
        2:
          message.event = QualifierEvent.internalBinaryRead(reader, reader.uint32(), options, message.event);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.event)
      QualifierEvent.internalBinaryWrite(message.event, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Event_QualifierCreated = new Event_QualifierCreated$Type();
var Event_QualifierUpdated$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Event.QualifierUpdated", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "event", kind: "message", T: () => QualifierEvent }
    ]);
  }
  create(value) {
    const message = { tournamentId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* proto.models.QualifierEvent event */
        2:
          message.event = QualifierEvent.internalBinaryRead(reader, reader.uint32(), options, message.event);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.event)
      QualifierEvent.internalBinaryWrite(message.event, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Event_QualifierUpdated = new Event_QualifierUpdated$Type();
var Event_QualifierDeleted$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Event.QualifierDeleted", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "event", kind: "message", T: () => QualifierEvent }
    ]);
  }
  create(value) {
    const message = { tournamentId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* proto.models.QualifierEvent event */
        2:
          message.event = QualifierEvent.internalBinaryRead(reader, reader.uint32(), options, message.event);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.event)
      QualifierEvent.internalBinaryWrite(message.event, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Event_QualifierDeleted = new Event_QualifierDeleted$Type();
var Event_TournamentCreated$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Event.TournamentCreated", [
      { no: 1, name: "tournament", kind: "message", T: () => Tournament }
    ]);
  }
  create(value) {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* proto.models.Tournament tournament */
        1:
          message.tournament = Tournament.internalBinaryRead(reader, reader.uint32(), options, message.tournament);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournament)
      Tournament.internalBinaryWrite(message.tournament, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Event_TournamentCreated = new Event_TournamentCreated$Type();
var Event_TournamentUpdated$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Event.TournamentUpdated", [
      { no: 1, name: "tournament", kind: "message", T: () => Tournament }
    ]);
  }
  create(value) {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* proto.models.Tournament tournament */
        1:
          message.tournament = Tournament.internalBinaryRead(reader, reader.uint32(), options, message.tournament);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournament)
      Tournament.internalBinaryWrite(message.tournament, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Event_TournamentUpdated = new Event_TournamentUpdated$Type();
var Event_TournamentDeleted$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Event.TournamentDeleted", [
      { no: 1, name: "tournament", kind: "message", T: () => Tournament }
    ]);
  }
  create(value) {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* proto.models.Tournament tournament */
        1:
          message.tournament = Tournament.internalBinaryRead(reader, reader.uint32(), options, message.tournament);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournament)
      Tournament.internalBinaryWrite(message.tournament, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Event_TournamentDeleted = new Event_TournamentDeleted$Type();
var Event_ServerAdded$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Event.ServerAdded", [
      { no: 1, name: "server", kind: "message", T: () => CoreServer }
    ]);
  }
  create(value) {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* proto.models.CoreServer server */
        1:
          message.server = CoreServer.internalBinaryRead(reader, reader.uint32(), options, message.server);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.server)
      CoreServer.internalBinaryWrite(message.server, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Event_ServerAdded = new Event_ServerAdded$Type();
var Event_ServerDeleted$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Event.ServerDeleted", [
      { no: 1, name: "server", kind: "message", T: () => CoreServer }
    ]);
  }
  create(value) {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* proto.models.CoreServer server */
        1:
          message.server = CoreServer.internalBinaryRead(reader, reader.uint32(), options, message.server);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.server)
      CoreServer.internalBinaryWrite(message.server, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Event_ServerDeleted = new Event_ServerDeleted$Type();

// src/models/responses.ts
init_dirname();
init_buffer2();
init_process2();
var Response_Connect_ConnectFailReason = /* @__PURE__ */ ((Response_Connect_ConnectFailReason2) => {
  Response_Connect_ConnectFailReason2[Response_Connect_ConnectFailReason2["IncorrectVersion"] = 0] = "IncorrectVersion";
  return Response_Connect_ConnectFailReason2;
})(Response_Connect_ConnectFailReason || {});
var Response_Join_JoinFailReason = /* @__PURE__ */ ((Response_Join_JoinFailReason2) => {
  Response_Join_JoinFailReason2[Response_Join_JoinFailReason2["IncorrectPassword"] = 0] = "IncorrectPassword";
  return Response_Join_JoinFailReason2;
})(Response_Join_JoinFailReason || {});
var Response_ResponseType = /* @__PURE__ */ ((Response_ResponseType2) => {
  Response_ResponseType2[Response_ResponseType2["Fail"] = 0] = "Fail";
  Response_ResponseType2[Response_ResponseType2["Success"] = 1] = "Success";
  return Response_ResponseType2;
})(Response_ResponseType || {});
var Response$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response", [
      { no: 1, name: "type", kind: "enum", T: () => ["proto.packets.Response.ResponseType", Response_ResponseType] },
      {
        no: 2,
        name: "responding_to_packet_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "update_user", kind: "message", oneof: "details", T: () => Response_UpdateUser },
      { no: 4, name: "create_match", kind: "message", oneof: "details", T: () => Response_CreateMatch },
      { no: 5, name: "update_match", kind: "message", oneof: "details", T: () => Response_UpdateMatch },
      { no: 6, name: "delete_match", kind: "message", oneof: "details", T: () => Response_DeleteMatch },
      { no: 7, name: "create_qualifier_event", kind: "message", oneof: "details", T: () => Response_CreateQualifierEvent },
      { no: 8, name: "update_qualifier_event", kind: "message", oneof: "details", T: () => Response_UpdateQualifierEvent },
      { no: 9, name: "delete_qualifier_event", kind: "message", oneof: "details", T: () => Response_DeleteQualifierEvent },
      { no: 21, name: "add_authorized_user", kind: "message", oneof: "details", T: () => Response_AddAuthorizedUser },
      { no: 22, name: "update_authorized_user", kind: "message", oneof: "details", T: () => Response_UpdateAuthorizedUser },
      { no: 23, name: "remove_authorized_user", kind: "message", oneof: "details", T: () => Response_RemoveAuthorizedUser },
      { no: 24, name: "get_authorized_users", kind: "message", oneof: "details", T: () => Response_GetAuthorizedUsers },
      { no: 25, name: "get_discord_info", kind: "message", oneof: "details", T: () => Response_GetDiscordInfo },
      { no: 10, name: "create_tournament", kind: "message", oneof: "details", T: () => Response_CreateTournament },
      { no: 11, name: "update_tournament", kind: "message", oneof: "details", T: () => Response_UpdateTournament },
      { no: 12, name: "delete_tournament", kind: "message", oneof: "details", T: () => Response_DeleteTournament },
      { no: 13, name: "add_server", kind: "message", oneof: "details", T: () => Response_AddServer },
      { no: 14, name: "connect", kind: "message", oneof: "details", T: () => Response_Connect },
      { no: 15, name: "join", kind: "message", oneof: "details", T: () => Response_Join },
      { no: 16, name: "leaderboard_entries", kind: "message", oneof: "details", T: () => Response_LeaderboardEntries },
      { no: 17, name: "load_song", kind: "message", oneof: "details", T: () => Response_LoadSong },
      { no: 18, name: "preload_image_for_stream_sync", kind: "message", oneof: "details", T: () => Response_PreloadImageForStreamSync },
      { no: 19, name: "show_prompt", kind: "message", oneof: "details", T: () => Response_ShowPrompt },
      { no: 20, name: "remaining_attempts", kind: "message", oneof: "details", T: () => Response_RemainingAttempts },
      { no: 26, name: "get_bot_tokens_for_user", kind: "message", oneof: "details", T: () => Response_GetBotTokensForUser },
      { no: 27, name: "generate_bot_token", kind: "message", oneof: "details", T: () => Response_GenerateBotToken },
      { no: 28, name: "revoke_bot_token", kind: "message", oneof: "details", T: () => Response_RevokeBotToken }
    ]);
  }
  create(value) {
    const message = { type: 0, respondingToPacketId: "", details: { oneofKind: void 0 } };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* proto.packets.Response.ResponseType type */
        1:
          message.type = reader.int32();
          break;
        case /* string responding_to_packet_id */
        2:
          message.respondingToPacketId = reader.string();
          break;
        case /* proto.packets.Response.UpdateUser update_user */
        3:
          message.details = {
            oneofKind: "updateUser",
            updateUser: Response_UpdateUser.internalBinaryRead(reader, reader.uint32(), options, message.details.updateUser)
          };
          break;
        case /* proto.packets.Response.CreateMatch create_match */
        4:
          message.details = {
            oneofKind: "createMatch",
            createMatch: Response_CreateMatch.internalBinaryRead(reader, reader.uint32(), options, message.details.createMatch)
          };
          break;
        case /* proto.packets.Response.UpdateMatch update_match */
        5:
          message.details = {
            oneofKind: "updateMatch",
            updateMatch: Response_UpdateMatch.internalBinaryRead(reader, reader.uint32(), options, message.details.updateMatch)
          };
          break;
        case /* proto.packets.Response.DeleteMatch delete_match */
        6:
          message.details = {
            oneofKind: "deleteMatch",
            deleteMatch: Response_DeleteMatch.internalBinaryRead(reader, reader.uint32(), options, message.details.deleteMatch)
          };
          break;
        case /* proto.packets.Response.CreateQualifierEvent create_qualifier_event */
        7:
          message.details = {
            oneofKind: "createQualifierEvent",
            createQualifierEvent: Response_CreateQualifierEvent.internalBinaryRead(reader, reader.uint32(), options, message.details.createQualifierEvent)
          };
          break;
        case /* proto.packets.Response.UpdateQualifierEvent update_qualifier_event */
        8:
          message.details = {
            oneofKind: "updateQualifierEvent",
            updateQualifierEvent: Response_UpdateQualifierEvent.internalBinaryRead(reader, reader.uint32(), options, message.details.updateQualifierEvent)
          };
          break;
        case /* proto.packets.Response.DeleteQualifierEvent delete_qualifier_event */
        9:
          message.details = {
            oneofKind: "deleteQualifierEvent",
            deleteQualifierEvent: Response_DeleteQualifierEvent.internalBinaryRead(reader, reader.uint32(), options, message.details.deleteQualifierEvent)
          };
          break;
        case /* proto.packets.Response.AddAuthorizedUser add_authorized_user */
        21:
          message.details = {
            oneofKind: "addAuthorizedUser",
            addAuthorizedUser: Response_AddAuthorizedUser.internalBinaryRead(reader, reader.uint32(), options, message.details.addAuthorizedUser)
          };
          break;
        case /* proto.packets.Response.UpdateAuthorizedUser update_authorized_user */
        22:
          message.details = {
            oneofKind: "updateAuthorizedUser",
            updateAuthorizedUser: Response_UpdateAuthorizedUser.internalBinaryRead(reader, reader.uint32(), options, message.details.updateAuthorizedUser)
          };
          break;
        case /* proto.packets.Response.RemoveAuthorizedUser remove_authorized_user */
        23:
          message.details = {
            oneofKind: "removeAuthorizedUser",
            removeAuthorizedUser: Response_RemoveAuthorizedUser.internalBinaryRead(reader, reader.uint32(), options, message.details.removeAuthorizedUser)
          };
          break;
        case /* proto.packets.Response.GetAuthorizedUsers get_authorized_users */
        24:
          message.details = {
            oneofKind: "getAuthorizedUsers",
            getAuthorizedUsers: Response_GetAuthorizedUsers.internalBinaryRead(reader, reader.uint32(), options, message.details.getAuthorizedUsers)
          };
          break;
        case /* proto.packets.Response.GetDiscordInfo get_discord_info */
        25:
          message.details = {
            oneofKind: "getDiscordInfo",
            getDiscordInfo: Response_GetDiscordInfo.internalBinaryRead(reader, reader.uint32(), options, message.details.getDiscordInfo)
          };
          break;
        case /* proto.packets.Response.CreateTournament create_tournament */
        10:
          message.details = {
            oneofKind: "createTournament",
            createTournament: Response_CreateTournament.internalBinaryRead(reader, reader.uint32(), options, message.details.createTournament)
          };
          break;
        case /* proto.packets.Response.UpdateTournament update_tournament */
        11:
          message.details = {
            oneofKind: "updateTournament",
            updateTournament: Response_UpdateTournament.internalBinaryRead(reader, reader.uint32(), options, message.details.updateTournament)
          };
          break;
        case /* proto.packets.Response.DeleteTournament delete_tournament */
        12:
          message.details = {
            oneofKind: "deleteTournament",
            deleteTournament: Response_DeleteTournament.internalBinaryRead(reader, reader.uint32(), options, message.details.deleteTournament)
          };
          break;
        case /* proto.packets.Response.AddServer add_server */
        13:
          message.details = {
            oneofKind: "addServer",
            addServer: Response_AddServer.internalBinaryRead(reader, reader.uint32(), options, message.details.addServer)
          };
          break;
        case /* proto.packets.Response.Connect connect */
        14:
          message.details = {
            oneofKind: "connect",
            connect: Response_Connect.internalBinaryRead(reader, reader.uint32(), options, message.details.connect)
          };
          break;
        case /* proto.packets.Response.Join join */
        15:
          message.details = {
            oneofKind: "join",
            join: Response_Join.internalBinaryRead(reader, reader.uint32(), options, message.details.join)
          };
          break;
        case /* proto.packets.Response.LeaderboardEntries leaderboard_entries */
        16:
          message.details = {
            oneofKind: "leaderboardEntries",
            leaderboardEntries: Response_LeaderboardEntries.internalBinaryRead(reader, reader.uint32(), options, message.details.leaderboardEntries)
          };
          break;
        case /* proto.packets.Response.LoadSong load_song */
        17:
          message.details = {
            oneofKind: "loadSong",
            loadSong: Response_LoadSong.internalBinaryRead(reader, reader.uint32(), options, message.details.loadSong)
          };
          break;
        case /* proto.packets.Response.PreloadImageForStreamSync preload_image_for_stream_sync */
        18:
          message.details = {
            oneofKind: "preloadImageForStreamSync",
            preloadImageForStreamSync: Response_PreloadImageForStreamSync.internalBinaryRead(reader, reader.uint32(), options, message.details.preloadImageForStreamSync)
          };
          break;
        case /* proto.packets.Response.ShowPrompt show_prompt */
        19:
          message.details = {
            oneofKind: "showPrompt",
            showPrompt: Response_ShowPrompt.internalBinaryRead(reader, reader.uint32(), options, message.details.showPrompt)
          };
          break;
        case /* proto.packets.Response.RemainingAttempts remaining_attempts */
        20:
          message.details = {
            oneofKind: "remainingAttempts",
            remainingAttempts: Response_RemainingAttempts.internalBinaryRead(reader, reader.uint32(), options, message.details.remainingAttempts)
          };
          break;
        case /* proto.packets.Response.GetBotTokensForUser get_bot_tokens_for_user */
        26:
          message.details = {
            oneofKind: "getBotTokensForUser",
            getBotTokensForUser: Response_GetBotTokensForUser.internalBinaryRead(reader, reader.uint32(), options, message.details.getBotTokensForUser)
          };
          break;
        case /* proto.packets.Response.GenerateBotToken generate_bot_token */
        27:
          message.details = {
            oneofKind: "generateBotToken",
            generateBotToken: Response_GenerateBotToken.internalBinaryRead(reader, reader.uint32(), options, message.details.generateBotToken)
          };
          break;
        case /* proto.packets.Response.RevokeBotToken revoke_bot_token */
        28:
          message.details = {
            oneofKind: "revokeBotToken",
            revokeBotToken: Response_RevokeBotToken.internalBinaryRead(reader, reader.uint32(), options, message.details.revokeBotToken)
          };
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.type !== 0)
      writer.tag(1, WireType.Varint).int32(message.type);
    if (message.respondingToPacketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.respondingToPacketId);
    if (message.details.oneofKind === "updateUser")
      Response_UpdateUser.internalBinaryWrite(message.details.updateUser, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "createMatch")
      Response_CreateMatch.internalBinaryWrite(message.details.createMatch, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "updateMatch")
      Response_UpdateMatch.internalBinaryWrite(message.details.updateMatch, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "deleteMatch")
      Response_DeleteMatch.internalBinaryWrite(message.details.deleteMatch, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "createQualifierEvent")
      Response_CreateQualifierEvent.internalBinaryWrite(message.details.createQualifierEvent, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "updateQualifierEvent")
      Response_UpdateQualifierEvent.internalBinaryWrite(message.details.updateQualifierEvent, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "deleteQualifierEvent")
      Response_DeleteQualifierEvent.internalBinaryWrite(message.details.deleteQualifierEvent, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "addAuthorizedUser")
      Response_AddAuthorizedUser.internalBinaryWrite(message.details.addAuthorizedUser, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "updateAuthorizedUser")
      Response_UpdateAuthorizedUser.internalBinaryWrite(message.details.updateAuthorizedUser, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "removeAuthorizedUser")
      Response_RemoveAuthorizedUser.internalBinaryWrite(message.details.removeAuthorizedUser, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "getAuthorizedUsers")
      Response_GetAuthorizedUsers.internalBinaryWrite(message.details.getAuthorizedUsers, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "getDiscordInfo")
      Response_GetDiscordInfo.internalBinaryWrite(message.details.getDiscordInfo, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "createTournament")
      Response_CreateTournament.internalBinaryWrite(message.details.createTournament, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "updateTournament")
      Response_UpdateTournament.internalBinaryWrite(message.details.updateTournament, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "deleteTournament")
      Response_DeleteTournament.internalBinaryWrite(message.details.deleteTournament, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "addServer")
      Response_AddServer.internalBinaryWrite(message.details.addServer, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "connect")
      Response_Connect.internalBinaryWrite(message.details.connect, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "join")
      Response_Join.internalBinaryWrite(message.details.join, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "leaderboardEntries")
      Response_LeaderboardEntries.internalBinaryWrite(message.details.leaderboardEntries, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "loadSong")
      Response_LoadSong.internalBinaryWrite(message.details.loadSong, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "preloadImageForStreamSync")
      Response_PreloadImageForStreamSync.internalBinaryWrite(message.details.preloadImageForStreamSync, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "showPrompt")
      Response_ShowPrompt.internalBinaryWrite(message.details.showPrompt, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "remainingAttempts")
      Response_RemainingAttempts.internalBinaryWrite(message.details.remainingAttempts, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "getBotTokensForUser")
      Response_GetBotTokensForUser.internalBinaryWrite(message.details.getBotTokensForUser, writer.tag(26, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "generateBotToken")
      Response_GenerateBotToken.internalBinaryWrite(message.details.generateBotToken, writer.tag(27, WireType.LengthDelimited).fork(), options).join();
    if (message.details.oneofKind === "revokeBotToken")
      Response_RevokeBotToken.internalBinaryWrite(message.details.revokeBotToken, writer.tag(28, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response = new Response$Type();
var Response_UpdateUser$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.UpdateUser", [
      {
        no: 1,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "user", kind: "message", T: () => User }
    ]);
  }
  create(value) {
    const message = { message: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message */
        1:
          message.message = reader.string();
          break;
        case /* proto.models.User user */
        2:
          message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.message !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.message);
    if (message.user)
      User.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_UpdateUser = new Response_UpdateUser$Type();
var Response_CreateMatch$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.CreateMatch", [
      {
        no: 1,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "match", kind: "message", T: () => Match }
    ]);
  }
  create(value) {
    const message = { message: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message */
        1:
          message.message = reader.string();
          break;
        case /* proto.models.Match match */
        2:
          message.match = Match.internalBinaryRead(reader, reader.uint32(), options, message.match);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.message !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.message);
    if (message.match)
      Match.internalBinaryWrite(message.match, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_CreateMatch = new Response_CreateMatch$Type();
var Response_UpdateMatch$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.UpdateMatch", [
      {
        no: 1,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "match", kind: "message", T: () => Match }
    ]);
  }
  create(value) {
    const message = { message: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message */
        1:
          message.message = reader.string();
          break;
        case /* proto.models.Match match */
        2:
          message.match = Match.internalBinaryRead(reader, reader.uint32(), options, message.match);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.message !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.message);
    if (message.match)
      Match.internalBinaryWrite(message.match, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_UpdateMatch = new Response_UpdateMatch$Type();
var Response_DeleteMatch$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.DeleteMatch", [
      {
        no: 1,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "match", kind: "message", T: () => Match }
    ]);
  }
  create(value) {
    const message = { message: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message */
        1:
          message.message = reader.string();
          break;
        case /* proto.models.Match match */
        2:
          message.match = Match.internalBinaryRead(reader, reader.uint32(), options, message.match);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.message !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.message);
    if (message.match)
      Match.internalBinaryWrite(message.match, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_DeleteMatch = new Response_DeleteMatch$Type();
var Response_CreateQualifierEvent$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.CreateQualifierEvent", [
      {
        no: 1,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "qualifier", kind: "message", T: () => QualifierEvent }
    ]);
  }
  create(value) {
    const message = { message: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message */
        1:
          message.message = reader.string();
          break;
        case /* proto.models.QualifierEvent qualifier */
        2:
          message.qualifier = QualifierEvent.internalBinaryRead(reader, reader.uint32(), options, message.qualifier);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.message !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.message);
    if (message.qualifier)
      QualifierEvent.internalBinaryWrite(message.qualifier, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_CreateQualifierEvent = new Response_CreateQualifierEvent$Type();
var Response_UpdateQualifierEvent$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.UpdateQualifierEvent", [
      {
        no: 1,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "qualifier", kind: "message", T: () => QualifierEvent }
    ]);
  }
  create(value) {
    const message = { message: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message */
        1:
          message.message = reader.string();
          break;
        case /* proto.models.QualifierEvent qualifier */
        2:
          message.qualifier = QualifierEvent.internalBinaryRead(reader, reader.uint32(), options, message.qualifier);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.message !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.message);
    if (message.qualifier)
      QualifierEvent.internalBinaryWrite(message.qualifier, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_UpdateQualifierEvent = new Response_UpdateQualifierEvent$Type();
var Response_DeleteQualifierEvent$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.DeleteQualifierEvent", [
      {
        no: 1,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "qualifier", kind: "message", T: () => QualifierEvent }
    ]);
  }
  create(value) {
    const message = { message: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message */
        1:
          message.message = reader.string();
          break;
        case /* proto.models.QualifierEvent qualifier */
        2:
          message.qualifier = QualifierEvent.internalBinaryRead(reader, reader.uint32(), options, message.qualifier);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.message !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.message);
    if (message.qualifier)
      QualifierEvent.internalBinaryWrite(message.qualifier, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_DeleteQualifierEvent = new Response_DeleteQualifierEvent$Type();
var Response_AddAuthorizedUser$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.AddAuthorizedUser", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "discord_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "permission_flags", kind: "enum", T: () => ["proto.models.Permissions", Permissions] }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", discordId: "", permissionFlags: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string discord_id */
        2:
          message.discordId = reader.string();
          break;
        case /* proto.models.Permissions permission_flags */
        3:
          message.permissionFlags = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.discordId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.discordId);
    if (message.permissionFlags !== 0)
      writer.tag(3, WireType.Varint).int32(message.permissionFlags);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_AddAuthorizedUser = new Response_AddAuthorizedUser$Type();
var Response_UpdateAuthorizedUser$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.UpdateAuthorizedUser", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "discord_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "permission_flags", kind: "enum", T: () => ["proto.models.Permissions", Permissions] }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", discordId: "", permissionFlags: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string discord_id */
        2:
          message.discordId = reader.string();
          break;
        case /* proto.models.Permissions permission_flags */
        3:
          message.permissionFlags = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.discordId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.discordId);
    if (message.permissionFlags !== 0)
      writer.tag(3, WireType.Varint).int32(message.permissionFlags);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_UpdateAuthorizedUser = new Response_UpdateAuthorizedUser$Type();
var Response_RemoveAuthorizedUser$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.RemoveAuthorizedUser", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "discord_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "permission_flags", kind: "enum", T: () => ["proto.models.Permissions", Permissions] }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", discordId: "", permissionFlags: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string discord_id */
        2:
          message.discordId = reader.string();
          break;
        case /* proto.models.Permissions permission_flags */
        3:
          message.permissionFlags = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.discordId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.discordId);
    if (message.permissionFlags !== 0)
      writer.tag(3, WireType.Varint).int32(message.permissionFlags);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_RemoveAuthorizedUser = new Response_RemoveAuthorizedUser$Type();
var Response_GetAuthorizedUsers$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.GetAuthorizedUsers", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "authorized_users", kind: "message", repeat: 1, T: () => Response_GetAuthorizedUsers_AuthroizedUser }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", authorizedUsers: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* repeated proto.packets.Response.GetAuthorizedUsers.AuthroizedUser authorized_users */
        2:
          message.authorizedUsers.push(Response_GetAuthorizedUsers_AuthroizedUser.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    for (let i2 = 0; i2 < message.authorizedUsers.length; i2++)
      Response_GetAuthorizedUsers_AuthroizedUser.internalBinaryWrite(message.authorizedUsers[i2], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_GetAuthorizedUsers = new Response_GetAuthorizedUsers$Type();
var Response_GetAuthorizedUsers_AuthroizedUser$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.GetAuthorizedUsers.AuthroizedUser", [
      {
        no: 1,
        name: "discord_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "discord_username",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "discord_avatar_url",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "permission", kind: "enum", T: () => ["proto.models.Permissions", Permissions] }
    ]);
  }
  create(value) {
    const message = { discordId: "", discordUsername: "", discordAvatarUrl: "", permission: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string discord_id */
        1:
          message.discordId = reader.string();
          break;
        case /* string discord_username */
        2:
          message.discordUsername = reader.string();
          break;
        case /* string discord_avatar_url */
        3:
          message.discordAvatarUrl = reader.string();
          break;
        case /* proto.models.Permissions permission */
        4:
          message.permission = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.discordId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.discordId);
    if (message.discordUsername !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.discordUsername);
    if (message.discordAvatarUrl !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.discordAvatarUrl);
    if (message.permission !== 0)
      writer.tag(4, WireType.Varint).int32(message.permission);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_GetAuthorizedUsers_AuthroizedUser = new Response_GetAuthorizedUsers_AuthroizedUser$Type();
var Response_GetDiscordInfo$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.GetDiscordInfo", [
      {
        no: 1,
        name: "discord_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "discord_username",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "discord_avatar_url",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { discordId: "", discordUsername: "", discordAvatarUrl: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string discord_id */
        1:
          message.discordId = reader.string();
          break;
        case /* string discord_username */
        2:
          message.discordUsername = reader.string();
          break;
        case /* string discord_avatar_url */
        3:
          message.discordAvatarUrl = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.discordId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.discordId);
    if (message.discordUsername !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.discordUsername);
    if (message.discordAvatarUrl !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.discordAvatarUrl);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_GetDiscordInfo = new Response_GetDiscordInfo$Type();
var Response_CreateTournament$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.CreateTournament", [
      {
        no: 1,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "tournament", kind: "message", T: () => Tournament }
    ]);
  }
  create(value) {
    const message = { message: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message */
        1:
          message.message = reader.string();
          break;
        case /* proto.models.Tournament tournament */
        2:
          message.tournament = Tournament.internalBinaryRead(reader, reader.uint32(), options, message.tournament);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.message !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.message);
    if (message.tournament)
      Tournament.internalBinaryWrite(message.tournament, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_CreateTournament = new Response_CreateTournament$Type();
var Response_UpdateTournament$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.UpdateTournament", [
      {
        no: 1,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "tournament", kind: "message", T: () => Tournament }
    ]);
  }
  create(value) {
    const message = { message: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message */
        1:
          message.message = reader.string();
          break;
        case /* proto.models.Tournament tournament */
        2:
          message.tournament = Tournament.internalBinaryRead(reader, reader.uint32(), options, message.tournament);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.message !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.message);
    if (message.tournament)
      Tournament.internalBinaryWrite(message.tournament, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_UpdateTournament = new Response_UpdateTournament$Type();
var Response_DeleteTournament$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.DeleteTournament", [
      {
        no: 1,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "tournament", kind: "message", T: () => Tournament }
    ]);
  }
  create(value) {
    const message = { message: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message */
        1:
          message.message = reader.string();
          break;
        case /* proto.models.Tournament tournament */
        2:
          message.tournament = Tournament.internalBinaryRead(reader, reader.uint32(), options, message.tournament);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.message !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.message);
    if (message.tournament)
      Tournament.internalBinaryWrite(message.tournament, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_DeleteTournament = new Response_DeleteTournament$Type();
var Response_AddServer$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.AddServer", [
      {
        no: 1,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "server", kind: "message", T: () => CoreServer }
    ]);
  }
  create(value) {
    const message = { message: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message */
        1:
          message.message = reader.string();
          break;
        case /* proto.models.CoreServer server */
        2:
          message.server = CoreServer.internalBinaryRead(reader, reader.uint32(), options, message.server);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.message !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.message);
    if (message.server)
      CoreServer.internalBinaryWrite(message.server, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_AddServer = new Response_AddServer$Type();
var Response_Connect$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.Connect", [
      { no: 1, name: "state", kind: "message", T: () => State },
      {
        no: 2,
        name: "server_version",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "reason", kind: "enum", T: () => ["proto.packets.Response.Connect.ConnectFailReason", Response_Connect_ConnectFailReason] }
    ]);
  }
  create(value) {
    const message = { serverVersion: 0, message: "", reason: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* proto.models.State state */
        1:
          message.state = State.internalBinaryRead(reader, reader.uint32(), options, message.state);
          break;
        case /* int32 server_version */
        2:
          message.serverVersion = reader.int32();
          break;
        case /* string message */
        3:
          message.message = reader.string();
          break;
        case /* proto.packets.Response.Connect.ConnectFailReason reason */
        4:
          message.reason = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.state)
      State.internalBinaryWrite(message.state, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.serverVersion !== 0)
      writer.tag(2, WireType.Varint).int32(message.serverVersion);
    if (message.message !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.message);
    if (message.reason !== 0)
      writer.tag(4, WireType.Varint).int32(message.reason);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_Connect = new Response_Connect$Type();
var Response_Join$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.Join", [
      { no: 1, name: "state", kind: "message", T: () => State },
      {
        no: 2,
        name: "self_guid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 5, name: "reason", kind: "enum", T: () => ["proto.packets.Response.Join.JoinFailReason", Response_Join_JoinFailReason] }
    ]);
  }
  create(value) {
    const message = { selfGuid: "", tournamentId: "", message: "", reason: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* proto.models.State state */
        1:
          message.state = State.internalBinaryRead(reader, reader.uint32(), options, message.state);
          break;
        case /* string self_guid */
        2:
          message.selfGuid = reader.string();
          break;
        case /* string tournament_id */
        3:
          message.tournamentId = reader.string();
          break;
        case /* string message */
        4:
          message.message = reader.string();
          break;
        case /* proto.packets.Response.Join.JoinFailReason reason */
        5:
          message.reason = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.state)
      State.internalBinaryWrite(message.state, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.selfGuid !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.selfGuid);
    if (message.tournamentId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.tournamentId);
    if (message.message !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.message);
    if (message.reason !== 0)
      writer.tag(5, WireType.Varint).int32(message.reason);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_Join = new Response_Join$Type();
var Response_LeaderboardEntries$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.LeaderboardEntries", [
      { no: 1, name: "scores", kind: "message", repeat: 1, T: () => LeaderboardEntry }
    ]);
  }
  create(value) {
    const message = { scores: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated proto.models.LeaderboardEntry scores */
        1:
          message.scores.push(LeaderboardEntry.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i2 = 0; i2 < message.scores.length; i2++)
      LeaderboardEntry.internalBinaryWrite(message.scores[i2], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_LeaderboardEntries = new Response_LeaderboardEntries$Type();
var Response_LoadSong$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.LoadSong", [
      {
        no: 1,
        name: "level_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { levelId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string level_id */
        1:
          message.levelId = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.levelId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.levelId);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_LoadSong = new Response_LoadSong$Type();
var Response_PreloadImageForStreamSync$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.PreloadImageForStreamSync", [
      {
        no: 1,
        name: "file_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { fileId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string file_id */
        1:
          message.fileId = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.fileId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.fileId);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_PreloadImageForStreamSync = new Response_PreloadImageForStreamSync$Type();
var Response_ShowPrompt$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.ShowPrompt", [
      {
        no: 1,
        name: "value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { value: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string value */
        1:
          message.value = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.value !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.value);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_ShowPrompt = new Response_ShowPrompt$Type();
var Response_RemainingAttempts$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.RemainingAttempts", [
      {
        no: 1,
        name: "remaining_attempts",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
  create(value) {
    const message = { remainingAttempts: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 remaining_attempts */
        1:
          message.remainingAttempts = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.remainingAttempts !== 0)
      writer.tag(1, WireType.Varint).int32(message.remainingAttempts);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_RemainingAttempts = new Response_RemainingAttempts$Type();
var Response_GetBotTokensForUser$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.GetBotTokensForUser", [
      { no: 1, name: "bot_users", kind: "message", repeat: 1, T: () => Response_GetBotTokensForUser_BotUser }
    ]);
  }
  create(value) {
    const message = { botUsers: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated proto.packets.Response.GetBotTokensForUser.BotUser bot_users */
        1:
          message.botUsers.push(Response_GetBotTokensForUser_BotUser.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i2 = 0; i2 < message.botUsers.length; i2++)
      Response_GetBotTokensForUser_BotUser.internalBinaryWrite(message.botUsers[i2], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_GetBotTokensForUser = new Response_GetBotTokensForUser$Type();
var Response_GetBotTokensForUser_BotUser$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.GetBotTokensForUser.BotUser", [
      {
        no: 1,
        name: "guid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "username",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "owner_discord_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { guid: "", username: "", ownerDiscordId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string guid */
        1:
          message.guid = reader.string();
          break;
        case /* string username */
        2:
          message.username = reader.string();
          break;
        case /* string owner_discord_id */
        3:
          message.ownerDiscordId = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.guid !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.guid);
    if (message.username !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.username);
    if (message.ownerDiscordId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.ownerDiscordId);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_GetBotTokensForUser_BotUser = new Response_GetBotTokensForUser_BotUser$Type();
var Response_GenerateBotToken$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.GenerateBotToken", [
      {
        no: 1,
        name: "bot_token",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { botToken: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string bot_token */
        1:
          message.botToken = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.botToken !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.botToken);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_GenerateBotToken = new Response_GenerateBotToken$Type();
var Response_RevokeBotToken$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Response.RevokeBotToken", [
      {
        no: 1,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { message: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message */
        1:
          message.message = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.message !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.message);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Response_RevokeBotToken = new Response_RevokeBotToken$Type();

// src/models/requests.ts
init_dirname();
init_buffer2();
init_process2();
var Request$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request", [
      { no: 1, name: "update_user", kind: "message", oneof: "type", T: () => Request_UpdateUser },
      { no: 2, name: "create_match", kind: "message", oneof: "type", T: () => Request_CreateMatch },
      { no: 3, name: "add_user_to_match", kind: "message", oneof: "type", T: () => Request_AddUserToMatch },
      { no: 4, name: "remove_user_from_match", kind: "message", oneof: "type", T: () => Request_RemoveUserFromMatch },
      { no: 5, name: "set_match_leader", kind: "message", oneof: "type", T: () => Request_SetMatchLeader },
      { no: 6, name: "set_match_map", kind: "message", oneof: "type", T: () => Request_SetMatchMap },
      { no: 7, name: "delete_match", kind: "message", oneof: "type", T: () => Request_DeleteMatch },
      { no: 8, name: "create_qualifier_event", kind: "message", oneof: "type", T: () => Request_CreateQualifierEvent },
      { no: 9, name: "set_qualifier_name", kind: "message", oneof: "type", T: () => Request_SetQualifierName },
      { no: 10, name: "set_qualifier_info_channel", kind: "message", oneof: "type", T: () => Request_SetQualifierInfoChannel },
      { no: 11, name: "set_qualifier_image", kind: "message", oneof: "type", T: () => Request_SetQualifierImage },
      { no: 12, name: "set_qualifier_flags", kind: "message", oneof: "type", T: () => Request_SetQualifierFlags },
      { no: 13, name: "set_qualifier_leaderboard_sort", kind: "message", oneof: "type", T: () => Request_SetQualifierLeaderboardSort },
      { no: 14, name: "add_qualifier_maps", kind: "message", oneof: "type", T: () => Request_AddQualifierMaps },
      { no: 15, name: "update_qualifier_map", kind: "message", oneof: "type", T: () => Request_UpdateQualifierMap },
      { no: 16, name: "remove_qualifier_map", kind: "message", oneof: "type", T: () => Request_RemoveQualifierMap },
      { no: 17, name: "delete_qualifier_event", kind: "message", oneof: "type", T: () => Request_DeleteQualifierEvent },
      { no: 48, name: "add_authorized_user", kind: "message", oneof: "type", T: () => Request_AddAuthorizedUser },
      { no: 49, name: "add_authorized_user_permission", kind: "message", oneof: "type", T: () => Request_AddAuthorizedUserPermission },
      { no: 50, name: "remove_authorized_user_permission", kind: "message", oneof: "type", T: () => Request_RemoveAuthorizedUserPermission },
      { no: 51, name: "remove_authorized_user", kind: "message", oneof: "type", T: () => Request_RemoveAuthorizedUser },
      { no: 52, name: "get_authorized_users", kind: "message", oneof: "type", T: () => Request_GetAuthorizedUsers },
      { no: 53, name: "get_discord_info", kind: "message", oneof: "type", T: () => Request_GetDiscordInfo },
      { no: 18, name: "create_tournament", kind: "message", oneof: "type", T: () => Request_CreateTournament },
      { no: 19, name: "set_tournament_name", kind: "message", oneof: "type", T: () => Request_SetTournamentName },
      { no: 20, name: "set_tournament_image", kind: "message", oneof: "type", T: () => Request_SetTournamentImage },
      { no: 21, name: "set_tournament_enable_teams", kind: "message", oneof: "type", T: () => Request_SetTournamentEnableTeams },
      { no: 44, name: "set_tournament_enable_pools", kind: "message", oneof: "type", T: () => Request_SetTournamentEnablePools },
      { no: 45, name: "set_tournament_show_tournament_button", kind: "message", oneof: "type", T: () => Request_SetTournamentShowTournamentButton },
      { no: 46, name: "set_tournament_show_qualifier_button", kind: "message", oneof: "type", T: () => Request_SetTournamentShowQualifierButton },
      { no: 54, name: "set_tournament_allow_unauthorized_view", kind: "message", oneof: "type", T: () => Request_SetTournamentAllowUnauthorizedView },
      { no: 47, name: "set_tournament_score_update_frequency", kind: "message", oneof: "type", T: () => Request_SetTournamentScoreUpdateFrequency },
      { no: 23, name: "set_tournament_banned_mods", kind: "message", oneof: "type", T: () => Request_SetTournamentBannedMods },
      { no: 24, name: "add_tournament_team", kind: "message", oneof: "type", T: () => Request_AddTournamentTeam },
      { no: 25, name: "set_tournament_team_name", kind: "message", oneof: "type", T: () => Request_SetTournamentTeamName },
      { no: 26, name: "set_tournament_team_image", kind: "message", oneof: "type", T: () => Request_SetTournamentTeamImage },
      { no: 27, name: "remove_tournament_team", kind: "message", oneof: "type", T: () => Request_RemoveTournamentTeam },
      { no: 28, name: "add_tournament_pool", kind: "message", oneof: "type", T: () => Request_AddTournamentPool },
      { no: 29, name: "set_tournament_pool_name", kind: "message", oneof: "type", T: () => Request_SetTournamentPoolName },
      { no: 30, name: "add_tournament_pool_maps", kind: "message", oneof: "type", T: () => Request_AddTournamentPoolMaps },
      { no: 31, name: "update_tournament_pool_map", kind: "message", oneof: "type", T: () => Request_UpdateTournamentPoolMap },
      { no: 32, name: "remove_tournament_pool_map", kind: "message", oneof: "type", T: () => Request_RemoveTournamentPoolMap },
      { no: 33, name: "remove_tournament_pool", kind: "message", oneof: "type", T: () => Request_RemoveTournamentPool },
      { no: 34, name: "delete_tournament", kind: "message", oneof: "type", T: () => Request_DeleteTournament },
      { no: 35, name: "add_server", kind: "message", oneof: "type", T: () => Request_AddServer },
      { no: 36, name: "connect", kind: "message", oneof: "type", T: () => Request_Connect },
      { no: 37, name: "join", kind: "message", oneof: "type", T: () => Request_Join },
      { no: 38, name: "qualifier_scores", kind: "message", oneof: "type", T: () => Request_QualifierScores },
      { no: 39, name: "submit_qualifier_score", kind: "message", oneof: "type", T: () => Request_SubmitQualifierScore },
      { no: 40, name: "load_song", kind: "message", oneof: "type", T: () => Request_LoadSong },
      { no: 41, name: "preload_image_for_stream_sync", kind: "message", oneof: "type", T: () => Request_PreloadImageForStreamSync },
      { no: 42, name: "show_prompt", kind: "message", oneof: "type", T: () => Request_ShowPrompt },
      { no: 43, name: "remaining_attempts", kind: "message", oneof: "type", T: () => Request_RemainingAttempts },
      { no: 55, name: "get_bot_tokens_for_user", kind: "message", oneof: "type", T: () => Request_GetBotTokensForUser },
      { no: 56, name: "generate_bot_token", kind: "message", oneof: "type", T: () => Request_GenerateBotToken },
      { no: 57, name: "revoke_bot_token", kind: "message", oneof: "type", T: () => Request_RevokeBotToken }
    ]);
  }
  create(value) {
    const message = { type: { oneofKind: void 0 } };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* proto.packets.Request.UpdateUser update_user */
        1:
          message.type = {
            oneofKind: "updateUser",
            updateUser: Request_UpdateUser.internalBinaryRead(reader, reader.uint32(), options, message.type.updateUser)
          };
          break;
        case /* proto.packets.Request.CreateMatch create_match */
        2:
          message.type = {
            oneofKind: "createMatch",
            createMatch: Request_CreateMatch.internalBinaryRead(reader, reader.uint32(), options, message.type.createMatch)
          };
          break;
        case /* proto.packets.Request.AddUserToMatch add_user_to_match */
        3:
          message.type = {
            oneofKind: "addUserToMatch",
            addUserToMatch: Request_AddUserToMatch.internalBinaryRead(reader, reader.uint32(), options, message.type.addUserToMatch)
          };
          break;
        case /* proto.packets.Request.RemoveUserFromMatch remove_user_from_match */
        4:
          message.type = {
            oneofKind: "removeUserFromMatch",
            removeUserFromMatch: Request_RemoveUserFromMatch.internalBinaryRead(reader, reader.uint32(), options, message.type.removeUserFromMatch)
          };
          break;
        case /* proto.packets.Request.SetMatchLeader set_match_leader */
        5:
          message.type = {
            oneofKind: "setMatchLeader",
            setMatchLeader: Request_SetMatchLeader.internalBinaryRead(reader, reader.uint32(), options, message.type.setMatchLeader)
          };
          break;
        case /* proto.packets.Request.SetMatchMap set_match_map */
        6:
          message.type = {
            oneofKind: "setMatchMap",
            setMatchMap: Request_SetMatchMap.internalBinaryRead(reader, reader.uint32(), options, message.type.setMatchMap)
          };
          break;
        case /* proto.packets.Request.DeleteMatch delete_match */
        7:
          message.type = {
            oneofKind: "deleteMatch",
            deleteMatch: Request_DeleteMatch.internalBinaryRead(reader, reader.uint32(), options, message.type.deleteMatch)
          };
          break;
        case /* proto.packets.Request.CreateQualifierEvent create_qualifier_event */
        8:
          message.type = {
            oneofKind: "createQualifierEvent",
            createQualifierEvent: Request_CreateQualifierEvent.internalBinaryRead(reader, reader.uint32(), options, message.type.createQualifierEvent)
          };
          break;
        case /* proto.packets.Request.SetQualifierName set_qualifier_name */
        9:
          message.type = {
            oneofKind: "setQualifierName",
            setQualifierName: Request_SetQualifierName.internalBinaryRead(reader, reader.uint32(), options, message.type.setQualifierName)
          };
          break;
        case /* proto.packets.Request.SetQualifierInfoChannel set_qualifier_info_channel */
        10:
          message.type = {
            oneofKind: "setQualifierInfoChannel",
            setQualifierInfoChannel: Request_SetQualifierInfoChannel.internalBinaryRead(reader, reader.uint32(), options, message.type.setQualifierInfoChannel)
          };
          break;
        case /* proto.packets.Request.SetQualifierImage set_qualifier_image */
        11:
          message.type = {
            oneofKind: "setQualifierImage",
            setQualifierImage: Request_SetQualifierImage.internalBinaryRead(reader, reader.uint32(), options, message.type.setQualifierImage)
          };
          break;
        case /* proto.packets.Request.SetQualifierFlags set_qualifier_flags */
        12:
          message.type = {
            oneofKind: "setQualifierFlags",
            setQualifierFlags: Request_SetQualifierFlags.internalBinaryRead(reader, reader.uint32(), options, message.type.setQualifierFlags)
          };
          break;
        case /* proto.packets.Request.SetQualifierLeaderboardSort set_qualifier_leaderboard_sort */
        13:
          message.type = {
            oneofKind: "setQualifierLeaderboardSort",
            setQualifierLeaderboardSort: Request_SetQualifierLeaderboardSort.internalBinaryRead(reader, reader.uint32(), options, message.type.setQualifierLeaderboardSort)
          };
          break;
        case /* proto.packets.Request.AddQualifierMaps add_qualifier_maps */
        14:
          message.type = {
            oneofKind: "addQualifierMaps",
            addQualifierMaps: Request_AddQualifierMaps.internalBinaryRead(reader, reader.uint32(), options, message.type.addQualifierMaps)
          };
          break;
        case /* proto.packets.Request.UpdateQualifierMap update_qualifier_map */
        15:
          message.type = {
            oneofKind: "updateQualifierMap",
            updateQualifierMap: Request_UpdateQualifierMap.internalBinaryRead(reader, reader.uint32(), options, message.type.updateQualifierMap)
          };
          break;
        case /* proto.packets.Request.RemoveQualifierMap remove_qualifier_map */
        16:
          message.type = {
            oneofKind: "removeQualifierMap",
            removeQualifierMap: Request_RemoveQualifierMap.internalBinaryRead(reader, reader.uint32(), options, message.type.removeQualifierMap)
          };
          break;
        case /* proto.packets.Request.DeleteQualifierEvent delete_qualifier_event */
        17:
          message.type = {
            oneofKind: "deleteQualifierEvent",
            deleteQualifierEvent: Request_DeleteQualifierEvent.internalBinaryRead(reader, reader.uint32(), options, message.type.deleteQualifierEvent)
          };
          break;
        case /* proto.packets.Request.AddAuthorizedUser add_authorized_user */
        48:
          message.type = {
            oneofKind: "addAuthorizedUser",
            addAuthorizedUser: Request_AddAuthorizedUser.internalBinaryRead(reader, reader.uint32(), options, message.type.addAuthorizedUser)
          };
          break;
        case /* proto.packets.Request.AddAuthorizedUserPermission add_authorized_user_permission */
        49:
          message.type = {
            oneofKind: "addAuthorizedUserPermission",
            addAuthorizedUserPermission: Request_AddAuthorizedUserPermission.internalBinaryRead(reader, reader.uint32(), options, message.type.addAuthorizedUserPermission)
          };
          break;
        case /* proto.packets.Request.RemoveAuthorizedUserPermission remove_authorized_user_permission */
        50:
          message.type = {
            oneofKind: "removeAuthorizedUserPermission",
            removeAuthorizedUserPermission: Request_RemoveAuthorizedUserPermission.internalBinaryRead(reader, reader.uint32(), options, message.type.removeAuthorizedUserPermission)
          };
          break;
        case /* proto.packets.Request.RemoveAuthorizedUser remove_authorized_user */
        51:
          message.type = {
            oneofKind: "removeAuthorizedUser",
            removeAuthorizedUser: Request_RemoveAuthorizedUser.internalBinaryRead(reader, reader.uint32(), options, message.type.removeAuthorizedUser)
          };
          break;
        case /* proto.packets.Request.GetAuthorizedUsers get_authorized_users */
        52:
          message.type = {
            oneofKind: "getAuthorizedUsers",
            getAuthorizedUsers: Request_GetAuthorizedUsers.internalBinaryRead(reader, reader.uint32(), options, message.type.getAuthorizedUsers)
          };
          break;
        case /* proto.packets.Request.GetDiscordInfo get_discord_info */
        53:
          message.type = {
            oneofKind: "getDiscordInfo",
            getDiscordInfo: Request_GetDiscordInfo.internalBinaryRead(reader, reader.uint32(), options, message.type.getDiscordInfo)
          };
          break;
        case /* proto.packets.Request.CreateTournament create_tournament */
        18:
          message.type = {
            oneofKind: "createTournament",
            createTournament: Request_CreateTournament.internalBinaryRead(reader, reader.uint32(), options, message.type.createTournament)
          };
          break;
        case /* proto.packets.Request.SetTournamentName set_tournament_name */
        19:
          message.type = {
            oneofKind: "setTournamentName",
            setTournamentName: Request_SetTournamentName.internalBinaryRead(reader, reader.uint32(), options, message.type.setTournamentName)
          };
          break;
        case /* proto.packets.Request.SetTournamentImage set_tournament_image */
        20:
          message.type = {
            oneofKind: "setTournamentImage",
            setTournamentImage: Request_SetTournamentImage.internalBinaryRead(reader, reader.uint32(), options, message.type.setTournamentImage)
          };
          break;
        case /* proto.packets.Request.SetTournamentEnableTeams set_tournament_enable_teams */
        21:
          message.type = {
            oneofKind: "setTournamentEnableTeams",
            setTournamentEnableTeams: Request_SetTournamentEnableTeams.internalBinaryRead(reader, reader.uint32(), options, message.type.setTournamentEnableTeams)
          };
          break;
        case /* proto.packets.Request.SetTournamentEnablePools set_tournament_enable_pools */
        44:
          message.type = {
            oneofKind: "setTournamentEnablePools",
            setTournamentEnablePools: Request_SetTournamentEnablePools.internalBinaryRead(reader, reader.uint32(), options, message.type.setTournamentEnablePools)
          };
          break;
        case /* proto.packets.Request.SetTournamentShowTournamentButton set_tournament_show_tournament_button */
        45:
          message.type = {
            oneofKind: "setTournamentShowTournamentButton",
            setTournamentShowTournamentButton: Request_SetTournamentShowTournamentButton.internalBinaryRead(reader, reader.uint32(), options, message.type.setTournamentShowTournamentButton)
          };
          break;
        case /* proto.packets.Request.SetTournamentShowQualifierButton set_tournament_show_qualifier_button */
        46:
          message.type = {
            oneofKind: "setTournamentShowQualifierButton",
            setTournamentShowQualifierButton: Request_SetTournamentShowQualifierButton.internalBinaryRead(reader, reader.uint32(), options, message.type.setTournamentShowQualifierButton)
          };
          break;
        case /* proto.packets.Request.SetTournamentAllowUnauthorizedView set_tournament_allow_unauthorized_view */
        54:
          message.type = {
            oneofKind: "setTournamentAllowUnauthorizedView",
            setTournamentAllowUnauthorizedView: Request_SetTournamentAllowUnauthorizedView.internalBinaryRead(reader, reader.uint32(), options, message.type.setTournamentAllowUnauthorizedView)
          };
          break;
        case /* proto.packets.Request.SetTournamentScoreUpdateFrequency set_tournament_score_update_frequency */
        47:
          message.type = {
            oneofKind: "setTournamentScoreUpdateFrequency",
            setTournamentScoreUpdateFrequency: Request_SetTournamentScoreUpdateFrequency.internalBinaryRead(reader, reader.uint32(), options, message.type.setTournamentScoreUpdateFrequency)
          };
          break;
        case /* proto.packets.Request.SetTournamentBannedMods set_tournament_banned_mods */
        23:
          message.type = {
            oneofKind: "setTournamentBannedMods",
            setTournamentBannedMods: Request_SetTournamentBannedMods.internalBinaryRead(reader, reader.uint32(), options, message.type.setTournamentBannedMods)
          };
          break;
        case /* proto.packets.Request.AddTournamentTeam add_tournament_team */
        24:
          message.type = {
            oneofKind: "addTournamentTeam",
            addTournamentTeam: Request_AddTournamentTeam.internalBinaryRead(reader, reader.uint32(), options, message.type.addTournamentTeam)
          };
          break;
        case /* proto.packets.Request.SetTournamentTeamName set_tournament_team_name */
        25:
          message.type = {
            oneofKind: "setTournamentTeamName",
            setTournamentTeamName: Request_SetTournamentTeamName.internalBinaryRead(reader, reader.uint32(), options, message.type.setTournamentTeamName)
          };
          break;
        case /* proto.packets.Request.SetTournamentTeamImage set_tournament_team_image */
        26:
          message.type = {
            oneofKind: "setTournamentTeamImage",
            setTournamentTeamImage: Request_SetTournamentTeamImage.internalBinaryRead(reader, reader.uint32(), options, message.type.setTournamentTeamImage)
          };
          break;
        case /* proto.packets.Request.RemoveTournamentTeam remove_tournament_team */
        27:
          message.type = {
            oneofKind: "removeTournamentTeam",
            removeTournamentTeam: Request_RemoveTournamentTeam.internalBinaryRead(reader, reader.uint32(), options, message.type.removeTournamentTeam)
          };
          break;
        case /* proto.packets.Request.AddTournamentPool add_tournament_pool */
        28:
          message.type = {
            oneofKind: "addTournamentPool",
            addTournamentPool: Request_AddTournamentPool.internalBinaryRead(reader, reader.uint32(), options, message.type.addTournamentPool)
          };
          break;
        case /* proto.packets.Request.SetTournamentPoolName set_tournament_pool_name */
        29:
          message.type = {
            oneofKind: "setTournamentPoolName",
            setTournamentPoolName: Request_SetTournamentPoolName.internalBinaryRead(reader, reader.uint32(), options, message.type.setTournamentPoolName)
          };
          break;
        case /* proto.packets.Request.AddTournamentPoolMaps add_tournament_pool_maps */
        30:
          message.type = {
            oneofKind: "addTournamentPoolMaps",
            addTournamentPoolMaps: Request_AddTournamentPoolMaps.internalBinaryRead(reader, reader.uint32(), options, message.type.addTournamentPoolMaps)
          };
          break;
        case /* proto.packets.Request.UpdateTournamentPoolMap update_tournament_pool_map */
        31:
          message.type = {
            oneofKind: "updateTournamentPoolMap",
            updateTournamentPoolMap: Request_UpdateTournamentPoolMap.internalBinaryRead(reader, reader.uint32(), options, message.type.updateTournamentPoolMap)
          };
          break;
        case /* proto.packets.Request.RemoveTournamentPoolMap remove_tournament_pool_map */
        32:
          message.type = {
            oneofKind: "removeTournamentPoolMap",
            removeTournamentPoolMap: Request_RemoveTournamentPoolMap.internalBinaryRead(reader, reader.uint32(), options, message.type.removeTournamentPoolMap)
          };
          break;
        case /* proto.packets.Request.RemoveTournamentPool remove_tournament_pool */
        33:
          message.type = {
            oneofKind: "removeTournamentPool",
            removeTournamentPool: Request_RemoveTournamentPool.internalBinaryRead(reader, reader.uint32(), options, message.type.removeTournamentPool)
          };
          break;
        case /* proto.packets.Request.DeleteTournament delete_tournament */
        34:
          message.type = {
            oneofKind: "deleteTournament",
            deleteTournament: Request_DeleteTournament.internalBinaryRead(reader, reader.uint32(), options, message.type.deleteTournament)
          };
          break;
        case /* proto.packets.Request.AddServer add_server */
        35:
          message.type = {
            oneofKind: "addServer",
            addServer: Request_AddServer.internalBinaryRead(reader, reader.uint32(), options, message.type.addServer)
          };
          break;
        case /* proto.packets.Request.Connect connect */
        36:
          message.type = {
            oneofKind: "connect",
            connect: Request_Connect.internalBinaryRead(reader, reader.uint32(), options, message.type.connect)
          };
          break;
        case /* proto.packets.Request.Join join */
        37:
          message.type = {
            oneofKind: "join",
            join: Request_Join.internalBinaryRead(reader, reader.uint32(), options, message.type.join)
          };
          break;
        case /* proto.packets.Request.QualifierScores qualifier_scores */
        38:
          message.type = {
            oneofKind: "qualifierScores",
            qualifierScores: Request_QualifierScores.internalBinaryRead(reader, reader.uint32(), options, message.type.qualifierScores)
          };
          break;
        case /* proto.packets.Request.SubmitQualifierScore submit_qualifier_score */
        39:
          message.type = {
            oneofKind: "submitQualifierScore",
            submitQualifierScore: Request_SubmitQualifierScore.internalBinaryRead(reader, reader.uint32(), options, message.type.submitQualifierScore)
          };
          break;
        case /* proto.packets.Request.LoadSong load_song */
        40:
          message.type = {
            oneofKind: "loadSong",
            loadSong: Request_LoadSong.internalBinaryRead(reader, reader.uint32(), options, message.type.loadSong)
          };
          break;
        case /* proto.packets.Request.PreloadImageForStreamSync preload_image_for_stream_sync */
        41:
          message.type = {
            oneofKind: "preloadImageForStreamSync",
            preloadImageForStreamSync: Request_PreloadImageForStreamSync.internalBinaryRead(reader, reader.uint32(), options, message.type.preloadImageForStreamSync)
          };
          break;
        case /* proto.packets.Request.ShowPrompt show_prompt */
        42:
          message.type = {
            oneofKind: "showPrompt",
            showPrompt: Request_ShowPrompt.internalBinaryRead(reader, reader.uint32(), options, message.type.showPrompt)
          };
          break;
        case /* proto.packets.Request.RemainingAttempts remaining_attempts */
        43:
          message.type = {
            oneofKind: "remainingAttempts",
            remainingAttempts: Request_RemainingAttempts.internalBinaryRead(reader, reader.uint32(), options, message.type.remainingAttempts)
          };
          break;
        case /* proto.packets.Request.GetBotTokensForUser get_bot_tokens_for_user */
        55:
          message.type = {
            oneofKind: "getBotTokensForUser",
            getBotTokensForUser: Request_GetBotTokensForUser.internalBinaryRead(reader, reader.uint32(), options, message.type.getBotTokensForUser)
          };
          break;
        case /* proto.packets.Request.GenerateBotToken generate_bot_token */
        56:
          message.type = {
            oneofKind: "generateBotToken",
            generateBotToken: Request_GenerateBotToken.internalBinaryRead(reader, reader.uint32(), options, message.type.generateBotToken)
          };
          break;
        case /* proto.packets.Request.RevokeBotToken revoke_bot_token */
        57:
          message.type = {
            oneofKind: "revokeBotToken",
            revokeBotToken: Request_RevokeBotToken.internalBinaryRead(reader, reader.uint32(), options, message.type.revokeBotToken)
          };
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.type.oneofKind === "updateUser")
      Request_UpdateUser.internalBinaryWrite(message.type.updateUser, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "createMatch")
      Request_CreateMatch.internalBinaryWrite(message.type.createMatch, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "addUserToMatch")
      Request_AddUserToMatch.internalBinaryWrite(message.type.addUserToMatch, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "removeUserFromMatch")
      Request_RemoveUserFromMatch.internalBinaryWrite(message.type.removeUserFromMatch, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "setMatchLeader")
      Request_SetMatchLeader.internalBinaryWrite(message.type.setMatchLeader, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "setMatchMap")
      Request_SetMatchMap.internalBinaryWrite(message.type.setMatchMap, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "deleteMatch")
      Request_DeleteMatch.internalBinaryWrite(message.type.deleteMatch, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "createQualifierEvent")
      Request_CreateQualifierEvent.internalBinaryWrite(message.type.createQualifierEvent, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "setQualifierName")
      Request_SetQualifierName.internalBinaryWrite(message.type.setQualifierName, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "setQualifierInfoChannel")
      Request_SetQualifierInfoChannel.internalBinaryWrite(message.type.setQualifierInfoChannel, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "setQualifierImage")
      Request_SetQualifierImage.internalBinaryWrite(message.type.setQualifierImage, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "setQualifierFlags")
      Request_SetQualifierFlags.internalBinaryWrite(message.type.setQualifierFlags, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "setQualifierLeaderboardSort")
      Request_SetQualifierLeaderboardSort.internalBinaryWrite(message.type.setQualifierLeaderboardSort, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "addQualifierMaps")
      Request_AddQualifierMaps.internalBinaryWrite(message.type.addQualifierMaps, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "updateQualifierMap")
      Request_UpdateQualifierMap.internalBinaryWrite(message.type.updateQualifierMap, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "removeQualifierMap")
      Request_RemoveQualifierMap.internalBinaryWrite(message.type.removeQualifierMap, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "deleteQualifierEvent")
      Request_DeleteQualifierEvent.internalBinaryWrite(message.type.deleteQualifierEvent, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "addAuthorizedUser")
      Request_AddAuthorizedUser.internalBinaryWrite(message.type.addAuthorizedUser, writer.tag(48, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "addAuthorizedUserPermission")
      Request_AddAuthorizedUserPermission.internalBinaryWrite(message.type.addAuthorizedUserPermission, writer.tag(49, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "removeAuthorizedUserPermission")
      Request_RemoveAuthorizedUserPermission.internalBinaryWrite(message.type.removeAuthorizedUserPermission, writer.tag(50, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "removeAuthorizedUser")
      Request_RemoveAuthorizedUser.internalBinaryWrite(message.type.removeAuthorizedUser, writer.tag(51, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "getAuthorizedUsers")
      Request_GetAuthorizedUsers.internalBinaryWrite(message.type.getAuthorizedUsers, writer.tag(52, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "getDiscordInfo")
      Request_GetDiscordInfo.internalBinaryWrite(message.type.getDiscordInfo, writer.tag(53, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "createTournament")
      Request_CreateTournament.internalBinaryWrite(message.type.createTournament, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "setTournamentName")
      Request_SetTournamentName.internalBinaryWrite(message.type.setTournamentName, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "setTournamentImage")
      Request_SetTournamentImage.internalBinaryWrite(message.type.setTournamentImage, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "setTournamentEnableTeams")
      Request_SetTournamentEnableTeams.internalBinaryWrite(message.type.setTournamentEnableTeams, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "setTournamentEnablePools")
      Request_SetTournamentEnablePools.internalBinaryWrite(message.type.setTournamentEnablePools, writer.tag(44, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "setTournamentShowTournamentButton")
      Request_SetTournamentShowTournamentButton.internalBinaryWrite(message.type.setTournamentShowTournamentButton, writer.tag(45, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "setTournamentShowQualifierButton")
      Request_SetTournamentShowQualifierButton.internalBinaryWrite(message.type.setTournamentShowQualifierButton, writer.tag(46, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "setTournamentAllowUnauthorizedView")
      Request_SetTournamentAllowUnauthorizedView.internalBinaryWrite(message.type.setTournamentAllowUnauthorizedView, writer.tag(54, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "setTournamentScoreUpdateFrequency")
      Request_SetTournamentScoreUpdateFrequency.internalBinaryWrite(message.type.setTournamentScoreUpdateFrequency, writer.tag(47, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "setTournamentBannedMods")
      Request_SetTournamentBannedMods.internalBinaryWrite(message.type.setTournamentBannedMods, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "addTournamentTeam")
      Request_AddTournamentTeam.internalBinaryWrite(message.type.addTournamentTeam, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "setTournamentTeamName")
      Request_SetTournamentTeamName.internalBinaryWrite(message.type.setTournamentTeamName, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "setTournamentTeamImage")
      Request_SetTournamentTeamImage.internalBinaryWrite(message.type.setTournamentTeamImage, writer.tag(26, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "removeTournamentTeam")
      Request_RemoveTournamentTeam.internalBinaryWrite(message.type.removeTournamentTeam, writer.tag(27, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "addTournamentPool")
      Request_AddTournamentPool.internalBinaryWrite(message.type.addTournamentPool, writer.tag(28, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "setTournamentPoolName")
      Request_SetTournamentPoolName.internalBinaryWrite(message.type.setTournamentPoolName, writer.tag(29, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "addTournamentPoolMaps")
      Request_AddTournamentPoolMaps.internalBinaryWrite(message.type.addTournamentPoolMaps, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "updateTournamentPoolMap")
      Request_UpdateTournamentPoolMap.internalBinaryWrite(message.type.updateTournamentPoolMap, writer.tag(31, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "removeTournamentPoolMap")
      Request_RemoveTournamentPoolMap.internalBinaryWrite(message.type.removeTournamentPoolMap, writer.tag(32, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "removeTournamentPool")
      Request_RemoveTournamentPool.internalBinaryWrite(message.type.removeTournamentPool, writer.tag(33, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "deleteTournament")
      Request_DeleteTournament.internalBinaryWrite(message.type.deleteTournament, writer.tag(34, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "addServer")
      Request_AddServer.internalBinaryWrite(message.type.addServer, writer.tag(35, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "connect")
      Request_Connect.internalBinaryWrite(message.type.connect, writer.tag(36, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "join")
      Request_Join.internalBinaryWrite(message.type.join, writer.tag(37, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "qualifierScores")
      Request_QualifierScores.internalBinaryWrite(message.type.qualifierScores, writer.tag(38, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "submitQualifierScore")
      Request_SubmitQualifierScore.internalBinaryWrite(message.type.submitQualifierScore, writer.tag(39, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "loadSong")
      Request_LoadSong.internalBinaryWrite(message.type.loadSong, writer.tag(40, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "preloadImageForStreamSync")
      Request_PreloadImageForStreamSync.internalBinaryWrite(message.type.preloadImageForStreamSync, writer.tag(41, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "showPrompt")
      Request_ShowPrompt.internalBinaryWrite(message.type.showPrompt, writer.tag(42, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "remainingAttempts")
      Request_RemainingAttempts.internalBinaryWrite(message.type.remainingAttempts, writer.tag(43, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "getBotTokensForUser")
      Request_GetBotTokensForUser.internalBinaryWrite(message.type.getBotTokensForUser, writer.tag(55, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "generateBotToken")
      Request_GenerateBotToken.internalBinaryWrite(message.type.generateBotToken, writer.tag(56, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "revokeBotToken")
      Request_RevokeBotToken.internalBinaryWrite(message.type.revokeBotToken, writer.tag(57, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request = new Request$Type();
var Request_UpdateUser$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.UpdateUser", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "user", kind: "message", T: () => User }
    ]);
  }
  create(value) {
    const message = { tournamentId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* proto.models.User user */
        2:
          message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.user)
      User.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_UpdateUser = new Request_UpdateUser$Type();
var Request_CreateMatch$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.CreateMatch", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "match", kind: "message", T: () => Match }
    ]);
  }
  create(value) {
    const message = { tournamentId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* proto.models.Match match */
        2:
          message.match = Match.internalBinaryRead(reader, reader.uint32(), options, message.match);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.match)
      Match.internalBinaryWrite(message.match, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_CreateMatch = new Request_CreateMatch$Type();
var Request_AddUserToMatch$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.AddUserToMatch", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "match_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", matchId: "", userId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string match_id */
        2:
          message.matchId = reader.string();
          break;
        case /* string user_id */
        3:
          message.userId = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.matchId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.matchId);
    if (message.userId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.userId);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_AddUserToMatch = new Request_AddUserToMatch$Type();
var Request_RemoveUserFromMatch$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.RemoveUserFromMatch", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "match_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", matchId: "", userId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string match_id */
        2:
          message.matchId = reader.string();
          break;
        case /* string user_id */
        3:
          message.userId = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.matchId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.matchId);
    if (message.userId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.userId);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_RemoveUserFromMatch = new Request_RemoveUserFromMatch$Type();
var Request_SetMatchLeader$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.SetMatchLeader", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "match_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", matchId: "", userId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string match_id */
        2:
          message.matchId = reader.string();
          break;
        case /* string user_id */
        3:
          message.userId = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.matchId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.matchId);
    if (message.userId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.userId);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_SetMatchLeader = new Request_SetMatchLeader$Type();
var Request_SetMatchMap$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.SetMatchMap", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "match_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "map", kind: "message", T: () => Map2 }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", matchId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string match_id */
        2:
          message.matchId = reader.string();
          break;
        case /* proto.models.Map map */
        3:
          message.map = Map2.internalBinaryRead(reader, reader.uint32(), options, message.map);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.matchId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.matchId);
    if (message.map)
      Map2.internalBinaryWrite(message.map, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_SetMatchMap = new Request_SetMatchMap$Type();
var Request_DeleteMatch$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.DeleteMatch", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "match_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", matchId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string match_id */
        2:
          message.matchId = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.matchId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.matchId);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_DeleteMatch = new Request_DeleteMatch$Type();
var Request_CreateQualifierEvent$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.CreateQualifierEvent", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "event", kind: "message", T: () => QualifierEvent }
    ]);
  }
  create(value) {
    const message = { tournamentId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* proto.models.QualifierEvent event */
        2:
          message.event = QualifierEvent.internalBinaryRead(reader, reader.uint32(), options, message.event);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.event)
      QualifierEvent.internalBinaryWrite(message.event, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_CreateQualifierEvent = new Request_CreateQualifierEvent$Type();
var Request_SetQualifierName$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.SetQualifierName", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "qualifier_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "qualifier_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", qualifierId: "", qualifierName: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string qualifier_id */
        2:
          message.qualifierId = reader.string();
          break;
        case /* string qualifier_name */
        3:
          message.qualifierName = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.qualifierId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.qualifierId);
    if (message.qualifierName !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.qualifierName);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_SetQualifierName = new Request_SetQualifierName$Type();
var Request_SetQualifierImage$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.SetQualifierImage", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "qualifier_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "qualifier_image",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", qualifierId: "", qualifierImage: new Uint8Array(0) };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string qualifier_id */
        2:
          message.qualifierId = reader.string();
          break;
        case /* bytes qualifier_image */
        3:
          message.qualifierImage = reader.bytes();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.qualifierId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.qualifierId);
    if (message.qualifierImage.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.qualifierImage);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_SetQualifierImage = new Request_SetQualifierImage$Type();
var Request_SetQualifierInfoChannel$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.SetQualifierInfoChannel", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "qualifier_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "info_channel", kind: "message", T: () => Channel }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", qualifierId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string qualifier_id */
        2:
          message.qualifierId = reader.string();
          break;
        case /* proto.discord.Channel info_channel */
        3:
          message.infoChannel = Channel.internalBinaryRead(reader, reader.uint32(), options, message.infoChannel);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.qualifierId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.qualifierId);
    if (message.infoChannel)
      Channel.internalBinaryWrite(message.infoChannel, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_SetQualifierInfoChannel = new Request_SetQualifierInfoChannel$Type();
var Request_SetQualifierFlags$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.SetQualifierFlags", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "qualifier_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "qualifier_flags", kind: "enum", T: () => ["proto.models.QualifierEvent.EventSettings", QualifierEvent_EventSettings] }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", qualifierId: "", qualifierFlags: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string qualifier_id */
        2:
          message.qualifierId = reader.string();
          break;
        case /* proto.models.QualifierEvent.EventSettings qualifier_flags */
        3:
          message.qualifierFlags = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.qualifierId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.qualifierId);
    if (message.qualifierFlags !== 0)
      writer.tag(3, WireType.Varint).int32(message.qualifierFlags);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_SetQualifierFlags = new Request_SetQualifierFlags$Type();
var Request_SetQualifierLeaderboardSort$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.SetQualifierLeaderboardSort", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "qualifier_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "qualifier_leaderboard_sort", kind: "enum", T: () => ["proto.models.QualifierEvent.LeaderboardSort", QualifierEvent_LeaderboardSort] }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", qualifierId: "", qualifierLeaderboardSort: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string qualifier_id */
        2:
          message.qualifierId = reader.string();
          break;
        case /* proto.models.QualifierEvent.LeaderboardSort qualifier_leaderboard_sort */
        3:
          message.qualifierLeaderboardSort = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.qualifierId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.qualifierId);
    if (message.qualifierLeaderboardSort !== 0)
      writer.tag(3, WireType.Varint).int32(message.qualifierLeaderboardSort);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_SetQualifierLeaderboardSort = new Request_SetQualifierLeaderboardSort$Type();
var Request_AddQualifierMaps$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.AddQualifierMaps", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "qualifier_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "maps", kind: "message", repeat: 1, T: () => Map2 }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", qualifierId: "", maps: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string qualifier_id */
        2:
          message.qualifierId = reader.string();
          break;
        case /* repeated proto.models.Map maps */
        3:
          message.maps.push(Map2.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.qualifierId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.qualifierId);
    for (let i2 = 0; i2 < message.maps.length; i2++)
      Map2.internalBinaryWrite(message.maps[i2], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_AddQualifierMaps = new Request_AddQualifierMaps$Type();
var Request_UpdateQualifierMap$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.UpdateQualifierMap", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "qualifier_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "map", kind: "message", T: () => Map2 }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", qualifierId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string qualifier_id */
        2:
          message.qualifierId = reader.string();
          break;
        case /* proto.models.Map map */
        3:
          message.map = Map2.internalBinaryRead(reader, reader.uint32(), options, message.map);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.qualifierId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.qualifierId);
    if (message.map)
      Map2.internalBinaryWrite(message.map, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_UpdateQualifierMap = new Request_UpdateQualifierMap$Type();
var Request_RemoveQualifierMap$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.RemoveQualifierMap", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "qualifier_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "map_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", qualifierId: "", mapId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string qualifier_id */
        2:
          message.qualifierId = reader.string();
          break;
        case /* string map_id */
        3:
          message.mapId = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.qualifierId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.qualifierId);
    if (message.mapId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.mapId);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_RemoveQualifierMap = new Request_RemoveQualifierMap$Type();
var Request_DeleteQualifierEvent$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.DeleteQualifierEvent", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "qualifier_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", qualifierId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string qualifier_id */
        2:
          message.qualifierId = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.qualifierId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.qualifierId);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_DeleteQualifierEvent = new Request_DeleteQualifierEvent$Type();
var Request_AddAuthorizedUser$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.AddAuthorizedUser", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "discord_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "permission_flags", kind: "enum", T: () => ["proto.models.Permissions", Permissions] }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", discordId: "", permissionFlags: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string discord_id */
        2:
          message.discordId = reader.string();
          break;
        case /* proto.models.Permissions permission_flags */
        3:
          message.permissionFlags = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.discordId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.discordId);
    if (message.permissionFlags !== 0)
      writer.tag(3, WireType.Varint).int32(message.permissionFlags);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_AddAuthorizedUser = new Request_AddAuthorizedUser$Type();
var Request_AddAuthorizedUserPermission$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.AddAuthorizedUserPermission", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "discord_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "permission", kind: "enum", T: () => ["proto.models.Permissions", Permissions] }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", discordId: "", permission: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string discord_id */
        2:
          message.discordId = reader.string();
          break;
        case /* proto.models.Permissions permission */
        3:
          message.permission = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.discordId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.discordId);
    if (message.permission !== 0)
      writer.tag(3, WireType.Varint).int32(message.permission);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_AddAuthorizedUserPermission = new Request_AddAuthorizedUserPermission$Type();
var Request_RemoveAuthorizedUserPermission$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.RemoveAuthorizedUserPermission", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "discord_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "permission", kind: "enum", T: () => ["proto.models.Permissions", Permissions] }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", discordId: "", permission: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string discord_id */
        2:
          message.discordId = reader.string();
          break;
        case /* proto.models.Permissions permission */
        3:
          message.permission = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.discordId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.discordId);
    if (message.permission !== 0)
      writer.tag(3, WireType.Varint).int32(message.permission);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_RemoveAuthorizedUserPermission = new Request_RemoveAuthorizedUserPermission$Type();
var Request_RemoveAuthorizedUser$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.RemoveAuthorizedUser", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "discord_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", discordId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string discord_id */
        2:
          message.discordId = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.discordId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.discordId);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_RemoveAuthorizedUser = new Request_RemoveAuthorizedUser$Type();
var Request_GetAuthorizedUsers$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.GetAuthorizedUsers", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_GetAuthorizedUsers = new Request_GetAuthorizedUsers$Type();
var Request_GetDiscordInfo$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.GetDiscordInfo", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "discord_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", discordId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string discord_id */
        2:
          message.discordId = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.discordId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.discordId);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_GetDiscordInfo = new Request_GetDiscordInfo$Type();
var Request_CreateTournament$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.CreateTournament", [
      { no: 1, name: "tournament", kind: "message", T: () => Tournament }
    ]);
  }
  create(value) {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* proto.models.Tournament tournament */
        1:
          message.tournament = Tournament.internalBinaryRead(reader, reader.uint32(), options, message.tournament);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournament)
      Tournament.internalBinaryWrite(message.tournament, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_CreateTournament = new Request_CreateTournament$Type();
var Request_SetTournamentName$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.SetTournamentName", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "tournament_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", tournamentName: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string tournament_name */
        2:
          message.tournamentName = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.tournamentName !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.tournamentName);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_SetTournamentName = new Request_SetTournamentName$Type();
var Request_SetTournamentImage$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.SetTournamentImage", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "tournament_image",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", tournamentImage: new Uint8Array(0) };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* bytes tournament_image */
        2:
          message.tournamentImage = reader.bytes();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.tournamentImage.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.tournamentImage);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_SetTournamentImage = new Request_SetTournamentImage$Type();
var Request_SetTournamentEnableTeams$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.SetTournamentEnableTeams", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "enable_teams",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", enableTeams: false };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* bool enable_teams */
        2:
          message.enableTeams = reader.bool();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.enableTeams !== false)
      writer.tag(2, WireType.Varint).bool(message.enableTeams);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_SetTournamentEnableTeams = new Request_SetTournamentEnableTeams$Type();
var Request_SetTournamentEnablePools$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.SetTournamentEnablePools", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "enable_pools",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", enablePools: false };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* bool enable_pools */
        2:
          message.enablePools = reader.bool();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.enablePools !== false)
      writer.tag(2, WireType.Varint).bool(message.enablePools);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_SetTournamentEnablePools = new Request_SetTournamentEnablePools$Type();
var Request_SetTournamentShowTournamentButton$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.SetTournamentShowTournamentButton", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "show_tournament_button",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", showTournamentButton: false };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* bool show_tournament_button */
        2:
          message.showTournamentButton = reader.bool();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.showTournamentButton !== false)
      writer.tag(2, WireType.Varint).bool(message.showTournamentButton);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_SetTournamentShowTournamentButton = new Request_SetTournamentShowTournamentButton$Type();
var Request_SetTournamentShowQualifierButton$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.SetTournamentShowQualifierButton", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "show_qualifier_button",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", showQualifierButton: false };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* bool show_qualifier_button */
        2:
          message.showQualifierButton = reader.bool();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.showQualifierButton !== false)
      writer.tag(2, WireType.Varint).bool(message.showQualifierButton);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_SetTournamentShowQualifierButton = new Request_SetTournamentShowQualifierButton$Type();
var Request_SetTournamentAllowUnauthorizedView$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.SetTournamentAllowUnauthorizedView", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "allow_unauthorized_view",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", allowUnauthorizedView: false };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* bool allow_unauthorized_view */
        2:
          message.allowUnauthorizedView = reader.bool();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.allowUnauthorizedView !== false)
      writer.tag(2, WireType.Varint).bool(message.allowUnauthorizedView);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_SetTournamentAllowUnauthorizedView = new Request_SetTournamentAllowUnauthorizedView$Type();
var Request_SetTournamentScoreUpdateFrequency$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.SetTournamentScoreUpdateFrequency", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "score_update_frequency",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", scoreUpdateFrequency: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* int32 score_update_frequency */
        2:
          message.scoreUpdateFrequency = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.scoreUpdateFrequency !== 0)
      writer.tag(2, WireType.Varint).int32(message.scoreUpdateFrequency);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_SetTournamentScoreUpdateFrequency = new Request_SetTournamentScoreUpdateFrequency$Type();
var Request_SetTournamentBannedMods$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.SetTournamentBannedMods", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "banned_mods",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", bannedMods: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* repeated string banned_mods */
        2:
          message.bannedMods.push(reader.string());
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    for (let i2 = 0; i2 < message.bannedMods.length; i2++)
      writer.tag(2, WireType.LengthDelimited).string(message.bannedMods[i2]);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_SetTournamentBannedMods = new Request_SetTournamentBannedMods$Type();
var Request_AddTournamentTeam$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.AddTournamentTeam", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "team", kind: "message", T: () => Tournament_TournamentSettings_Team }
    ]);
  }
  create(value) {
    const message = { tournamentId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* proto.models.Tournament.TournamentSettings.Team team */
        2:
          message.team = Tournament_TournamentSettings_Team.internalBinaryRead(reader, reader.uint32(), options, message.team);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.team)
      Tournament_TournamentSettings_Team.internalBinaryWrite(message.team, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_AddTournamentTeam = new Request_AddTournamentTeam$Type();
var Request_SetTournamentTeamName$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.SetTournamentTeamName", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "team_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "team_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", teamId: "", teamName: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string team_id */
        2:
          message.teamId = reader.string();
          break;
        case /* string team_name */
        3:
          message.teamName = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.teamId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.teamId);
    if (message.teamName !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.teamName);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_SetTournamentTeamName = new Request_SetTournamentTeamName$Type();
var Request_SetTournamentTeamImage$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.SetTournamentTeamImage", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "team_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "team_image",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", teamId: "", teamImage: new Uint8Array(0) };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string team_id */
        2:
          message.teamId = reader.string();
          break;
        case /* bytes team_image */
        3:
          message.teamImage = reader.bytes();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.teamId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.teamId);
    if (message.teamImage.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.teamImage);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_SetTournamentTeamImage = new Request_SetTournamentTeamImage$Type();
var Request_RemoveTournamentTeam$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.RemoveTournamentTeam", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "team_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", teamId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string team_id */
        2:
          message.teamId = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.teamId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.teamId);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_RemoveTournamentTeam = new Request_RemoveTournamentTeam$Type();
var Request_AddTournamentPool$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.AddTournamentPool", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "pool", kind: "message", T: () => Tournament_TournamentSettings_Pool }
    ]);
  }
  create(value) {
    const message = { tournamentId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* proto.models.Tournament.TournamentSettings.Pool pool */
        2:
          message.pool = Tournament_TournamentSettings_Pool.internalBinaryRead(reader, reader.uint32(), options, message.pool);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.pool)
      Tournament_TournamentSettings_Pool.internalBinaryWrite(message.pool, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_AddTournamentPool = new Request_AddTournamentPool$Type();
var Request_SetTournamentPoolName$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.SetTournamentPoolName", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "pool_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "pool_name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", poolId: "", poolName: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string pool_id */
        2:
          message.poolId = reader.string();
          break;
        case /* string pool_name */
        3:
          message.poolName = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.poolId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.poolId);
    if (message.poolName !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.poolName);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_SetTournamentPoolName = new Request_SetTournamentPoolName$Type();
var Request_AddTournamentPoolMaps$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.AddTournamentPoolMaps", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "pool_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "maps", kind: "message", repeat: 1, T: () => Map2 }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", poolId: "", maps: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string pool_id */
        2:
          message.poolId = reader.string();
          break;
        case /* repeated proto.models.Map maps */
        3:
          message.maps.push(Map2.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.poolId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.poolId);
    for (let i2 = 0; i2 < message.maps.length; i2++)
      Map2.internalBinaryWrite(message.maps[i2], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_AddTournamentPoolMaps = new Request_AddTournamentPoolMaps$Type();
var Request_UpdateTournamentPoolMap$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.UpdateTournamentPoolMap", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "pool_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 3, name: "map", kind: "message", T: () => Map2 }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", poolId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string pool_id */
        2:
          message.poolId = reader.string();
          break;
        case /* proto.models.Map map */
        3:
          message.map = Map2.internalBinaryRead(reader, reader.uint32(), options, message.map);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.poolId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.poolId);
    if (message.map)
      Map2.internalBinaryWrite(message.map, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_UpdateTournamentPoolMap = new Request_UpdateTournamentPoolMap$Type();
var Request_RemoveTournamentPoolMap$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.RemoveTournamentPoolMap", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "pool_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "map_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", poolId: "", mapId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string pool_id */
        2:
          message.poolId = reader.string();
          break;
        case /* string map_id */
        3:
          message.mapId = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.poolId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.poolId);
    if (message.mapId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.mapId);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_RemoveTournamentPoolMap = new Request_RemoveTournamentPoolMap$Type();
var Request_RemoveTournamentPool$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.RemoveTournamentPool", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "pool_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", poolId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string pool_id */
        2:
          message.poolId = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.poolId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.poolId);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_RemoveTournamentPool = new Request_RemoveTournamentPool$Type();
var Request_DeleteTournament$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.DeleteTournament", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_DeleteTournament = new Request_DeleteTournament$Type();
var Request_AddServer$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.AddServer", [
      { no: 1, name: "server", kind: "message", T: () => CoreServer },
      {
        no: 2,
        name: "auth_token",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { authToken: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* proto.models.CoreServer server */
        1:
          message.server = CoreServer.internalBinaryRead(reader, reader.uint32(), options, message.server);
          break;
        case /* string auth_token */
        2:
          message.authToken = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.server)
      CoreServer.internalBinaryWrite(message.server, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.authToken !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.authToken);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_AddServer = new Request_AddServer$Type();
var Request_Connect$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.Connect", [
      {
        no: 1,
        name: "client_version",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: "ui_version",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
  create(value) {
    const message = { clientVersion: 0, uiVersion: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 client_version */
        1:
          message.clientVersion = reader.int32();
          break;
        case /* int32 ui_version */
        2:
          message.uiVersion = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.clientVersion !== 0)
      writer.tag(1, WireType.Varint).int32(message.clientVersion);
    if (message.uiVersion !== 0)
      writer.tag(2, WireType.Varint).int32(message.uiVersion);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_Connect = new Request_Connect$Type();
var Request_Join$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.Join", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "password",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", password: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string password */
        2:
          message.password = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.password !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.password);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_Join = new Request_Join$Type();
var Request_QualifierScores$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.QualifierScores", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "event_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "map_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", eventId: "", mapId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string event_id */
        2:
          message.eventId = reader.string();
          break;
        case /* string map_id */
        3:
          message.mapId = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.eventId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.eventId);
    if (message.mapId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.mapId);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_QualifierScores = new Request_QualifierScores$Type();
var Request_SubmitQualifierScore$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.SubmitQualifierScore", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "qualifier_score", kind: "message", T: () => LeaderboardEntry },
      { no: 3, name: "map", kind: "message", T: () => GameplayParameters }
    ]);
  }
  create(value) {
    const message = { tournamentId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* proto.models.LeaderboardEntry qualifier_score */
        2:
          message.qualifierScore = LeaderboardEntry.internalBinaryRead(reader, reader.uint32(), options, message.qualifierScore);
          break;
        case /* proto.models.GameplayParameters map */
        3:
          message.map = GameplayParameters.internalBinaryRead(reader, reader.uint32(), options, message.map);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.qualifierScore)
      LeaderboardEntry.internalBinaryWrite(message.qualifierScore, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.map)
      GameplayParameters.internalBinaryWrite(message.map, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_SubmitQualifierScore = new Request_SubmitQualifierScore$Type();
var Request_LoadSong$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.LoadSong", [
      {
        no: 1,
        name: "level_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "custom_host_url",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { levelId: "", customHostUrl: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string level_id */
        1:
          message.levelId = reader.string();
          break;
        case /* string custom_host_url */
        2:
          message.customHostUrl = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.levelId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.levelId);
    if (message.customHostUrl !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.customHostUrl);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_LoadSong = new Request_LoadSong$Type();
var Request_PreloadImageForStreamSync$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.PreloadImageForStreamSync", [
      {
        no: 1,
        name: "file_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "compressed",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "data",
        kind: "scalar",
        T: 12
        /*ScalarType.BYTES*/
      }
    ]);
  }
  create(value) {
    const message = { fileId: "", compressed: false, data: new Uint8Array(0) };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string file_id */
        1:
          message.fileId = reader.string();
          break;
        case /* bool compressed */
        2:
          message.compressed = reader.bool();
          break;
        case /* bytes data */
        3:
          message.data = reader.bytes();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.fileId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.fileId);
    if (message.compressed !== false)
      writer.tag(2, WireType.Varint).bool(message.compressed);
    if (message.data.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.data);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_PreloadImageForStreamSync = new Request_PreloadImageForStreamSync$Type();
var Request_ShowPrompt$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.ShowPrompt", [
      {
        no: 1,
        name: "prompt_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "message_title",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "message_text",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "timeout",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 5,
        name: "show_timer",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 6,
        name: "can_close",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 7, name: "options", kind: "message", repeat: 1, T: () => Request_ShowPrompt_PromptOption }
    ]);
  }
  create(value) {
    const message = { promptId: "", messageTitle: "", messageText: "", timeout: 0, showTimer: false, canClose: false, options: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string prompt_id */
        1:
          message.promptId = reader.string();
          break;
        case /* string message_title */
        2:
          message.messageTitle = reader.string();
          break;
        case /* string message_text */
        3:
          message.messageText = reader.string();
          break;
        case /* int32 timeout */
        4:
          message.timeout = reader.int32();
          break;
        case /* bool show_timer */
        5:
          message.showTimer = reader.bool();
          break;
        case /* bool can_close */
        6:
          message.canClose = reader.bool();
          break;
        case /* repeated proto.packets.Request.ShowPrompt.PromptOption options */
        7:
          message.options.push(Request_ShowPrompt_PromptOption.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.promptId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.promptId);
    if (message.messageTitle !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.messageTitle);
    if (message.messageText !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.messageText);
    if (message.timeout !== 0)
      writer.tag(4, WireType.Varint).int32(message.timeout);
    if (message.showTimer !== false)
      writer.tag(5, WireType.Varint).bool(message.showTimer);
    if (message.canClose !== false)
      writer.tag(6, WireType.Varint).bool(message.canClose);
    for (let i2 = 0; i2 < message.options.length; i2++)
      Request_ShowPrompt_PromptOption.internalBinaryWrite(message.options[i2], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_ShowPrompt = new Request_ShowPrompt$Type();
var Request_ShowPrompt_PromptOption$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.ShowPrompt.PromptOption", [
      {
        no: 1,
        name: "label",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "value",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { label: "", value: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string label */
        1:
          message.label = reader.string();
          break;
        case /* string value */
        2:
          message.value = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.label !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.label);
    if (message.value !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.value);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_ShowPrompt_PromptOption = new Request_ShowPrompt_PromptOption$Type();
var Request_RemainingAttempts$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.RemainingAttempts", [
      {
        no: 1,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "event_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "map_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { tournamentId: "", eventId: "", mapId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string tournament_id */
        1:
          message.tournamentId = reader.string();
          break;
        case /* string event_id */
        2:
          message.eventId = reader.string();
          break;
        case /* string map_id */
        3:
          message.mapId = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.tournamentId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.tournamentId);
    if (message.eventId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.eventId);
    if (message.mapId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.mapId);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_RemainingAttempts = new Request_RemainingAttempts$Type();
var Request_GetBotTokensForUser$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.GetBotTokensForUser", [
      {
        no: 1,
        name: "owner_discord_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { ownerDiscordId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string owner_discord_id */
        1:
          message.ownerDiscordId = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.ownerDiscordId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.ownerDiscordId);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_GetBotTokensForUser = new Request_GetBotTokensForUser$Type();
var Request_GenerateBotToken$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.GenerateBotToken", [
      {
        no: 1,
        name: "username",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { username: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string username */
        1:
          message.username = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.username !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.username);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_GenerateBotToken = new Request_GenerateBotToken$Type();
var Request_RevokeBotToken$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Request.RevokeBotToken", [
      {
        no: 1,
        name: "bot_token_guid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { botTokenGuid: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string bot_token_guid */
        1:
          message.botTokenGuid = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.botTokenGuid !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.botTokenGuid);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Request_RevokeBotToken = new Request_RevokeBotToken$Type();

// src/models/pushes.ts
init_dirname();
init_buffer2();
init_process2();
var Push_SongFinished_CompletionType = /* @__PURE__ */ ((Push_SongFinished_CompletionType2) => {
  Push_SongFinished_CompletionType2[Push_SongFinished_CompletionType2["Passed"] = 0] = "Passed";
  Push_SongFinished_CompletionType2[Push_SongFinished_CompletionType2["Failed"] = 1] = "Failed";
  Push_SongFinished_CompletionType2[Push_SongFinished_CompletionType2["Quit"] = 2] = "Quit";
  return Push_SongFinished_CompletionType2;
})(Push_SongFinished_CompletionType || {});
var Push$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Push", [
      { no: 1, name: "realtime_score", kind: "message", oneof: "data", T: () => RealtimeScore },
      { no: 2, name: "song_finished", kind: "message", oneof: "data", T: () => Push_SongFinished }
    ]);
  }
  create(value) {
    const message = { data: { oneofKind: void 0 } };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* proto.models.RealtimeScore realtime_score */
        1:
          message.data = {
            oneofKind: "realtimeScore",
            realtimeScore: RealtimeScore.internalBinaryRead(reader, reader.uint32(), options, message.data.realtimeScore)
          };
          break;
        case /* proto.packets.Push.SongFinished song_finished */
        2:
          message.data = {
            oneofKind: "songFinished",
            songFinished: Push_SongFinished.internalBinaryRead(reader, reader.uint32(), options, message.data.songFinished)
          };
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.data.oneofKind === "realtimeScore")
      RealtimeScore.internalBinaryWrite(message.data.realtimeScore, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.data.oneofKind === "songFinished")
      Push_SongFinished.internalBinaryWrite(message.data.songFinished, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Push = new Push$Type();
var Push_SongFinished$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Push.SongFinished", [
      { no: 1, name: "player", kind: "message", T: () => User },
      { no: 2, name: "beatmap", kind: "message", T: () => Beatmap },
      { no: 3, name: "type", kind: "enum", T: () => ["proto.packets.Push.SongFinished.CompletionType", Push_SongFinished_CompletionType] },
      {
        no: 4,
        name: "score",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 5,
        name: "misses",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 6,
        name: "bad_cuts",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 7,
        name: "good_cuts",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 8,
        name: "end_time",
        kind: "scalar",
        T: 2
        /*ScalarType.FLOAT*/
      },
      {
        no: 9,
        name: "tournament_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "match_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { type: 0, score: 0, misses: 0, badCuts: 0, goodCuts: 0, endTime: 0, tournamentId: "", matchId: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* proto.models.User player */
        1:
          message.player = User.internalBinaryRead(reader, reader.uint32(), options, message.player);
          break;
        case /* proto.models.Beatmap beatmap */
        2:
          message.beatmap = Beatmap.internalBinaryRead(reader, reader.uint32(), options, message.beatmap);
          break;
        case /* proto.packets.Push.SongFinished.CompletionType type */
        3:
          message.type = reader.int32();
          break;
        case /* int32 score */
        4:
          message.score = reader.int32();
          break;
        case /* int32 misses */
        5:
          message.misses = reader.int32();
          break;
        case /* int32 bad_cuts */
        6:
          message.badCuts = reader.int32();
          break;
        case /* int32 good_cuts */
        7:
          message.goodCuts = reader.int32();
          break;
        case /* float end_time */
        8:
          message.endTime = reader.float();
          break;
        case /* string tournament_id */
        9:
          message.tournamentId = reader.string();
          break;
        case /* string match_id */
        10:
          message.matchId = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.player)
      User.internalBinaryWrite(message.player, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.beatmap)
      Beatmap.internalBinaryWrite(message.beatmap, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.type !== 0)
      writer.tag(3, WireType.Varint).int32(message.type);
    if (message.score !== 0)
      writer.tag(4, WireType.Varint).int32(message.score);
    if (message.misses !== 0)
      writer.tag(5, WireType.Varint).int32(message.misses);
    if (message.badCuts !== 0)
      writer.tag(6, WireType.Varint).int32(message.badCuts);
    if (message.goodCuts !== 0)
      writer.tag(7, WireType.Varint).int32(message.goodCuts);
    if (message.endTime !== 0)
      writer.tag(8, WireType.Bit32).float(message.endTime);
    if (message.tournamentId !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.tournamentId);
    if (message.matchId !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.matchId);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Push_SongFinished = new Push_SongFinished$Type();

// src/models/commands.ts
init_dirname();
init_buffer2();
init_process2();
var Command$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Command", [
      {
        no: 1,
        name: "heartbeat",
        kind: "scalar",
        oneof: "type",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "return_to_menu",
        kind: "scalar",
        oneof: "type",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "delay_test_finish",
        kind: "scalar",
        oneof: "type",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 4,
        name: "stream_sync_show_image",
        kind: "scalar",
        oneof: "type",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 6, name: "play_song", kind: "message", oneof: "type", T: () => Command_PlaySong },
      { no: 7, name: "send_bot_message", kind: "message", oneof: "type", T: () => Command_SendBotMessage },
      {
        no: 9,
        name: "discord_authorize",
        kind: "scalar",
        oneof: "type",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { type: { oneofKind: void 0 } };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool heartbeat */
        1:
          message.type = {
            oneofKind: "heartbeat",
            heartbeat: reader.bool()
          };
          break;
        case /* bool return_to_menu */
        2:
          message.type = {
            oneofKind: "returnToMenu",
            returnToMenu: reader.bool()
          };
          break;
        case /* bool delay_test_finish */
        3:
          message.type = {
            oneofKind: "delayTestFinish",
            delayTestFinish: reader.bool()
          };
          break;
        case /* bool stream_sync_show_image */
        4:
          message.type = {
            oneofKind: "streamSyncShowImage",
            streamSyncShowImage: reader.bool()
          };
          break;
        case /* proto.packets.Command.PlaySong play_song */
        6:
          message.type = {
            oneofKind: "playSong",
            playSong: Command_PlaySong.internalBinaryRead(reader, reader.uint32(), options, message.type.playSong)
          };
          break;
        case /* proto.packets.Command.SendBotMessage send_bot_message */
        7:
          message.type = {
            oneofKind: "sendBotMessage",
            sendBotMessage: Command_SendBotMessage.internalBinaryRead(reader, reader.uint32(), options, message.type.sendBotMessage)
          };
          break;
        case /* string discord_authorize */
        9:
          message.type = {
            oneofKind: "discordAuthorize",
            discordAuthorize: reader.string()
          };
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.type.oneofKind === "heartbeat")
      writer.tag(1, WireType.Varint).bool(message.type.heartbeat);
    if (message.type.oneofKind === "returnToMenu")
      writer.tag(2, WireType.Varint).bool(message.type.returnToMenu);
    if (message.type.oneofKind === "delayTestFinish")
      writer.tag(3, WireType.Varint).bool(message.type.delayTestFinish);
    if (message.type.oneofKind === "streamSyncShowImage")
      writer.tag(4, WireType.Varint).bool(message.type.streamSyncShowImage);
    if (message.type.oneofKind === "playSong")
      Command_PlaySong.internalBinaryWrite(message.type.playSong, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "sendBotMessage")
      Command_SendBotMessage.internalBinaryWrite(message.type.sendBotMessage, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.type.oneofKind === "discordAuthorize")
      writer.tag(9, WireType.LengthDelimited).string(message.type.discordAuthorize);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Command = new Command$Type();
var Command_PlaySong$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Command.PlaySong", [
      { no: 1, name: "gameplay_parameters", kind: "message", T: () => GameplayParameters }
    ]);
  }
  create(value) {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* proto.models.GameplayParameters gameplay_parameters */
        1:
          message.gameplayParameters = GameplayParameters.internalBinaryRead(reader, reader.uint32(), options, message.gameplayParameters);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.gameplayParameters)
      GameplayParameters.internalBinaryWrite(message.gameplayParameters, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Command_PlaySong = new Command_PlaySong$Type();
var Command_SendBotMessage$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Command.SendBotMessage", [
      { no: 1, name: "channel", kind: "message", T: () => Channel },
      {
        no: 2,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = { message: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* proto.discord.Channel channel */
        1:
          message.channel = Channel.internalBinaryRead(reader, reader.uint32(), options, message.channel);
          break;
        case /* string message */
        2:
          message.message = reader.string();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.channel)
      Channel.internalBinaryWrite(message.channel, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.message !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.message);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Command_SendBotMessage = new Command_SendBotMessage$Type();

// src/models/packets.ts
var Acknowledgement_AcknowledgementType = /* @__PURE__ */ ((Acknowledgement_AcknowledgementType2) => {
  Acknowledgement_AcknowledgementType2[Acknowledgement_AcknowledgementType2["MessageReceived"] = 0] = "MessageReceived";
  return Acknowledgement_AcknowledgementType2;
})(Acknowledgement_AcknowledgementType || {});
var Acknowledgement$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Acknowledgement", [
      {
        no: 1,
        name: "packet_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "type", kind: "enum", T: () => ["proto.packets.Acknowledgement.AcknowledgementType", Acknowledgement_AcknowledgementType] }
    ]);
  }
  create(value) {
    const message = { packetId: "", type: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string packet_id */
        1:
          message.packetId = reader.string();
          break;
        case /* proto.packets.Acknowledgement.AcknowledgementType type */
        2:
          message.type = reader.int32();
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.packetId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.packetId);
    if (message.type !== 0)
      writer.tag(2, WireType.Varint).int32(message.type);
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Acknowledgement = new Acknowledgement$Type();
var ForwardingPacket$Type = class extends MessageType {
  constructor() {
    super("proto.packets.ForwardingPacket", [
      {
        no: 1,
        name: "forward_to",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "packet", kind: "message", T: () => Packet }
    ]);
  }
  create(value) {
    const message = { forwardTo: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string forward_to */
        1:
          message.forwardTo.push(reader.string());
          break;
        case /* proto.packets.Packet packet */
        2:
          message.packet = Packet.internalBinaryRead(reader, reader.uint32(), options, message.packet);
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i2 = 0; i2 < message.forwardTo.length; i2++)
      writer.tag(1, WireType.LengthDelimited).string(message.forwardTo[i2]);
    if (message.packet)
      Packet.internalBinaryWrite(message.packet, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var ForwardingPacket = new ForwardingPacket$Type();
var Packet$Type = class extends MessageType {
  constructor() {
    super("proto.packets.Packet", [
      {
        no: 1,
        name: "token",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "from",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 4, name: "acknowledgement", kind: "message", oneof: "packet", T: () => Acknowledgement },
      { no: 5, name: "forwarding_packet", kind: "message", oneof: "packet", T: () => ForwardingPacket },
      { no: 6, name: "command", kind: "message", oneof: "packet", T: () => Command },
      { no: 7, name: "push", kind: "message", oneof: "packet", T: () => Push },
      { no: 8, name: "request", kind: "message", oneof: "packet", T: () => Request },
      { no: 9, name: "response", kind: "message", oneof: "packet", T: () => Response },
      { no: 10, name: "event", kind: "message", oneof: "packet", T: () => Event }
    ]);
  }
  create(value) {
    const message = { token: "", id: "", from: "", packet: { oneofKind: void 0 } };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string token */
        1:
          message.token = reader.string();
          break;
        case /* string id */
        2:
          message.id = reader.string();
          break;
        case /* string from */
        3:
          message.from = reader.string();
          break;
        case /* proto.packets.Acknowledgement acknowledgement */
        4:
          message.packet = {
            oneofKind: "acknowledgement",
            acknowledgement: Acknowledgement.internalBinaryRead(reader, reader.uint32(), options, message.packet.acknowledgement)
          };
          break;
        case /* proto.packets.ForwardingPacket forwarding_packet */
        5:
          message.packet = {
            oneofKind: "forwardingPacket",
            forwardingPacket: ForwardingPacket.internalBinaryRead(reader, reader.uint32(), options, message.packet.forwardingPacket)
          };
          break;
        case /* proto.packets.Command command */
        6:
          message.packet = {
            oneofKind: "command",
            command: Command.internalBinaryRead(reader, reader.uint32(), options, message.packet.command)
          };
          break;
        case /* proto.packets.Push push */
        7:
          message.packet = {
            oneofKind: "push",
            push: Push.internalBinaryRead(reader, reader.uint32(), options, message.packet.push)
          };
          break;
        case /* proto.packets.Request request */
        8:
          message.packet = {
            oneofKind: "request",
            request: Request.internalBinaryRead(reader, reader.uint32(), options, message.packet.request)
          };
          break;
        case /* proto.packets.Response response */
        9:
          message.packet = {
            oneofKind: "response",
            response: Response.internalBinaryRead(reader, reader.uint32(), options, message.packet.response)
          };
          break;
        case /* proto.packets.Event event */
        10:
          message.packet = {
            oneofKind: "event",
            event: Event.internalBinaryRead(reader, reader.uint32(), options, message.packet.event)
          };
          break;
        default:
          let u2 = options.readUnknownField;
          if (u2 === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.token !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.token);
    if (message.id !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.id);
    if (message.from !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.from);
    if (message.packet.oneofKind === "acknowledgement")
      Acknowledgement.internalBinaryWrite(message.packet.acknowledgement, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    if (message.packet.oneofKind === "forwardingPacket")
      ForwardingPacket.internalBinaryWrite(message.packet.forwardingPacket, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
    if (message.packet.oneofKind === "command")
      Command.internalBinaryWrite(message.packet.command, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
    if (message.packet.oneofKind === "push")
      Push.internalBinaryWrite(message.packet.push, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
    if (message.packet.oneofKind === "request")
      Request.internalBinaryWrite(message.packet.request, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    if (message.packet.oneofKind === "response")
      Response.internalBinaryWrite(message.packet.response, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
    if (message.packet.oneofKind === "event")
      Event.internalBinaryWrite(message.packet.event, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 == true ? UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
    return writer;
  }
};
var Packet = new Packet$Type();

// src/client.ts
var import_ws = __toESM(require_ws(), 1);
var Client = class extends CustomEventEmitter {
  address;
  port;
  token;
  websocket;
  websocketWasConnected = false;
  constructor(address, port, token) {
    super();
    this.address = address;
    this.port = port;
    this.token = token ?? "";
  }
  get isConnected() {
    var _a;
    return ((_a = this.websocket) == null ? void 0 : _a.readyState) === import_ws.default.OPEN;
  }
  get readyState() {
    var _a;
    return (_a = this.websocket) == null ? void 0 : _a.readyState;
  }
  connect() {
    this.websocket = new import_ws.default(`wss://${this.address}:${this.port}`);
    this.websocket.binaryType = "arraybuffer";
    if (!this.websocket) {
      this.emit("failedToConnectToServer", {});
      return;
    }
    this.websocket.onopen = () => {
      this.websocketWasConnected = true;
      this.emit("connectedToServer", {});
    };
    this.websocket.onmessage = (event) => {
      if (event.data instanceof ArrayBuffer) {
        const packet = Packet.fromBinary(new Uint8Array(event.data));
        this.emit("packetReceived", packet);
      }
    };
    this.websocket.onclose = () => {
      if (this.websocketWasConnected) {
        this.emit("disconnectedFromServer", {});
      } else {
        this.emit("failedToConnectToServer", {});
      }
    };
    this.websocket.onerror = (error) => {
      console.error(error);
    };
  }
  disconnect() {
    var _a;
    (_a = this.websocket) == null ? void 0 : _a.close();
  }
  setToken(token) {
    this.token = token;
  }
  send(packet, ids) {
    var _a;
    let toSend = packet;
    toSend.token = this.token;
    if (ids) {
      const toForward = {
        packet,
        forwardTo: ids
      };
      toSend = {
        token: this.token,
        from: packet.from,
        id: packet.id,
        packet: {
          oneofKind: "forwardingPacket",
          forwardingPacket: toForward
        }
      };
    }
    (_a = this.websocket) == null ? void 0 : _a.send(Packet.toBinary(toSend));
  }
};

// node_modules/uuid/dist/esm-browser/index.js
init_dirname();
init_buffer2();
init_process2();

// node_modules/uuid/dist/esm-browser/rng.js
init_dirname();
init_buffer2();
init_process2();
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
init_dirname();
init_buffer2();
init_process2();
var byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/v4.js
init_dirname();
init_buffer2();
init_process2();

// node_modules/uuid/dist/esm-browser/native.js
init_dirname();
init_buffer2();
init_process2();
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/state-manager.ts
init_dirname();
init_buffer2();
init_process2();
var StateManager = class extends CustomEventEmitter {
  state;
  self;
  constructor() {
    super();
    this.self = v4_default();
    this.state = {
      tournaments: [],
      knownServers: []
    };
  }
  // --- Packet handler --- //
  handlePacket(packet) {
    if (packet.packet.oneofKind === "event") {
      const event = packet.packet.event;
      switch (event.changedObject.oneofKind) {
        case "userAdded": {
          this.userConnected(
            event.changedObject.userAdded.tournamentId,
            event.changedObject.userAdded.user
          );
          break;
        }
        case "userUpdated": {
          this.userUpdated(
            event.changedObject.userUpdated.tournamentId,
            event.changedObject.userUpdated.user
          );
          break;
        }
        case "userLeft": {
          this.userDisconnected(
            event.changedObject.userLeft.tournamentId,
            event.changedObject.userLeft.user
          );
          break;
        }
        case "matchCreated": {
          this.matchCreated(
            event.changedObject.matchCreated.tournamentId,
            event.changedObject.matchCreated.match
          );
          break;
        }
        case "matchUpdated": {
          this.matchUpdated(
            event.changedObject.matchUpdated.tournamentId,
            event.changedObject.matchUpdated.match
          );
          break;
        }
        case "matchDeleted": {
          this.matchDeleted(
            event.changedObject.matchDeleted.tournamentId,
            event.changedObject.matchDeleted.match
          );
          break;
        }
        case "qualifierCreated": {
          this.qualifierEventCreated(
            event.changedObject.qualifierCreated.tournamentId,
            event.changedObject.qualifierCreated.event
          );
          break;
        }
        case "qualifierUpdated": {
          this.qualifierEventUpdated(
            event.changedObject.qualifierUpdated.tournamentId,
            event.changedObject.qualifierUpdated.event
          );
          break;
        }
        case "qualifierDeleted": {
          this.qualifierEventDeleted(
            event.changedObject.qualifierDeleted.tournamentId,
            event.changedObject.qualifierDeleted.event
          );
          break;
        }
        case "tournamentCreated": {
          this.tournamentCreated(
            event.changedObject.tournamentCreated.tournament
          );
          break;
        }
        case "tournamentUpdated": {
          this.tournamentUpdated(
            event.changedObject.tournamentUpdated.tournament
          );
          break;
        }
        case "tournamentDeleted": {
          this.tournamentDeleted(
            event.changedObject.tournamentDeleted.tournament
          );
          break;
        }
        case "serverAdded": {
          this.serverAdded(event.changedObject.serverAdded.server);
          break;
        }
        case "serverDeleted": {
          this.serverDeleted(event.changedObject.serverDeleted.server);
          break;
        }
      }
    } else if (packet.packet.oneofKind === "response") {
      const response = packet.packet.response;
      if (response.details.oneofKind === "connect") {
        const connect = response.details.connect;
        if (response.type === 1 /* Success */) {
          this.state = connect.state;
        }
      } else if (response.details.oneofKind === "join") {
        const join = response.details.join;
        if (response.type === 1 /* Success */) {
          this.state = join.state;
          this.self = join.selfGuid;
        }
      }
    }
  }
  // --- Helpers --- //
  getSelfGuid() {
    return this.self;
  }
  getTournaments() {
    return this.state.tournaments;
  }
  getTournament(id) {
    return this.state.tournaments.find((x) => x.guid === id);
  }
  getUsers(tournamentId) {
    var _a;
    return (_a = this.getTournament(tournamentId)) == null ? void 0 : _a.users;
  }
  getUser(tournamentId, userId) {
    var _a;
    return (_a = this.getUsers(tournamentId)) == null ? void 0 : _a.find((x) => x.guid === userId);
  }
  getMatches(tournamentId) {
    var _a;
    return (_a = this.getTournament(tournamentId)) == null ? void 0 : _a.matches;
  }
  getMatch(tournamentId, matchId) {
    var _a;
    return (_a = this.getMatches(tournamentId)) == null ? void 0 : _a.find((x) => x.guid === matchId);
  }
  getQualifiers(tournamentId) {
    var _a;
    return (_a = this.getTournament(tournamentId)) == null ? void 0 : _a.qualifiers;
  }
  getQualifier(tournamentId, qualifierId) {
    var _a;
    return (_a = this.getQualifiers(tournamentId)) == null ? void 0 : _a.find((x) => x.guid === qualifierId);
  }
  getKnownServers() {
    return this.state.knownServers;
  }
  // --- Event handlers --- //
  userConnected = (tournamentId, user) => {
    const tournament = this.getTournament(tournamentId);
    tournament.users = [...tournament.users, user];
    this.emit("userConnected", [user, tournament]);
  };
  userUpdated = (tournamentId, user) => {
    const tournament = this.getTournament(tournamentId);
    const index = tournament.users.findIndex((x) => x.guid === user.guid);
    tournament.users[index] = user;
    this.emit("userUpdated", [user, tournament]);
  };
  userDisconnected = (tournamentId, user) => {
    const tournament = this.getTournament(tournamentId);
    tournament.users = tournament.users.filter((x) => x.guid !== user.guid);
    this.emit("userDisconnected", [user, tournament]);
  };
  matchCreated = (tournamentId, match) => {
    const tournament = this.getTournament(tournamentId);
    tournament.matches = [...tournament.matches, match];
    this.emit("matchCreated", [match, tournament]);
  };
  matchUpdated = (tournamentId, match) => {
    const tournament = this.getTournament(tournamentId);
    const index = tournament.matches.findIndex((x) => x.guid === match.guid);
    tournament.matches[index] = match;
    this.emit("matchUpdated", [match, tournament]);
  };
  matchDeleted = (tournamentId, match) => {
    const tournament = this.getTournament(tournamentId);
    tournament.matches = tournament.matches.filter(
      (x) => x.guid !== match.guid
    );
    this.emit("matchDeleted", [match, tournament]);
  };
  qualifierEventCreated = (tournamentId, event) => {
    const tournament = this.getTournament(tournamentId);
    tournament.qualifiers = [...tournament.qualifiers, event];
    this.emit("qualifierCreated", [event, tournament]);
  };
  qualifierEventUpdated = (tournamentId, event) => {
    const tournament = this.getTournament(tournamentId);
    const index = tournament.qualifiers.findIndex(
      (x) => x.guid === event.guid
    );
    tournament.qualifiers[index] = event;
    this.emit("qualifierUpdated", [event, tournament]);
  };
  qualifierEventDeleted = (tournamentId, event) => {
    const tournament = this.getTournament(tournamentId);
    tournament.qualifiers = tournament.qualifiers.filter(
      (x) => x.guid !== event.guid
    );
    this.emit("qualifierDeleted", [event, tournament]);
  };
  tournamentCreated = (tournament) => {
    this.state.tournaments = [...this.state.tournaments, tournament];
    this.emit("tournamentCreated", tournament);
  };
  tournamentUpdated = (tournament) => {
    const index = this.state.tournaments.findIndex(
      (x) => x.guid === tournament.guid
    );
    this.state.tournaments[index] = tournament;
    this.emit("tournamentUpdated", tournament);
  };
  tournamentDeleted = (tournament) => {
    this.state.tournaments = this.state.tournaments.filter(
      (x) => x.guid !== tournament.guid
    );
    this.emit("tournamentDeleted", tournament);
  };
  serverAdded = (server) => {
    this.state.knownServers = [...this.state.knownServers, server];
    this.emit("serverAdded", server);
  };
  serverDeleted = (server) => {
    this.state.knownServers = this.state.knownServers.filter(
      (x) => `${server.address}:${server.port}` !== `${x.address}:${x.port}`
    );
    this.emit("serverDeleted", server);
  };
};

// src/constants.ts
init_dirname();
init_buffer2();
init_process2();
var masterAddress = "server.tournamentassistant.net";
var masterPort = "8676";
var version = "1.1.7";
var versionCode = 117;

// src/tournament-assistant-client.ts
var import_ws2 = __toESM(require_ws(), 1);

// src/scraper.ts
init_dirname();
init_buffer2();
init_process2();
var MASTER_ADDRESS = "server.tournamentassistant.net";
var MASTER_PORT = "8676";
function getTournaments(token, onProgress, onComplete) {
  const scraper = new Scraper(token);
  scraper.on("onProgress", (progress) => {
    onProgress(
      progress.totalServers,
      progress.succeededServers,
      progress.failedServers
    );
    if (progress.failedServers + progress.succeededServers === progress.totalServers) {
      onComplete(progress.tournaments);
    }
  });
  scraper.getTournaments();
}
var Scraper = class extends CustomEventEmitter {
  servers = [];
  tournaments = [];
  token;
  succeededServers = 0;
  failedServers = 0;
  constructor(token) {
    super();
    this.token = token;
  }
  getTournaments() {
    const masterClient = new TAClient();
    masterClient.setAuthToken(this.token);
    masterClient.on("connectedToServer", async (response) => {
      this.servers = response.state.knownServers;
      this.tournaments = response.state.tournaments;
      masterClient.disconnect();
      this.succeededServers++;
      this.emit("onProgress", {
        totalServers: this.servers.length,
        succeededServers: this.succeededServers,
        failedServers: this.failedServers,
        tournaments: this.tournaments
      });
      this.servers.filter(
        (x) => `${x.address}:${x.websocketPort}` !== `${MASTER_ADDRESS}:${MASTER_PORT}`
      ).map(
        (x) => this.getTournamentsFromServer(x.address, `${x.websocketPort}`)
      );
    });
    masterClient.on("failedToConnectToServer", () => {
      this.failedServers++;
      this.emit("onProgress", {
        totalServers: this.servers.length,
        succeededServers: this.succeededServers,
        failedServers: this.failedServers,
        tournaments: this.tournaments
      });
    });
    masterClient.connect(MASTER_ADDRESS, MASTER_PORT);
  }
  async getTournamentsFromServer(address, port) {
    const client = new TAClient();
    client.setAuthToken(this.token);
    client.on("connectedToServer", (response) => {
      this.tournaments = [...this.tournaments, ...response.state.tournaments];
      client.disconnect();
      this.succeededServers++;
      this.emit("onProgress", {
        totalServers: this.servers.length,
        succeededServers: this.succeededServers,
        failedServers: this.failedServers,
        tournaments: this.tournaments
      });
    });
    client.on("failedToConnectToServer", () => {
      this.failedServers++;
      this.emit("onProgress", {
        totalServers: this.servers.length,
        succeededServers: this.succeededServers,
        failedServers: this.failedServers,
        tournaments: this.tournaments
      });
    });
    client.connect(address, port);
  }
};

// src/tournament-assistant-client.ts
var TAClient = class extends CustomEventEmitter {
  stateManager;
  uiVersion;
  client;
  token = "";
  shouldHeartbeat = false;
  heartbeatInterval;
  constructor(uiVersion = void 0) {
    super();
    this.stateManager = new StateManager();
    this.uiVersion = uiVersion;
  }
  // --- State helpers --- //
  get isConnected() {
    var _a;
    return ((_a = this.client) == null ? void 0 : _a.isConnected) ?? false;
  }
  get isConnecting() {
    var _a;
    return ((_a = this.client) == null ? void 0 : _a.readyState) === import_ws2.default.CONNECTING;
  }
  // --- Actions --- //
  async connect(serverAddress, port) {
    this.shouldHeartbeat = true;
    this.client = new Client(serverAddress, port, this.token);
    this.client.on("packetReceived", this.handlePacket);
    this.client.on("disconnectedFromServer", () => {
      clearInterval(this.heartbeatInterval);
      console.info("Disconnected from server!");
      this.emit("disconnectedFromServer", {});
    });
    this.client.on("failedToConnectToServer", () => {
      console.error("Failed to connect to server!");
      this.emit("failedToConnectToServer", {});
    });
    this.emit("connectingToServer", {});
    const connectPromise = new Promise((resolve, reject) => {
      var _a;
      const onConnectedToServer = async () => {
        var _a2;
        const response = await this.sendRequest({
          type: {
            oneofKind: "connect",
            connect: {
              clientVersion: versionCode,
              uiVersion: this.uiVersion ?? 0
            }
          }
        });
        if (this.shouldHeartbeat) {
          this.heartbeatInterval = setInterval(() => {
            var _a3;
            (_a3 = this.client) == null ? void 0 : _a3.send({
              token: this.token,
              from: this.stateManager.getSelfGuid(),
              id: v4_default(),
              packet: {
                oneofKind: "command",
                command: {
                  type: {
                    oneofKind: "heartbeat",
                    heartbeat: true
                  }
                }
              }
            });
          }, 1e4);
        }
        (_a2 = this.client) == null ? void 0 : _a2.removeListener("connectedToServer", onConnectedToServer);
        clearTimeout(timeout);
        if (response.length <= 0) {
          reject("Server timed out");
        } else {
          resolve(response[0].response);
        }
      };
      const createTimeout = (time) => {
        return setTimeout(() => {
          var _a2;
          (_a2 = this.client) == null ? void 0 : _a2.removeListener("connectedToServer", onConnectedToServer);
          reject("Server timed out");
        }, time);
      };
      const timeout = createTimeout(3e4);
      (_a = this.client) == null ? void 0 : _a.on("connectedToServer", onConnectedToServer);
    });
    this.client.connect();
    return connectPromise;
  }
  disconnect() {
    var _a;
    this.shouldHeartbeat = false;
    console.info(`Disconnecting from server!`);
    (_a = this.client) == null ? void 0 : _a.disconnect();
  }
  setAuthToken(token) {
    var _a;
    this.token = token;
    (_a = this.client) == null ? void 0 : _a.setToken(token);
  }
  forwardToUsers(packet, to) {
    var _a;
    (_a = this.client) == null ? void 0 : _a.send({
      token: "",
      // Overridden in this.send()
      from: packet.from,
      id: packet.id,
      packet: {
        oneofKind: "forwardingPacket",
        forwardingPacket: {
          forwardTo: to,
          packet
        }
      }
    });
  }
  sendCommand(command, to) {
    const packet = {
      token: this.token,
      from: this.stateManager.getSelfGuid(),
      id: v4_default(),
      packet: {
        oneofKind: "command",
        command
      }
    };
    this.forwardToUsers(packet, to);
  }
  async sendRequest(request, to, timeout = 3e4) {
    var _a;
    const packet = {
      token: "",
      // Overridden in this.send()
      from: this.stateManager.getSelfGuid(),
      id: v4_default(),
      packet: {
        oneofKind: "request",
        request
      }
    };
    const responseDictionary = [];
    const responsesPromise = new Promise((resolve) => {
      const addListeners = () => {
        this.on("responseReceived", onResponseReceived);
        this.on("authorizationRequestedFromServer", onAuthorizationRequested);
      };
      const removeListeners = () => {
        this.removeListener("responseReceived", onResponseReceived);
        this.removeListener(
          "authorizationRequestedFromServer",
          onAuthorizationRequested
        );
      };
      const getUnrespondedUsers = () => {
        const responseUsers = responseDictionary.map((x) => x.userId);
        const expectedUsers = to ?? ["00000000-0000-0000-0000-000000000000"];
        if (responseUsers.length === expectedUsers.length) {
          return [];
        }
        const sortedArr1 = responseUsers.slice().sort();
        const sortedArr2 = expectedUsers.slice().sort();
        let waitingForUsers = [];
        for (let i2 = 0; i2 < sortedArr2.length; i2++) {
          if (i2 > sortedArr1.length || sortedArr2[i2] !== sortedArr1[i2]) {
            waitingForUsers.push(sortedArr2[i2]);
          }
        }
        return waitingForUsers;
      };
      const onResponseReceived = (response) => {
        const expectedUsers = to ?? ["00000000-0000-0000-0000-000000000000"];
        if (response.response.respondingToPacketId === packet.id && expectedUsers.includes(response.userId)) {
          responseDictionary.push({
            userId: response.userId,
            response: response.response
          });
          if (getUnrespondedUsers().length === 0) {
            removeListeners();
            clearTimeout(timeoutTimer);
            resolve(responseDictionary);
          }
        }
      };
      const createTimeout = (time) => {
        return setTimeout(() => {
          const unrespondedUsers = getUnrespondedUsers();
          for (let user of unrespondedUsers) {
            responseDictionary.push({
              userId: user,
              response: {
                type: 0 /* Fail */,
                respondingToPacketId: packet.id,
                details: {
                  oneofKind: void 0
                }
              }
            });
          }
          removeListeners();
          resolve(responseDictionary);
        }, time);
      };
      const timeoutTimer = createTimeout(timeout);
      const onAuthorizationRequested = () => {
        clearTimeout(timeoutTimer);
        throw "Authorization token invalid or not provided";
      };
      addListeners();
    });
    if (to) {
      this.forwardToUsers(packet, to);
    } else {
      (_a = this.client) == null ? void 0 : _a.send(packet, to);
    }
    return responsesPromise;
  }
  async sendResponse(response, to) {
    var _a;
    const packet = {
      token: this.token,
      from: this.stateManager.getSelfGuid(),
      id: v4_default(),
      packet: {
        oneofKind: "response",
        response
      }
    };
    if (to) {
      this.forwardToUsers(packet, to);
    } else {
      (_a = this.client) == null ? void 0 : _a.send(packet, to);
    }
  }
  // --- Commands --- //
  playSong = (gameplayParameters, userIds) => {
    this.sendCommand({
      type: {
        oneofKind: "playSong",
        playSong: {
          gameplayParameters
        }
      }
    }, userIds);
  };
  returnToMenu = (userIds) => {
    this.sendCommand({
      type: {
        oneofKind: "returnToMenu",
        returnToMenu: true
      }
    }, userIds);
  };
  showLoadedImage = (userIds) => {
    this.sendCommand({
      type: {
        oneofKind: "streamSyncShowImage",
        streamSyncShowImage: true
      }
    }, userIds);
  };
  delayTestFinished = (userIds) => {
    this.sendCommand({
      type: {
        oneofKind: "delayTestFinish",
        delayTestFinish: true
      }
    }, userIds);
  };
  // --- Requests --- //
  joinTournament = async (tournamentId) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "join",
        join: {
          tournamentId,
          password: ""
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  getLeaderboard = async (tournamentId, qualifierId, mapId) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "qualifierScores",
        qualifierScores: {
          tournamentId,
          eventId: qualifierId,
          mapId
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  loadSong = async (levelId, userIds, timeout) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "loadSong",
        loadSong: {
          levelId,
          customHostUrl: ""
        }
      }
    }, userIds, timeout);
    if (response.length <= 0) {
      throw new Error("Server timed out, or no users responded");
    }
    return response;
  };
  loadImage = async (bitmap, userIds) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "preloadImageForStreamSync",
        preloadImageForStreamSync: {
          fileId: v4_default(),
          data: bitmap,
          compressed: false
        }
      }
    }, userIds);
    if (response.length <= 0) {
      throw new Error("Server timed out, or no users responded");
    }
    return response;
  };
  showPrompt = async (userIds, titleText, bodyText, canClose, options, timer) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "showPrompt",
        showPrompt: {
          promptId: v4_default(),
          messageTitle: titleText,
          messageText: bodyText,
          showTimer: !!timer,
          timeout: timer ?? 0,
          canClose,
          options
        }
      }
    }, userIds, timer ? timer * 1e3 : timer);
    if (response.length <= 0) {
      throw new Error("Server timed out, or no users responded");
    }
    return response;
  };
  // --- Packet Handler --- //
  handlePacket = (packet) => {
    this.stateManager.handlePacket(packet);
    if (packet.packet.oneofKind === "command") {
      const command = packet.packet.command;
      if (command.type.oneofKind === "discordAuthorize") {
        this.emit(
          "authorizationRequestedFromServer",
          command.type.discordAuthorize
        );
      }
    } else if (packet.packet.oneofKind === "request") {
      const request = packet.packet.request;
      if (request.type.oneofKind === "loadSong") {
        this.emit("loadSongRequested", [packet.id, packet.from, request.type.loadSong]);
      }
    } else if (packet.packet.oneofKind === "response") {
      const response = packet.packet.response;
      this.emit("responseReceived", {
        userId: packet.from,
        response
      });
      if (response.details.oneofKind === "connect") {
        const connect = response.details.connect;
        if (response.type === 1 /* Success */) {
          console.info(`Successfully connected to server!`);
          this.emit("connectedToServer", connect);
        } else {
          console.error(
            `Failed to connect to server. Message: ${connect.message}`
          );
          this.emit("failedToConnectToServer", {});
        }
      } else if (response.details.oneofKind === "join") {
        const join = response.details.join;
        if (response.type === 1 /* Success */) {
          console.info(`Successfully joined tournament!`);
          this.emit("joinedTournament", {});
        } else {
          console.error(`Failed to join server. Message: ${join.message}`);
          this.emit("failedToJoinTournament", {});
        }
      } else if (response.details.oneofKind === "createTournament") {
        const createTournament = response.details.createTournament;
        if (response.type === 1 /* Success */) {
          console.info(`Successfully created tournament!`);
          this.emit("createdTournament", {});
        } else {
          console.error(
            `Failed to create tournament. Message: ${createTournament.message}`
          );
          this.emit("failedToCreateTournament", {});
        }
      } else if (response.details.oneofKind === "updateTournament") {
        const updateTournament = response.details.updateTournament;
        if (response.type === 1 /* Success */) {
          console.info(`Successfully modified tournament!`);
          this.emit("updatedTournament", {});
        } else {
          console.error(
            `Failed update tournament. Message: ${updateTournament.message}`
          );
          this.emit("failedToUpdateTournament", {});
        }
      } else if (response.details.oneofKind === "deleteTournament") {
        const deleteTournament = response.details.deleteTournament;
        if (response.type === 1 /* Success */) {
          console.info(`Successfully deleted tournament!`);
          this.emit("deletedTournament", {});
        } else {
          console.error(
            `Failed to delete tournament. Message: ${deleteTournament.message}`
          );
          this.emit("failedToDeleteTournament", {});
        }
      } else if (response.details.oneofKind === "createMatch") {
        const createMatch = response.details.createMatch;
        if (response.type === 1 /* Success */) {
          console.info(`Successfully created match!`);
          this.emit("createdMatch", {});
        } else {
          console.error(
            `Failed to create Match. Message: ${createMatch.message}`
          );
          this.emit("failedToCreateMatch", {});
        }
      } else if (response.details.oneofKind === "updateMatch") {
        const updateMatch = response.details.updateMatch;
        if (response.type === 1 /* Success */) {
          console.info(`Successfully modified match!`);
          this.emit("updatedMatch", {});
        } else {
          console.error(`Failed update Match. Message: ${updateMatch.message}`);
          this.emit("failedToUpdateMatch", {});
        }
      } else if (response.details.oneofKind === "deleteMatch") {
        const deleteMatch = response.details.deleteMatch;
        if (response.type === 1 /* Success */) {
          console.info(`Successfully deleted match!`);
          this.emit("deletedMatch", {});
        } else {
          console.error(
            `Failed to delete Match. Message: ${deleteMatch.message}`
          );
          this.emit("failedToDeleteMatch", {});
        }
      } else if (response.details.oneofKind === "createQualifierEvent") {
        const createQualifierEvent = response.details.createQualifierEvent;
        if (response.type === 1 /* Success */) {
          console.info(`Successfully created qualifier!`);
          this.emit("createdQualifier", {});
        } else {
          console.error(
            `Failed to create qualifier. Message: ${createQualifierEvent.message}`
          );
          this.emit("failedToCreateQualifier", {});
        }
      } else if (response.details.oneofKind === "updateQualifierEvent") {
        const modifyQualifier = response.details.updateQualifierEvent;
        if (response.type === 1 /* Success */) {
          console.info(`Successfully modified qualifier!`);
          this.emit("updatedQualifier", {});
        } else {
          console.error(
            `Failed to update qualifier. Message: ${modifyQualifier.message}`
          );
          this.emit("failedToUpdateQualifier", {});
        }
      } else if (response.details.oneofKind === "deleteQualifierEvent") {
        const deleteQualifierEvent = response.details.deleteQualifierEvent;
        if (response.type === 1 /* Success */) {
          console.info(`Successfully deleted qualifier!`);
          this.emit("deletedQualifier", {});
        } else {
          console.error(
            `Failed to delete qualifier. Message: ${deleteQualifierEvent.message}`
          );
          this.emit("failedToDeleteQualifier", {});
        }
      }
    } else if (packet.packet.oneofKind === "push") {
      const push = packet.packet.push;
      if (push.data.oneofKind === "songFinished") {
        this.emit("songFinished", push.data.songFinished);
      } else if (push.data.oneofKind === "realtimeScore") {
        this.emit("realtimeScore", push.data.realtimeScore);
      }
    }
  };
  // --- State Actions --- //
  updateUser = async (tournamentId, user) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "updateUser",
        updateUser: {
          tournamentId,
          user
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  createMatch = async (tournamentId, match) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "createMatch",
        createMatch: {
          tournamentId,
          match
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  addUserToMatch = async (tournamentId, matchId, userId) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "addUserToMatch",
        addUserToMatch: {
          tournamentId,
          matchId,
          userId
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  removeUserFromMatch = async (tournamentId, matchId, userId) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "removeUserFromMatch",
        removeUserFromMatch: {
          tournamentId,
          matchId,
          userId
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  setMatchLeader = async (tournamentId, matchId, userId) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "setMatchLeader",
        setMatchLeader: {
          tournamentId,
          matchId,
          userId
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  setMatchMap = async (tournamentId, matchId, map) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "setMatchMap",
        setMatchMap: {
          tournamentId,
          matchId,
          map
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  deleteMatch = async (tournamentId, matchId) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "deleteMatch",
        deleteMatch: {
          tournamentId,
          matchId
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  createQualifierEvent = async (tournamentId, event) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "createQualifierEvent",
        createQualifierEvent: {
          tournamentId,
          event
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  setQualifierName = async (tournamentId, qualifierId, qualifierName) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "setQualifierName",
        setQualifierName: {
          tournamentId,
          qualifierId,
          qualifierName
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  setQualifierImage = async (tournamentId, qualifierId, qualifierImage) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "setQualifierImage",
        setQualifierImage: {
          tournamentId,
          qualifierId,
          qualifierImage
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  setQualifierInfoChannel = async (tournamentId, qualifierId, infoChannel) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "setQualifierInfoChannel",
        setQualifierInfoChannel: {
          tournamentId,
          qualifierId,
          infoChannel
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  setQualifierFlags = async (tournamentId, qualifierId, qualifierFlags) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "setQualifierFlags",
        setQualifierFlags: {
          tournamentId,
          qualifierId,
          qualifierFlags
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  setQualifierLeaderboardSort = async (tournamentId, qualifierId, qualifierLeaderboardSort) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "setQualifierLeaderboardSort",
        setQualifierLeaderboardSort: {
          tournamentId,
          qualifierId,
          qualifierLeaderboardSort
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  addQualifierMaps = async (tournamentId, qualifierId, maps) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "addQualifierMaps",
        addQualifierMaps: {
          tournamentId,
          qualifierId,
          maps
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  updateQualifierMap = async (tournamentId, qualifierId, map) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "updateQualifierMap",
        updateQualifierMap: {
          tournamentId,
          qualifierId,
          map
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  removeQualifierMap = async (tournamentId, qualifierId, mapId) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "removeQualifierMap",
        removeQualifierMap: {
          tournamentId,
          qualifierId,
          mapId
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  deleteQualifierEvent = async (tournamentId, qualifierId) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "deleteQualifierEvent",
        deleteQualifierEvent: {
          tournamentId,
          qualifierId
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  addAuthorizedUser = async (tournamentId, discordId, permissionFlags) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "addAuthorizedUser",
        addAuthorizedUser: {
          tournamentId,
          discordId,
          permissionFlags
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  removeAuthorizedUser = async (tournamentId, discordId) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "removeAuthorizedUser",
        removeAuthorizedUser: {
          tournamentId,
          discordId
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  getAuthorizedUsers = async (tournamentId) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "getAuthorizedUsers",
        getAuthorizedUsers: {
          tournamentId
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  getDiscordInfo = async (tournamentId, discordId) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "getDiscordInfo",
        getDiscordInfo: {
          tournamentId,
          discordId
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  getBotTokensForUser = async (ownerDiscordId) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "getBotTokensForUser",
        getBotTokensForUser: {
          ownerDiscordId
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  generateBotToken = async (username) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "generateBotToken",
        generateBotToken: {
          username
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  revokeBotToken = async (botTokenGuid) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "revokeBotToken",
        revokeBotToken: {
          botTokenGuid
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  createTournament = async (tournament) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "createTournament",
        createTournament: {
          tournament
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  setTournamentName = async (tournamentId, tournamentName) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "setTournamentName",
        setTournamentName: {
          tournamentId,
          tournamentName
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  setTournamentImage = async (tournamentId, tournamentImage) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "setTournamentImage",
        setTournamentImage: {
          tournamentId,
          tournamentImage
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  setTournamentEnableTeams = async (tournamentId, enableTeams) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "setTournamentEnableTeams",
        setTournamentEnableTeams: {
          tournamentId,
          enableTeams
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  setTournamentEnablePools = async (tournamentId, enablePools) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "setTournamentEnablePools",
        setTournamentEnablePools: {
          tournamentId,
          enablePools
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  setTournamentShowTournamentButton = async (tournamentId, showTournamentButton) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "setTournamentShowTournamentButton",
        setTournamentShowTournamentButton: {
          tournamentId,
          showTournamentButton
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  setTournamentShowQualifierButton = async (tournamentId, showQualifierButton) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "setTournamentShowQualifierButton",
        setTournamentShowQualifierButton: {
          tournamentId,
          showQualifierButton
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  setTournamentAllowUnauthorizedView = async (tournamentId, allowUnauthorizedView) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "setTournamentAllowUnauthorizedView",
        setTournamentAllowUnauthorizedView: {
          tournamentId,
          allowUnauthorizedView
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  setTournamentScoreUpdateFrequency = async (tournamentId, scoreUpdateFrequency) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "setTournamentScoreUpdateFrequency",
        setTournamentScoreUpdateFrequency: {
          tournamentId,
          scoreUpdateFrequency
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  setTournamentBannedMods = async (tournamentId, bannedMods) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "setTournamentBannedMods",
        setTournamentBannedMods: {
          tournamentId,
          bannedMods
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  addTournamentTeam = async (tournamentId, team) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "addTournamentTeam",
        addTournamentTeam: {
          tournamentId,
          team
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  setTournamentTeamName = async (tournamentId, teamId, teamName) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "setTournamentTeamName",
        setTournamentTeamName: {
          tournamentId,
          teamId,
          teamName
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  setTournamentTeamImage = async (tournamentId, teamId, teamImage) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "setTournamentTeamImage",
        setTournamentTeamImage: {
          tournamentId,
          teamId,
          teamImage
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  removeTournamentTeam = async (tournamentId, teamId) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "removeTournamentTeam",
        removeTournamentTeam: {
          tournamentId,
          teamId
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  addTournamentPool = async (tournamentId, pool) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "addTournamentPool",
        addTournamentPool: {
          tournamentId,
          pool
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  setTournamentPoolName = async (tournamentId, poolId, poolName) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "setTournamentPoolName",
        setTournamentPoolName: {
          tournamentId,
          poolId,
          poolName
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  addTournamentPoolMaps = async (tournamentId, poolId, maps) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "addTournamentPoolMaps",
        addTournamentPoolMaps: {
          tournamentId,
          poolId,
          maps
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  updateTournamentPoolMap = async (tournamentId, poolId, map) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "updateTournamentPoolMap",
        updateTournamentPoolMap: {
          tournamentId,
          poolId,
          map
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  removeTournamentPoolMap = async (tournamentId, poolId, mapId) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "removeTournamentPoolMap",
        removeTournamentPoolMap: {
          tournamentId,
          poolId,
          mapId
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  removeTournamentPool = async (tournamentId, poolId) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "removeTournamentPool",
        removeTournamentPool: {
          tournamentId,
          poolId
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  deleteTournament = async (tournamentId) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "deleteTournament",
        deleteTournament: {
          tournamentId
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
  addServer = async (server, authToken) => {
    const response = await this.sendRequest({
      type: {
        oneofKind: "addServer",
        addServer: {
          server,
          authToken: authToken ?? ""
        }
      }
    });
    if (response.length <= 0) {
      throw new Error("Server timed out");
    }
    return response[0].response;
  };
};

// src/models/index.ts
init_dirname();
init_buffer2();
init_process2();
export {
  Acknowledgement,
  Acknowledgement_AcknowledgementType,
  Beatmap,
  Channel,
  Characteristic,
  Command,
  Command_PlaySong,
  Command_SendBotMessage,
  CoreServer,
  CustomEventEmitter,
  DiscordUser,
  Event,
  Event_MatchCreated,
  Event_MatchDeleted,
  Event_MatchUpdated,
  Event_QualifierCreated,
  Event_QualifierDeleted,
  Event_QualifierUpdated,
  Event_ServerAdded,
  Event_ServerDeleted,
  Event_TournamentCreated,
  Event_TournamentDeleted,
  Event_TournamentUpdated,
  Event_UserAdded,
  Event_UserLeft,
  Event_UserUpdated,
  ForwardingPacket,
  GameplayModifiers,
  GameplayModifiers_GameOptions,
  GameplayParameters,
  Guild,
  LeaderboardEntry,
  Map2 as Map,
  Match,
  Packet,
  Permissions,
  PlayerSpecificSettings,
  PlayerSpecificSettings_ArcVisibilityType,
  PlayerSpecificSettings_NoteJumpDurationTypeSettings,
  PlayerSpecificSettings_PlayerOptions,
  Push,
  Push_SongFinished,
  Push_SongFinished_CompletionType,
  QualifierEvent,
  QualifierEvent_EventSettings,
  QualifierEvent_LeaderboardSort,
  RealtimeScore,
  Request,
  Request_AddAuthorizedUser,
  Request_AddAuthorizedUserPermission,
  Request_AddQualifierMaps,
  Request_AddServer,
  Request_AddTournamentPool,
  Request_AddTournamentPoolMaps,
  Request_AddTournamentTeam,
  Request_AddUserToMatch,
  Request_Connect,
  Request_CreateMatch,
  Request_CreateQualifierEvent,
  Request_CreateTournament,
  Request_DeleteMatch,
  Request_DeleteQualifierEvent,
  Request_DeleteTournament,
  Request_GenerateBotToken,
  Request_GetAuthorizedUsers,
  Request_GetBotTokensForUser,
  Request_GetDiscordInfo,
  Request_Join,
  Request_LoadSong,
  Request_PreloadImageForStreamSync,
  Request_QualifierScores,
  Request_RemainingAttempts,
  Request_RemoveAuthorizedUser,
  Request_RemoveAuthorizedUserPermission,
  Request_RemoveQualifierMap,
  Request_RemoveTournamentPool,
  Request_RemoveTournamentPoolMap,
  Request_RemoveTournamentTeam,
  Request_RemoveUserFromMatch,
  Request_RevokeBotToken,
  Request_SetMatchLeader,
  Request_SetMatchMap,
  Request_SetQualifierFlags,
  Request_SetQualifierImage,
  Request_SetQualifierInfoChannel,
  Request_SetQualifierLeaderboardSort,
  Request_SetQualifierName,
  Request_SetTournamentAllowUnauthorizedView,
  Request_SetTournamentBannedMods,
  Request_SetTournamentEnablePools,
  Request_SetTournamentEnableTeams,
  Request_SetTournamentImage,
  Request_SetTournamentName,
  Request_SetTournamentPoolName,
  Request_SetTournamentScoreUpdateFrequency,
  Request_SetTournamentShowQualifierButton,
  Request_SetTournamentShowTournamentButton,
  Request_SetTournamentTeamImage,
  Request_SetTournamentTeamName,
  Request_ShowPrompt,
  Request_ShowPrompt_PromptOption,
  Request_SubmitQualifierScore,
  Request_UpdateQualifierMap,
  Request_UpdateTournamentPoolMap,
  Request_UpdateUser,
  Response,
  Response_AddAuthorizedUser,
  Response_AddServer,
  Response_Connect,
  Response_Connect_ConnectFailReason,
  Response_CreateMatch,
  Response_CreateQualifierEvent,
  Response_CreateTournament,
  Response_DeleteMatch,
  Response_DeleteQualifierEvent,
  Response_DeleteTournament,
  Response_GenerateBotToken,
  Response_GetAuthorizedUsers,
  Response_GetAuthorizedUsers_AuthroizedUser,
  Response_GetBotTokensForUser,
  Response_GetBotTokensForUser_BotUser,
  Response_GetDiscordInfo,
  Response_Join,
  Response_Join_JoinFailReason,
  Response_LeaderboardEntries,
  Response_LoadSong,
  Response_PreloadImageForStreamSync,
  Response_RemainingAttempts,
  Response_RemoveAuthorizedUser,
  Response_ResponseType,
  Response_RevokeBotToken,
  Response_ShowPrompt,
  Response_UpdateAuthorizedUser,
  Response_UpdateMatch,
  Response_UpdateQualifierEvent,
  Response_UpdateTournament,
  Response_UpdateUser,
  ScoreTrackerHand,
  State,
  TAClient,
  Tournament,
  Tournament_TournamentSettings,
  Tournament_TournamentSettings_Pool,
  Tournament_TournamentSettings_Team,
  User,
  User_ClientTypes,
  User_DiscordInfo,
  User_DownloadStates,
  User_PlayStates,
  User_Point,
  getTournaments,
  masterAddress,
  masterPort,
  version,
  versionCode
};
/*! Bundled license information:

@jspm/core/nodelibs/browser/buffer.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
