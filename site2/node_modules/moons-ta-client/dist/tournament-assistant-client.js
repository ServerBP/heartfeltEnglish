import { Client } from "./client.js";
import { CustomEventEmitter } from "./custom-event-emitter.js";
import { v4 as uuidv4 } from "uuid";
import { StateManager } from "./state-manager.js";
import { Response_ResponseType, } from "./models/responses.js";
import { versionCode } from "./constants.js";
import WebSocket from "ws";
// Created by Moon on 6/12/2022
export * from "./scraper.js";
export * from "./models/models.js";
export class TAClient extends CustomEventEmitter {
    stateManager;
    uiVersion;
    client;
    token = "";
    shouldHeartbeat = false;
    heartbeatInterval;
    constructor(uiVersion = undefined) {
        super();
        this.stateManager = new StateManager();
        this.uiVersion = uiVersion;
    }
    // --- State helpers --- //
    get isConnected() {
        return this.client?.isConnected ?? false;
    }
    get isConnecting() {
        return this.client?.readyState === WebSocket.CONNECTING;
    }
    // --- Actions --- //
    async connect(serverAddress, port) {
        this.shouldHeartbeat = true;
        this.client = new Client(serverAddress, port, this.token);
        this.client.on("packetReceived", this.handlePacket);
        this.client.on("disconnectedFromServer", () => {
            clearInterval(this.heartbeatInterval);
            console.info("Disconnected from server!");
            this.emit("disconnectedFromServer", {});
        });
        this.client.on("failedToConnectToServer", () => {
            console.error("Failed to connect to server!");
            this.emit("failedToConnectToServer", {});
        });
        this.emit("connectingToServer", {});
        // Create a promise that resolves when connected to the server
        const connectPromise = new Promise((resolve, reject) => {
            const onConnectedToServer = async () => {
                const response = await this.sendRequest({
                    type: {
                        oneofKind: "connect",
                        connect: {
                            clientVersion: versionCode,
                            uiVersion: this.uiVersion ?? 0
                        },
                    },
                });
                if (this.shouldHeartbeat) {
                    this.heartbeatInterval = setInterval(() => {
                        this.client?.send({
                            token: this.token,
                            from: this.stateManager.getSelfGuid(),
                            id: uuidv4(),
                            packet: {
                                oneofKind: "command",
                                command: {
                                    type: {
                                        oneofKind: "heartbeat",
                                        heartbeat: true,
                                    },
                                },
                            },
                        });
                    }, 10000);
                }
                this.client?.removeListener("connectedToServer", onConnectedToServer);
                clearTimeout(timeout);
                if (response.length <= 0) {
                    reject("Server timed out");
                }
                else {
                    resolve(response[0].response);
                }
            };
            // Return what we have after 5 seconds
            const createTimeout = (time) => {
                return setTimeout(() => {
                    this.client?.removeListener("connectedToServer", onConnectedToServer);
                    reject("Server timed out");
                }, time);
            };
            const timeout = createTimeout(30000);
            this.client?.on("connectedToServer", onConnectedToServer);
        });
        this.client.connect();
        return connectPromise;
    }
    disconnect() {
        this.shouldHeartbeat = false;
        console.info(`Disconnecting from server!`);
        this.client?.disconnect();
    }
    setAuthToken(token) {
        this.token = token;
        this.client?.setToken(token);
    }
    forwardToUsers(packet, to) {
        this.client?.send({
            token: "",
            from: packet.from,
            id: packet.id,
            packet: {
                oneofKind: "forwardingPacket",
                forwardingPacket: {
                    forwardTo: to,
                    packet,
                },
            },
        });
    }
    sendCommand(command, to) {
        const packet = {
            token: this.token,
            from: this.stateManager.getSelfGuid(),
            id: uuidv4(),
            packet: {
                oneofKind: "command",
                command,
            },
        };
        this.forwardToUsers(packet, to);
    }
    async sendRequest(request, to, timeout = 30000) {
        const packet = {
            token: "",
            from: this.stateManager.getSelfGuid(),
            id: uuidv4(),
            packet: {
                oneofKind: "request",
                request,
            },
        };
        const responseDictionary = [];
        // Create a promise that resolves when all responses are received
        const responsesPromise = new Promise((resolve) => {
            const addListeners = () => {
                this.on("responseReceived", onResponseReceived);
                this.on("authorizationRequestedFromServer", onAuthorizationRequested);
            };
            const removeListeners = () => {
                this.removeListener("responseReceived", onResponseReceived);
                this.removeListener("authorizationRequestedFromServer", onAuthorizationRequested);
            };
            const getUnrespondedUsers = () => {
                const responseUsers = responseDictionary.map((x) => x.userId);
                const expectedUsers = to ?? ["00000000-0000-0000-0000-000000000000"]; // If we didn't forward this to any users, we should expect a response from the server
                if (responseUsers.length === expectedUsers.length) {
                    return [];
                }
                const sortedArr1 = responseUsers.slice().sort();
                const sortedArr2 = expectedUsers.slice().sort();
                let waitingForUsers = [];
                for (let i = 0; i < sortedArr2.length; i++) {
                    if (i > sortedArr1.length || sortedArr2[i] !== sortedArr1[i]) {
                        waitingForUsers.push(sortedArr2[i]);
                    }
                }
                return waitingForUsers;
            };
            // Add to the dictionary when the response is to this packet, and from an expected user
            const onResponseReceived = (response) => {
                const expectedUsers = to ?? ["00000000-0000-0000-0000-000000000000"]; // If we didn't forward this to any users, we should expect a response from the server
                if (response.response.respondingToPacketId === packet.id &&
                    expectedUsers.includes(response.userId)) {
                    responseDictionary.push({
                        userId: response.userId,
                        response: response.response,
                    });
                    if (getUnrespondedUsers().length === 0) {
                        // All responses are received, clean up and resolve
                        removeListeners();
                        clearTimeout(timeoutTimer);
                        resolve(responseDictionary);
                    }
                }
            };
            // Return what we have after 30 seconds, inject errors for users that haven't responded yet
            const createTimeout = (time) => {
                return setTimeout(() => {
                    const unrespondedUsers = getUnrespondedUsers();
                    for (let user of unrespondedUsers) {
                        responseDictionary.push({
                            userId: user,
                            response: {
                                type: Response_ResponseType.Fail,
                                respondingToPacketId: packet.id,
                                details: {
                                    oneofKind: undefined
                                }
                            },
                        });
                    }
                    removeListeners();
                    resolve(responseDictionary);
                }, time);
            };
            const timeoutTimer = createTimeout(timeout);
            // If authorization is requested, we're assuming an external application failed
            // to provide a valid token, so we will combust
            const onAuthorizationRequested = () => {
                clearTimeout(timeoutTimer);
                throw "Authorization token invalid or not provided";
            };
            addListeners();
        });
        // Assume forwardToUsers emits the 'responseReceived' event asynchronously
        if (to) {
            this.forwardToUsers(packet, to);
        }
        else {
            this.client?.send(packet, to);
        }
        return responsesPromise;
    }
    async sendResponse(response, to) {
        const packet = {
            token: this.token,
            from: this.stateManager.getSelfGuid(),
            id: uuidv4(),
            packet: {
                oneofKind: "response",
                response,
            },
        };
        if (to) {
            this.forwardToUsers(packet, to);
        }
        else {
            this.client?.send(packet, to);
        }
    }
    // --- Commands --- //
    playSong = (gameplayParameters, userIds) => {
        this.sendCommand({
            type: {
                oneofKind: "playSong",
                playSong: {
                    gameplayParameters,
                },
            },
        }, userIds);
    };
    returnToMenu = (userIds) => {
        this.sendCommand({
            type: {
                oneofKind: "returnToMenu",
                returnToMenu: true,
            },
        }, userIds);
    };
    showLoadedImage = (userIds) => {
        this.sendCommand({
            type: {
                oneofKind: "streamSyncShowImage",
                streamSyncShowImage: true,
            },
        }, userIds);
    };
    delayTestFinished = (userIds) => {
        this.sendCommand({
            type: {
                oneofKind: "delayTestFinish",
                delayTestFinish: true,
            },
        }, userIds);
    };
    // --- Requests --- //
    joinTournament = async (tournamentId) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "join",
                join: {
                    tournamentId,
                    password: "",
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    getLeaderboard = async (tournamentId, qualifierId, mapId) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "qualifierScores",
                qualifierScores: {
                    tournamentId: tournamentId,
                    eventId: qualifierId,
                    mapId,
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    loadSong = async (levelId, userIds, timeout) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "loadSong",
                loadSong: {
                    levelId,
                    customHostUrl: ""
                },
            },
        }, userIds, timeout);
        if (response.length <= 0) {
            throw new Error("Server timed out, or no users responded");
        }
        return response;
    };
    loadImage = async (bitmap, userIds) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "preloadImageForStreamSync",
                preloadImageForStreamSync: {
                    fileId: uuidv4(),
                    data: bitmap,
                    compressed: false
                },
            },
        }, userIds);
        if (response.length <= 0) {
            throw new Error("Server timed out, or no users responded");
        }
        return response;
    };
    showPrompt = async (userIds, titleText, bodyText, canClose, options, timer) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "showPrompt",
                showPrompt: {
                    promptId: uuidv4(),
                    messageTitle: titleText,
                    messageText: bodyText,
                    showTimer: !!timer,
                    timeout: timer ?? 0,
                    canClose: canClose,
                    options
                },
            },
        }, userIds, timer ? timer * 1000 : timer);
        if (response.length <= 0) {
            throw new Error("Server timed out, or no users responded");
        }
        return response;
    };
    // --- Packet Handler --- //
    handlePacket = (packet) => {
        this.stateManager.handlePacket(packet);
        // if (packet.packet.oneofKind !== "acknowledgement") {
        //   const send: Packet = {
        //     token: this.token,
        //     from: this.stateManager.getSelfGuid(),
        //     id: uuidv4(),
        //     packet: {
        //       oneofKind: "acknowledgement",
        //       acknowledgement: {
        //         packetId: packet.id,
        //         type: Acknowledgement_AcknowledgementType.MessageReceived,
        //       },
        //     },
        //   };
        //   this.client?.send(send);
        // }
        if (packet.packet.oneofKind === "command") {
            const command = packet.packet.command;
            if (command.type.oneofKind === 'discordAuthorize') {
                this.emit("authorizationRequestedFromServer", command.type.discordAuthorize);
            }
        }
        else if (packet.packet.oneofKind === 'request') {
            const request = packet.packet.request;
            if (request.type.oneofKind === 'loadSong') {
                this.emit("loadSongRequested", [packet.id, packet.from, request.type.loadSong]);
            }
        }
        else if (packet.packet.oneofKind === "response") {
            const response = packet.packet.response;
            this.emit("responseReceived", {
                userId: packet.from,
                response: response,
            });
            if (response.details.oneofKind === "connect") {
                const connect = response.details.connect;
                if (response.type === Response_ResponseType.Success) {
                    console.info(`Successfully connected to server!`);
                    this.emit("connectedToServer", connect);
                }
                else {
                    console.error(`Failed to connect to server. Message: ${connect.message}`);
                    this.emit("failedToConnectToServer", {});
                }
            }
            else if (response.details.oneofKind === "join") {
                const join = response.details.join;
                if (response.type === Response_ResponseType.Success) {
                    console.info(`Successfully joined tournament!`);
                    this.emit("joinedTournament", {});
                }
                else {
                    console.error(`Failed to join server. Message: ${join.message}`);
                    this.emit("failedToJoinTournament", {});
                }
            }
            else if (response.details.oneofKind === "createTournament") {
                const createTournament = response.details.createTournament;
                if (response.type === Response_ResponseType.Success) {
                    console.info(`Successfully created tournament!`);
                    this.emit("createdTournament", {});
                }
                else {
                    console.error(`Failed to create tournament. Message: ${createTournament.message}`);
                    this.emit("failedToCreateTournament", {});
                }
            }
            else if (response.details.oneofKind === "updateTournament") {
                const updateTournament = response.details.updateTournament;
                if (response.type === Response_ResponseType.Success) {
                    console.info(`Successfully modified tournament!`);
                    this.emit("updatedTournament", {});
                }
                else {
                    console.error(`Failed update tournament. Message: ${updateTournament.message}`);
                    this.emit("failedToUpdateTournament", {});
                }
            }
            else if (response.details.oneofKind === "deleteTournament") {
                const deleteTournament = response.details.deleteTournament;
                if (response.type === Response_ResponseType.Success) {
                    console.info(`Successfully deleted tournament!`);
                    this.emit("deletedTournament", {});
                }
                else {
                    console.error(`Failed to delete tournament. Message: ${deleteTournament.message}`);
                    this.emit("failedToDeleteTournament", {});
                }
            }
            else if (response.details.oneofKind === "createMatch") {
                const createMatch = response.details.createMatch;
                if (response.type === Response_ResponseType.Success) {
                    console.info(`Successfully created match!`);
                    this.emit("createdMatch", {});
                }
                else {
                    console.error(`Failed to create Match. Message: ${createMatch.message}`);
                    this.emit("failedToCreateMatch", {});
                }
            }
            else if (response.details.oneofKind === "updateMatch") {
                const updateMatch = response.details.updateMatch;
                if (response.type === Response_ResponseType.Success) {
                    console.info(`Successfully modified match!`);
                    this.emit("updatedMatch", {});
                }
                else {
                    console.error(`Failed update Match. Message: ${updateMatch.message}`);
                    this.emit("failedToUpdateMatch", {});
                }
            }
            else if (response.details.oneofKind === "deleteMatch") {
                const deleteMatch = response.details.deleteMatch;
                if (response.type === Response_ResponseType.Success) {
                    console.info(`Successfully deleted match!`);
                    this.emit("deletedMatch", {});
                }
                else {
                    console.error(`Failed to delete Match. Message: ${deleteMatch.message}`);
                    this.emit("failedToDeleteMatch", {});
                }
            }
            else if (response.details.oneofKind === "createQualifierEvent") {
                const createQualifierEvent = response.details.createQualifierEvent;
                if (response.type === Response_ResponseType.Success) {
                    console.info(`Successfully created qualifier!`);
                    this.emit("createdQualifier", {});
                }
                else {
                    console.error(`Failed to create qualifier. Message: ${createQualifierEvent.message}`);
                    this.emit("failedToCreateQualifier", {});
                }
            }
            else if (response.details.oneofKind === "updateQualifierEvent") {
                const modifyQualifier = response.details.updateQualifierEvent;
                if (response.type === Response_ResponseType.Success) {
                    console.info(`Successfully modified qualifier!`);
                    this.emit("updatedQualifier", {});
                }
                else {
                    console.error(`Failed to update qualifier. Message: ${modifyQualifier.message}`);
                    this.emit("failedToUpdateQualifier", {});
                }
            }
            else if (response.details.oneofKind === "deleteQualifierEvent") {
                const deleteQualifierEvent = response.details.deleteQualifierEvent;
                if (response.type === Response_ResponseType.Success) {
                    console.info(`Successfully deleted qualifier!`);
                    this.emit("deletedQualifier", {});
                }
                else {
                    console.error(`Failed to delete qualifier. Message: ${deleteQualifierEvent.message}`);
                    this.emit("failedToDeleteQualifier", {});
                }
            }
        }
        else if (packet.packet.oneofKind === "push") {
            const push = packet.packet.push;
            if (push.data.oneofKind === "songFinished") {
                this.emit("songFinished", push.data.songFinished);
            }
            else if (push.data.oneofKind === "realtimeScore") {
                this.emit("realtimeScore", push.data.realtimeScore);
            }
        }
    };
    // --- State Actions --- //
    updateUser = async (tournamentId, user) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "updateUser",
                updateUser: {
                    tournamentId,
                    user,
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    createMatch = async (tournamentId, match) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "createMatch",
                createMatch: {
                    tournamentId,
                    match,
                },
            },
        });
        // Checking oneOfKind here helps typescript identify what type of response it is
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    addUserToMatch = async (tournamentId, matchId, userId) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "addUserToMatch",
                addUserToMatch: {
                    tournamentId,
                    matchId,
                    userId
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    removeUserFromMatch = async (tournamentId, matchId, userId) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "removeUserFromMatch",
                removeUserFromMatch: {
                    tournamentId,
                    matchId,
                    userId
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    setMatchLeader = async (tournamentId, matchId, userId) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "setMatchLeader",
                setMatchLeader: {
                    tournamentId,
                    matchId,
                    userId
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    setMatchMap = async (tournamentId, matchId, map) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "setMatchMap",
                setMatchMap: {
                    tournamentId,
                    matchId,
                    map
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    deleteMatch = async (tournamentId, matchId) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "deleteMatch",
                deleteMatch: {
                    tournamentId,
                    matchId,
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    createQualifierEvent = async (tournamentId, event) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "createQualifierEvent",
                createQualifierEvent: {
                    tournamentId,
                    event,
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    setQualifierName = async (tournamentId, qualifierId, qualifierName) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "setQualifierName",
                setQualifierName: {
                    tournamentId,
                    qualifierId,
                    qualifierName
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    setQualifierImage = async (tournamentId, qualifierId, qualifierImage) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "setQualifierImage",
                setQualifierImage: {
                    tournamentId,
                    qualifierId,
                    qualifierImage
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    setQualifierInfoChannel = async (tournamentId, qualifierId, infoChannel) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "setQualifierInfoChannel",
                setQualifierInfoChannel: {
                    tournamentId,
                    qualifierId,
                    infoChannel
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    setQualifierFlags = async (tournamentId, qualifierId, qualifierFlags) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "setQualifierFlags",
                setQualifierFlags: {
                    tournamentId,
                    qualifierId,
                    qualifierFlags
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    setQualifierLeaderboardSort = async (tournamentId, qualifierId, qualifierLeaderboardSort) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "setQualifierLeaderboardSort",
                setQualifierLeaderboardSort: {
                    tournamentId,
                    qualifierId,
                    qualifierLeaderboardSort
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    addQualifierMaps = async (tournamentId, qualifierId, maps) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "addQualifierMaps",
                addQualifierMaps: {
                    tournamentId,
                    qualifierId,
                    maps
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    updateQualifierMap = async (tournamentId, qualifierId, map) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "updateQualifierMap",
                updateQualifierMap: {
                    tournamentId,
                    qualifierId,
                    map
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    removeQualifierMap = async (tournamentId, qualifierId, mapId) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "removeQualifierMap",
                removeQualifierMap: {
                    tournamentId,
                    qualifierId,
                    mapId
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    deleteQualifierEvent = async (tournamentId, qualifierId) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "deleteQualifierEvent",
                deleteQualifierEvent: {
                    tournamentId,
                    qualifierId,
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    addAuthorizedUser = async (tournamentId, discordId, permissionFlags) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "addAuthorizedUser",
                addAuthorizedUser: {
                    tournamentId,
                    discordId,
                    permissionFlags
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    removeAuthorizedUser = async (tournamentId, discordId) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "removeAuthorizedUser",
                removeAuthorizedUser: {
                    tournamentId,
                    discordId
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    getAuthorizedUsers = async (tournamentId) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "getAuthorizedUsers",
                getAuthorizedUsers: {
                    tournamentId,
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    getDiscordInfo = async (tournamentId, discordId) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "getDiscordInfo",
                getDiscordInfo: {
                    tournamentId,
                    discordId
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    getBotTokensForUser = async (ownerDiscordId) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "getBotTokensForUser",
                getBotTokensForUser: {
                    ownerDiscordId
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    generateBotToken = async (username) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "generateBotToken",
                generateBotToken: {
                    username
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    revokeBotToken = async (botTokenGuid) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "revokeBotToken",
                revokeBotToken: {
                    botTokenGuid
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    createTournament = async (tournament) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "createTournament",
                createTournament: {
                    tournament,
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    setTournamentName = async (tournamentId, tournamentName) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "setTournamentName",
                setTournamentName: {
                    tournamentId,
                    tournamentName
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    setTournamentImage = async (tournamentId, tournamentImage) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "setTournamentImage",
                setTournamentImage: {
                    tournamentId,
                    tournamentImage
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    setTournamentEnableTeams = async (tournamentId, enableTeams) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "setTournamentEnableTeams",
                setTournamentEnableTeams: {
                    tournamentId,
                    enableTeams
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    setTournamentEnablePools = async (tournamentId, enablePools) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "setTournamentEnablePools",
                setTournamentEnablePools: {
                    tournamentId,
                    enablePools
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    setTournamentShowTournamentButton = async (tournamentId, showTournamentButton) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "setTournamentShowTournamentButton",
                setTournamentShowTournamentButton: {
                    tournamentId,
                    showTournamentButton
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    setTournamentShowQualifierButton = async (tournamentId, showQualifierButton) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "setTournamentShowQualifierButton",
                setTournamentShowQualifierButton: {
                    tournamentId,
                    showQualifierButton
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    setTournamentAllowUnauthorizedView = async (tournamentId, allowUnauthorizedView) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "setTournamentAllowUnauthorizedView",
                setTournamentAllowUnauthorizedView: {
                    tournamentId,
                    allowUnauthorizedView
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    setTournamentScoreUpdateFrequency = async (tournamentId, scoreUpdateFrequency) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "setTournamentScoreUpdateFrequency",
                setTournamentScoreUpdateFrequency: {
                    tournamentId,
                    scoreUpdateFrequency
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    setTournamentBannedMods = async (tournamentId, bannedMods) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: 'setTournamentBannedMods',
                setTournamentBannedMods: {
                    tournamentId,
                    bannedMods
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    addTournamentTeam = async (tournamentId, team) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "addTournamentTeam",
                addTournamentTeam: {
                    tournamentId,
                    team
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    setTournamentTeamName = async (tournamentId, teamId, teamName) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "setTournamentTeamName",
                setTournamentTeamName: {
                    tournamentId,
                    teamId,
                    teamName
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    setTournamentTeamImage = async (tournamentId, teamId, teamImage) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "setTournamentTeamImage",
                setTournamentTeamImage: {
                    tournamentId,
                    teamId,
                    teamImage
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    removeTournamentTeam = async (tournamentId, teamId) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "removeTournamentTeam",
                removeTournamentTeam: {
                    tournamentId,
                    teamId
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    addTournamentPool = async (tournamentId, pool) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "addTournamentPool",
                addTournamentPool: {
                    tournamentId,
                    pool
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    setTournamentPoolName = async (tournamentId, poolId, poolName) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "setTournamentPoolName",
                setTournamentPoolName: {
                    tournamentId,
                    poolId,
                    poolName
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    addTournamentPoolMaps = async (tournamentId, poolId, maps) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "addTournamentPoolMaps",
                addTournamentPoolMaps: {
                    tournamentId,
                    poolId,
                    maps
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    updateTournamentPoolMap = async (tournamentId, poolId, map) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "updateTournamentPoolMap",
                updateTournamentPoolMap: {
                    tournamentId,
                    poolId,
                    map
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    removeTournamentPoolMap = async (tournamentId, poolId, mapId) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "removeTournamentPoolMap",
                removeTournamentPoolMap: {
                    tournamentId,
                    poolId,
                    mapId
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    removeTournamentPool = async (tournamentId, poolId) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "removeTournamentPool",
                removeTournamentPool: {
                    tournamentId,
                    poolId
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    deleteTournament = async (tournamentId) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "deleteTournament",
                deleteTournament: {
                    tournamentId,
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
    addServer = async (server, authToken) => {
        const response = await this.sendRequest({
            type: {
                oneofKind: "addServer",
                addServer: {
                    server,
                    authToken: authToken ?? "",
                },
            },
        });
        if (response.length <= 0) {
            throw new Error("Server timed out");
        }
        return response[0].response;
    };
}
