import { CustomEventEmitter } from "./custom-event-emitter.js";
import { v4 as uuidv4 } from "uuid";
import { Response_ResponseType } from "./models/responses.js";
export class StateManager extends CustomEventEmitter {
    state;
    self;
    constructor() {
        super();
        this.self = uuidv4();
        this.state = {
            tournaments: [],
            knownServers: [],
        };
    }
    // --- Packet handler --- //
    handlePacket(packet) {
        if (packet.packet.oneofKind === "event") {
            const event = packet.packet.event;
            switch (event.changedObject.oneofKind) {
                case "userAdded": {
                    this.userConnected(event.changedObject.userAdded.tournamentId, event.changedObject.userAdded.user);
                    break;
                }
                case "userUpdated": {
                    this.userUpdated(event.changedObject.userUpdated.tournamentId, event.changedObject.userUpdated.user);
                    break;
                }
                case "userLeft": {
                    this.userDisconnected(event.changedObject.userLeft.tournamentId, event.changedObject.userLeft.user);
                    break;
                }
                case "matchCreated": {
                    this.matchCreated(event.changedObject.matchCreated.tournamentId, event.changedObject.matchCreated.match);
                    break;
                }
                case "matchUpdated": {
                    this.matchUpdated(event.changedObject.matchUpdated.tournamentId, event.changedObject.matchUpdated.match);
                    break;
                }
                case "matchDeleted": {
                    this.matchDeleted(event.changedObject.matchDeleted.tournamentId, event.changedObject.matchDeleted.match);
                    break;
                }
                case "qualifierCreated": {
                    this.qualifierEventCreated(event.changedObject.qualifierCreated.tournamentId, event.changedObject.qualifierCreated.event);
                    break;
                }
                case "qualifierUpdated": {
                    this.qualifierEventUpdated(event.changedObject.qualifierUpdated.tournamentId, event.changedObject.qualifierUpdated.event);
                    break;
                }
                case "qualifierDeleted": {
                    this.qualifierEventDeleted(event.changedObject.qualifierDeleted.tournamentId, event.changedObject.qualifierDeleted.event);
                    break;
                }
                case "tournamentCreated": {
                    this.tournamentCreated(event.changedObject.tournamentCreated.tournament);
                    break;
                }
                case "tournamentUpdated": {
                    this.tournamentUpdated(event.changedObject.tournamentUpdated.tournament);
                    break;
                }
                case "tournamentDeleted": {
                    this.tournamentDeleted(event.changedObject.tournamentDeleted.tournament);
                    break;
                }
                case "serverAdded": {
                    this.serverAdded(event.changedObject.serverAdded.server);
                    break;
                }
                case "serverDeleted": {
                    this.serverDeleted(event.changedObject.serverDeleted.server);
                    break;
                }
            }
        }
        else if (packet.packet.oneofKind === "response") {
            const response = packet.packet.response;
            if (response.details.oneofKind === "connect") {
                const connect = response.details.connect;
                if (response.type === Response_ResponseType.Success) {
                    this.state = connect.state;
                }
            }
            else if (response.details.oneofKind === "join") {
                const join = response.details.join;
                if (response.type === Response_ResponseType.Success) {
                    this.state = join.state;
                    this.self = join.selfGuid;
                }
            }
        }
    }
    // --- Helpers --- //
    getSelfGuid() {
        return this.self;
    }
    getTournaments() {
        return this.state.tournaments;
    }
    getTournament(id) {
        return this.state.tournaments.find((x) => x.guid === id);
    }
    getUsers(tournamentId) {
        return this.getTournament(tournamentId)?.users;
    }
    getUser(tournamentId, userId) {
        return this.getUsers(tournamentId)?.find((x) => x.guid === userId);
    }
    getMatches(tournamentId) {
        return this.getTournament(tournamentId)?.matches;
    }
    getMatch(tournamentId, matchId) {
        return this.getMatches(tournamentId)?.find((x) => x.guid === matchId);
    }
    getQualifiers(tournamentId) {
        return this.getTournament(tournamentId)?.qualifiers;
    }
    getQualifier(tournamentId, qualifierId) {
        return this.getQualifiers(tournamentId)?.find((x) => x.guid === qualifierId);
    }
    getKnownServers() {
        return this.state.knownServers;
    }
    // --- Event handlers --- //
    userConnected = (tournamentId, user) => {
        const tournament = this.getTournament(tournamentId);
        tournament.users = [...tournament.users, user];
        this.emit("userConnected", [user, tournament]);
    };
    userUpdated = (tournamentId, user) => {
        const tournament = this.getTournament(tournamentId);
        const index = tournament.users.findIndex((x) => x.guid === user.guid);
        tournament.users[index] = user;
        this.emit("userUpdated", [user, tournament]);
    };
    userDisconnected = (tournamentId, user) => {
        const tournament = this.getTournament(tournamentId);
        tournament.users = tournament.users.filter((x) => x.guid !== user.guid);
        this.emit("userDisconnected", [user, tournament]);
    };
    matchCreated = (tournamentId, match) => {
        const tournament = this.getTournament(tournamentId);
        tournament.matches = [...tournament.matches, match];
        this.emit("matchCreated", [match, tournament]);
    };
    matchUpdated = (tournamentId, match) => {
        const tournament = this.getTournament(tournamentId);
        const index = tournament.matches.findIndex((x) => x.guid === match.guid);
        tournament.matches[index] = match;
        this.emit("matchUpdated", [match, tournament]);
    };
    matchDeleted = (tournamentId, match) => {
        const tournament = this.getTournament(tournamentId);
        tournament.matches = tournament.matches.filter((x) => x.guid !== match.guid);
        this.emit("matchDeleted", [match, tournament]);
    };
    qualifierEventCreated = (tournamentId, event) => {
        const tournament = this.getTournament(tournamentId);
        tournament.qualifiers = [...tournament.qualifiers, event];
        this.emit("qualifierCreated", [event, tournament]);
    };
    qualifierEventUpdated = (tournamentId, event) => {
        const tournament = this.getTournament(tournamentId);
        const index = tournament.qualifiers.findIndex((x) => x.guid === event.guid);
        tournament.qualifiers[index] = event;
        this.emit("qualifierUpdated", [event, tournament]);
    };
    qualifierEventDeleted = (tournamentId, event) => {
        const tournament = this.getTournament(tournamentId);
        tournament.qualifiers = tournament.qualifiers.filter((x) => x.guid !== event.guid);
        this.emit("qualifierDeleted", [event, tournament]);
    };
    tournamentCreated = (tournament) => {
        this.state.tournaments = [...this.state.tournaments, tournament];
        this.emit("tournamentCreated", tournament);
    };
    tournamentUpdated = (tournament) => {
        const index = this.state.tournaments.findIndex((x) => x.guid === tournament.guid);
        this.state.tournaments[index] = tournament;
        this.emit("tournamentUpdated", tournament);
    };
    tournamentDeleted = (tournament) => {
        this.state.tournaments = this.state.tournaments.filter((x) => x.guid !== tournament.guid);
        this.emit("tournamentDeleted", tournament);
    };
    serverAdded = (server) => {
        this.state.knownServers = [...this.state.knownServers, server];
        this.emit("serverAdded", server);
    };
    serverDeleted = (server) => {
        this.state.knownServers = this.state.knownServers.filter((x) => `${server.address}:${server.port}` !== `${x.address}:${x.port}`);
        this.emit("serverDeleted", server);
    };
}
